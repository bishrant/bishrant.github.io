(function(){(this||window).webpackJsonp.registerAbsMids({"arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl":"+5nk","arcgis-js-api/views/3d/interactive/dragUtils/projectScreenToMap":"+soW","arcgis-js-api/views/3d/webgl-engine/materials/NativeLineMaterial":"+v1/","arcgis-js-api/views/3d/webgl-engine/lib/screenSizePerspectiveUtils":"+wMf","arcgis-js-api/renderers/support/clickToleranceUtils":"/E+R","esri/layers/graphics/dehydratedFeatureComparison":"/Vvo","arcgis-js-api/views/3d/webgl-engine/shaders/NativeLine.glsl":"1eB5","arcgis-js-api/views/3d/interactive/editingTools/manipulatorUtils":"1eTA","arcgis-js-api/views/3d/webgl-engine/lib/doublePrecisionUtils":"1f+t","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl":"2o+p","esri/symbols/support/defaultsJSON":"35hF","arcgis-js-api/symbols/support/defaultsJSON":"35hF","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl":"3PFg","arcgis-js-api/views/3d/webgl-engine/lib/BoundingInfo":"3RHn","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/util/DecodeNormal.glsl":"3iei","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/Transform.glsl":"3kdR","arcgis-js-api/views/3d/webgl-engine/lib/GeometryUtil":"4ziW","arcgis-js-api/views/3d/interactive/manipulatorUtils":"5T2R","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/HighlightData.glsl":"5UTK","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl":"6t3m","arcgis-js-api/views/3d/webgl-engine/core/shaderModules/interfaces":"7Aei","arcgis-js-api/core/libs/gl-matrix-2/factories/mat4f32":"7Yqx","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl":"7zqm","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl":"8TPw","arcgis-js-api/views/3d/webgl-engine/lib/intersectorUtils":"9DjX","arcgis-js-api/views/3d/webgl-engine/lib/GLMaterialTexture":"9FJH","arcgis-js-api/views/3d/interactive/dragUtils/dragAtLocation":"9ZJu","arcgis-js-api/views/3d/webgl-engine/shaders/DefaultMaterial.glsl":"9dVJ","arcgis-js-api/views/3d/interactive/editingTools/graphicTransform3D/GraphicXYTransform":"A3J9","arcgis-js-api/views/3d/webgl-engine/lib/IntervalUtilities":"AASg","arcgis-js-api/views/3d/webgl-engine/lib/GeometryData":"AgDx","arcgis-js-api/views/interactive/Manipulator3D":"AvU8","arcgis-js-api/views/3d/layers/graphics/graphicUtils":"BwdQ","arcgis-js-api/views/3d/webgl-engine/materials/WaterGLMaterial":"CP88","arcgis-js-api/views/3d/webgl-engine/shaders/DefaultMaterialTechnique":"CsnI","arcgis-js-api/views/3d/webgl-engine/lib/GeometryRecord":"Cvn+","arcgis-js-api/views/3d/webgl-engine/shaders/ColorMaterial.glsl":"DFuO","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl":"DKwL","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl":"E/g4","arcgis-js-api/views/3d/webgl-engine/lib/DefaultTextureUnits":"EiD/","arcgis-js-api/views/3d/webgl-engine/shaders/ColorMaterialTechnique":"EiS2","arcgis-js-api/views/3d/webgl-engine/lib/Material":"FNtW","arcgis-js-api/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique":"FQ4r","arcgis-js-api/views/3d/interactive/editingTools/graphicTransform3D/GraphicZTransform":"HAIt","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl":"HkM8","arcgis-js-api/views/3d/webgl-engine/materials/internal/bufferWriterUtils":"ILj8","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl":"JvNb","arcgis-js-api/views/3d/webgl-engine/lib/AutoDisposable":"KRuQ","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateMainLighting.glsl":"KT2k","arcgis-js-api/views/3d/webgl-engine/materials/internal/DefaultBufferWriter":"LZD4","arcgis-js-api/views/interactive/GraphicManipulator":"N78w","arcgis-js-api/views/support/drapedUtils":"NbdF","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl":"PaEL","arcgis-js-api/views/3d/webgl-engine/materials/renderers/utils":"PwS/","arcgis-js-api/views/3d/webgl-engine/materials/RibbonLineMaterial":"RC9r","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/WaterDistortion.glsl":"RdU/","arcgis-js-api/views/3d/webgl-engine/lib/Camera":"RsYQ","arcgis-js-api/views/3d/webgl-engine/shaders/RibbonLineTechnique":"SNs2","arcgis-js-api/views/3d/interactive/editingTools/graphicReshape3D/reshapeUtils":"TCLX","arcgis-js-api/views/3d/webgl-engine/materials/DefaultMaterial":"TP2F","arcgis-js-api/views/3d/interactive/editingTools/graphicTransform3D/GraphicScaleRotateTransform":"UdQa","arcgis-js-api/views/3d/webgl-engine/shaders/sources/shaderRepository":"VVgn","arcgis-js-api/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule":"W/V4","arcgis-js-api/views/3d/webgl-engine/lib/IdGen":"W0kZ","arcgis-js-api/views/3d/webgl-engine/collections/Component/Material/shader/DecodeSymbolColor.glsl":"WMxK","esri/geometry/support/aaBoundingBox":"WRgd","arcgis-js-api/geometry/support/aaBoundingBox":"WRgd","arcgis-js-api/views/interactive/ManipulatorCollection":"X0Jx","arcgis-js-api/views/interactive/InteractiveToolBase":"X7Ps","arcgis-js-api/core/tsSupport/makeTemplateObjectHelper":"XsoR","arcgis-js-api/views/3d/webgl-engine/lib/ResizableFloat32Array":"YseA","arcgis-js-api/views/3d/interactive/editingTools/graphicTransform3D/graphicTransform3DToolConfig":"Z0CD","arcgis-js-api/views/3d/webgl-engine/lib/Object3D":"ZJC8","arcgis-js-api/views/3d/webgl-engine/lib/Layer":"ZO6V","arcgis-js-api/layers/graphics/dehydratedFeatures":"ZcgO","esri/layers/graphics/dehydratedFeatures":"ZcgO","arcgis-js-api/views/3d/webgl-engine/materials/renderers/MergedRenderer":"ZeO9","arcgis-js-api/views/3d/webgl-engine/core/shaderModules/ShaderBuilder":"aExC","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl":"aluc","arcgis-js-api/views/3d/webgl-engine/materials/VisualVariableMaterialParameters":"ama6","arcgis-js-api/views/interactive/dragUtils/dragHandlers":"bF8Q","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/DiscardOrAdjustAlpha.glsl":"bMXq","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl":"cGZG","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl":"cj3m","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl":"cmSR","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl":"cqYc","arcgis-js-api/views/3d/interactive/editingTools/graphicReshape3D/ReshapeOperation":"d0uo","esri/symbols/support/defaults":"dXKx","arcgis-js-api/symbols/support/defaults":"dXKx","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl":"eYHx","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/Slice.glsl":"fese","arcgis-js-api/views/3d/webgl-engine/lib/DefaultVertexAttributeLocations":"ff/U","arcgis-js-api/views/3d/webgl-engine/shaders/NativeLineTechnique":"hlOa","arcgis-js-api/views/3d/webgl-engine/materials/internal/waterMaterialUtils":"hsRy","arcgis-js-api/views/3d/webgl-engine/shaders/WaterSurface.glsl":"jl7D","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl":"juLw","arcgis-js-api/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration":"lBa0","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl":"lF8C","arcgis-js-api/views/3d/webgl-engine/lib/Intersector":"m4lJ","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl":"mOGR","arcgis-js-api/views/3d/webgl-engine/lib/Octree":"mYMs","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl":"nJqw","arcgis-js-api/views/3d/webgl-engine/shaders/RibbonLine.glsl":"ne9J","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl":"nobt","arcgis-js-api/views/3d/webgl-engine/materials/ColorMaterial":"o5p5","arcgis-js-api/core/libs/gl-matrix-2/mat4f32":"oZZu","arcgis-js-api/views/3d/interactive/editingTools/graphicTransform3D/GraphicTransform3DTool":"pESw","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl":"pLfv","arcgis-js-api/views/3d/webgl-engine/materials/renderers/Instance":"pbva","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl":"piY7","arcgis-js-api/views/3d/interactive/editingTools":"qkUi","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl":"quQL","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/util/DoublePrecision.glsl":"r0i9","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl":"rCq5","arcgis-js-api/views/3d/interactive/editingTools/graphicMove3D/GraphicMove3DTool":"runW","arcgis-js-api/views/3d/webgl-engine/lib/WebGLDriverTest":"rxbe","arcgis-js-api/views/3d/webgl-engine/materials/internal/MaterialUtil":"s6rJ","arcgis-js-api/views/interactive/dragUtils/dragActions":"sGGe","arcgis-js-api/views/3d/interactive/editingTools/graphicTransform3D/GraphicXYAxisTransform":"synF","arcgis-js-api/views/3d/webgl-engine/lib/GLMaterial":"tUyH","esri/geometry/support/quantizationUtils":"u90+","arcgis-js-api/geometry/support/quantizationUtils":"u90+","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl":"uEh2","arcgis-js-api/views/3d/webgl-engine/materials/renderers/InstancedRenderer":"uNX8","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl":"uci5","arcgis-js-api/views/3d/webgl-engine/materials/WaterTechnique":"v22c","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl":"vGsU","arcgis-js-api/views/interactive/dragUtils/screenDragToMap":"wOtw","arcgis-js-api/views/3d/support/imageUtils":"weRx","arcgis-js-api/views/3d/interactive/Manipulator3D":"woUR","arcgis-js-api/views/3d/interactive/editingTools/graphicTransform3D/dragUtils":"wrIU","arcgis-js-api/views/3d/interactive/editingTools/graphicReshape3D/GraphicReshape3DTool":"x82K","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl":"xDGw","arcgis-js-api/views/3d/webgl-engine/lib/HighlightUtils":"xsp2","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl":"ybGv","arcgis-js-api/views/3d/webgl-engine/lib/Geometry":"ys4y","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl":"zdOl"})})(),(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{"+5nk":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("HkM8"),n("eYHx"),n("KT2k"),n("piY7"),n("quQL"),n("cj3m"),n("7Aei")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c){var u,d,p,f,h,v,m,g,y,b,x;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateSceneLighting=function(e,t){var _=e.fragment;e.include(a.EvaluateMainLighting),e.include(r.EvaluateAmbientOcclusion,t),t.usePBR&&e.include(o.PhysicallyBasedRendering,t),e.include(i.EvaluateAmbientLighting,t),t.receiveShadows&&e.include(l.ReadShadowMap,t),_.uniforms.add("lightingGlobalFactor","float"),_.uniforms.add("ambientBoostFactor","float"),t.useOldSceneLightInterface?(e.include(s.PiUtils),_.code.add(c.glsl(u||(u=n(["\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;  // 1 / GAMMA_SRGB\n\n    vec3 evaluateSceneLightingExt(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\n      // evaluate the main light\n      #if defined(TREE_RENDERING)\n        // Special case for tree rendering:\n        // We shift the Lambert lobe to the back, allowing it to reach part of the hemisphere\n        // facing away from the light. The idea is to get an effect where light is transmitted\n        // through the tree.\n        float minDot = -0.5;\n        float dotRange = 1.0 - minDot;\n        float dotNormalization = 0.66; // guessed & hand tweaked value, for an exact value we could precompute an integral over the sphere\n\n        float dotVal = dotNormalization * (clamp(-dot(normal, lightingMainDirection), 1.0 - dotRange, 1.0) - minDot) * (1.0 / dotRange);\n      #else\n        float dotVal = clamp(-dot(normal, lightingMainDirection), 0.0, 1.0);\n      #endif\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      vec3 mainLight = (1.0 - shadow) * lightingMainIntensity * dotVal;\n      vec3 ambientLight = calculateAmbientIrradiance(normal, ssao);\n\n      // inverse gamma correction on the albedo color\n      vec3 albedoGammaC = pow(albedo, vec3(GAMMA_SRGB));\n\n      // physically correct BRDF normalizes by PI\n      vec3 totalLight = mainLight + ambientLight + additionalLight;\n      totalLight = min(totalLight, vec3(PI, PI, PI));\n      vec3 outColor = vec3((albedoGammaC / PI) * (totalLight));\n\n      // apply gamma correction to the computed color\n      outColor = pow(outColor, vec3(1.0/GAMMA_SRGB));\n\n      return outColor;\n    }\n  "],["\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;  // 1 / GAMMA_SRGB\n\n    vec3 evaluateSceneLightingExt(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\n      // evaluate the main light\n      #if defined(TREE_RENDERING)\n        // Special case for tree rendering:\n        // We shift the Lambert lobe to the back, allowing it to reach part of the hemisphere\n        // facing away from the light. The idea is to get an effect where light is transmitted\n        // through the tree.\n        float minDot = -0.5;\n        float dotRange = 1.0 - minDot;\n        float dotNormalization = 0.66; // guessed & hand tweaked value, for an exact value we could precompute an integral over the sphere\n\n        float dotVal = dotNormalization * (clamp(-dot(normal, lightingMainDirection), 1.0 - dotRange, 1.0) - minDot) * (1.0 / dotRange);\n      #else\n        float dotVal = clamp(-dot(normal, lightingMainDirection), 0.0, 1.0);\n      #endif\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      vec3 mainLight = (1.0 - shadow) * lightingMainIntensity * dotVal;\n      vec3 ambientLight = calculateAmbientIrradiance(normal, ssao);\n\n      // inverse gamma correction on the albedo color\n      vec3 albedoGammaC = pow(albedo, vec3(GAMMA_SRGB));\n\n      // physically correct BRDF normalizes by PI\n      vec3 totalLight = mainLight + ambientLight + additionalLight;\n      totalLight = min(totalLight, vec3(PI, PI, PI));\n      vec3 outColor = vec3((albedoGammaC / PI) * (totalLight));\n\n      // apply gamma correction to the computed color\n      outColor = pow(outColor, vec3(1.0/GAMMA_SRGB));\n\n      return outColor;\n    }\n  "]))))):(_.code.add(c.glsl(0===t.viewingMode?d||(d=n(["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        vec3 shadingNormalWorld = normalize(vPosWorld);\n        float vndl = -dot(shadingNormalWorld, lightingMainDirection);\n\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "],["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        vec3 shadingNormalWorld = normalize(vPosWorld);\n        float vndl = -dot(shadingNormalWorld, lightingMainDirection);\n\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "])):p||(p=n(["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        float vndl = -dot(vec3(0.0, 0.0, 1.0), lightingMainDirection);\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "],["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        float vndl = -dot(vec3(0.0, 0.0, 1.0), lightingMainDirection);\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "])))),_.code.add(c.glsl(f||(f=n(["\n      vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\n        float additionalAmbientScale = _oldHeuristicLighting(vPosWorld);\n        return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n      }\n    "],["\n      vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\n        float additionalAmbientScale = _oldHeuristicLighting(vPosWorld);\n        return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n      }\n    "])))),t.usePBR?(_.code.add(c.glsl(v||(v=n(["\n      // The albedo color of the ground used in the environment illumination algorithm\n      const float GROUND_REFLECTANCE = 0.2; //This is the set value of the diffuse reflectance of the ground surface\n\n      const float GAMMA_SRGB = 2.1;\n      const float INV_GAMMA_SRGB = 0.4761904;  // 1 / GAMMA_SRGB\n      "],["\n      // The albedo color of the ground used in the environment illumination algorithm\n      const float GROUND_REFLECTANCE = 0.2; //This is the set value of the diffuse reflectance of the ground surface\n\n      const float GAMMA_SRGB = 2.1;\n      const float INV_GAMMA_SRGB = 0.4761904;  // 1 / GAMMA_SRGB\n      "])))),_.code.add(c.glsl(m||(m=n(["\n      vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, float _roughness, float _metalness, vec3 _emission, float _reflectance, float additionalAmbientIrradiance)\n      {\n        // Calculate half vector between view and light direction\n        vec3 viewDirection = -viewDir;\n        vec3 mainLightDirection = -lightingMainDirection;\n        vec3 h = normalize(viewDirection + mainLightDirection);\n\n        PBRShadingInfo inputs;\n        inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\n        inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\n        inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\n        inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\n        inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\n        vec3 reflectedView = normalize(reflect(viewDirection, normal));\n        inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\n\n        inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\n        inputs.groundReflectance = vec3(GROUND_REFLECTANCE);\n        inputs.ssao = ssao;\n\n        inputs.roughness = clamp(_roughness * _roughness, 0.001, 0.99);\n        inputs.metalness = _metalness;\n      "],["\n      vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, float _roughness, float _metalness, vec3 _emission, float _reflectance, float additionalAmbientIrradiance)\n      {\n        // Calculate half vector between view and light direction\n        vec3 viewDirection = -viewDir;\n        vec3 mainLightDirection = -lightingMainDirection;\n        vec3 h = normalize(viewDirection + mainLightDirection);\n\n        PBRShadingInfo inputs;\n        inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\n        inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\n        inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\n        inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\n        inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\n        vec3 reflectedView = normalize(reflect(viewDirection, normal));\n        inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\n\n        inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\n        inputs.groundReflectance = vec3(GROUND_REFLECTANCE);\n        inputs.ssao = ssao;\n\n        inputs.roughness = clamp(_roughness * _roughness, 0.001, 0.99);\n        inputs.metalness = _metalness;\n      "])))),_.code.add(c.glsl(g||(g=n(["\n        inputs.f0 = (0.16 * _reflectance * _reflectance) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\n        inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0)); // more accurate then using  f90 = 1.0\n        inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);\n      "],["\n        inputs.f0 = (0.16 * _reflectance * _reflectance) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\n        inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0)); // more accurate then using  f90 = 1.0\n        inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);\n      "])))),_.code.add(c.glsl(y||(y=n(["\n        vec3 ambientDir = normalize(vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2],\n                                      - 5.0 * normalGround[0] - normalGround[2] * normalGround[1],\n                                        normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]));\n\n        inputs.NdotAmbDir = abs(dot(normal, ambientDir));\n\n        // Calculate the irradiance components: sun, fill lights and the sky.\n        vec3 mainLightIrradianceComponent  = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\n        vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\n        // calculateAmbientIrradiance for localView and additionalLight for gloabalView\n        vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\n\n        // Assemble the overall irradiance of the sky that illuminates the surface\n        inputs.skyIrradianceToSurface    = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n        // Assemble the overall irradiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky irradiance by the groundReflectance\n        inputs.groundIrradianceToSurface = inputs.groundReflectance * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n      "],["\n        vec3 ambientDir = normalize(vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2],\n                                      - 5.0 * normalGround[0] - normalGround[2] * normalGround[1],\n                                        normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]));\n\n        inputs.NdotAmbDir = abs(dot(normal, ambientDir));\n\n        // Calculate the irradiance components: sun, fill lights and the sky.\n        vec3 mainLightIrradianceComponent  = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\n        vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\n        // calculateAmbientIrradiance for localView and additionalLight for gloabalView\n        vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\n\n        // Assemble the overall irradiance of the sky that illuminates the surface\n        inputs.skyIrradianceToSurface    = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n        // Assemble the overall irradiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky irradiance by the groundReflectance\n        inputs.groundIrradianceToSurface = inputs.groundReflectance * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n      "])))),_.code.add(c.glsl(b||(b=n(["\n        vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\n        vec3 horizonRingH = normalize(viewDirection + horizonRingDir);\n        inputs.NdotH_Horizon = dot(normal, horizonRingH);\n\n        vec3 mainLightRadianceComponent  = normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\n        vec3 horizonLightRadianceComponent = normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\n        vec3 ambientLightRadianceComponent = calculateAmbientRadiance(ssao) + additionalLight; // calculateAmbientRadiance for localView and additionalLight for gloabalView\n\n        // Assemble the overall radiance of the sky that illuminates the surface\n        inputs.skyRadianceToSurface    =  ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\n        // Assemble the overall radiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky radince by the groundReflectance\n        inputs.groundRadianceToSurface = inputs.groundReflectance * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\n\n        // Calculate average ambient radiance - this is used int the gamut mapping part to deduce the black level that is soft compressed\n        inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + inputs.groundReflectance[1]);\n        "],["\n        vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\n        vec3 horizonRingH = normalize(viewDirection + horizonRingDir);\n        inputs.NdotH_Horizon = dot(normal, horizonRingH);\n\n        vec3 mainLightRadianceComponent  = normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\n        vec3 horizonLightRadianceComponent = normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\n        vec3 ambientLightRadianceComponent = calculateAmbientRadiance(ssao) + additionalLight; // calculateAmbientRadiance for localView and additionalLight for gloabalView\n\n        // Assemble the overall radiance of the sky that illuminates the surface\n        inputs.skyRadianceToSurface    =  ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\n        // Assemble the overall radiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky radince by the groundReflectance\n        inputs.groundRadianceToSurface = inputs.groundReflectance * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\n\n        // Calculate average ambient radiance - this is used int the gamut mapping part to deduce the black level that is soft compressed\n        inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + inputs.groundReflectance[1]);\n        "])))),_.code.add(c.glsl(x||(x=n(["\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));\n        return outColor;\n      }\n    "],["\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));\n        return outColor;\n      }\n    "]))))):_.code.add(c.glsl(h||(h=n(["\n      vec3 evaluateSceneLighting(vec3 normalWorld, vec3 baseColor, float mainLightShadow, float ambientOcclusion, vec3 additionalLight)\n      {\n        vec3 mainLighting = evaluateMainLighting(normalWorld, mainLightShadow);\n        vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ambientOcclusion);\n        // inverse gamma correction on the base color\n        float gamma = 2.1;\n        vec3 baseColorLinear = pow(baseColor, vec3(gamma));\n\n        // physically correct BRDF normalizes by PI\n        const float PI = 3.14159;\n        vec3 totalLight = mainLighting + ambientLighting + additionalLight;\n        totalLight = min(totalLight, vec3(PI, PI, PI));\n        vec3 outColor = vec3((baseColorLinear / PI) * totalLight);\n\n        // apply gamma correction to the computed color\n        outColor = pow(outColor, vec3(1.0/gamma));\n\n        return outColor;\n      }\n      "],["\n      vec3 evaluateSceneLighting(vec3 normalWorld, vec3 baseColor, float mainLightShadow, float ambientOcclusion, vec3 additionalLight)\n      {\n        vec3 mainLighting = evaluateMainLighting(normalWorld, mainLightShadow);\n        vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ambientOcclusion);\n        // inverse gamma correction on the base color\n        float gamma = 2.1;\n        vec3 baseColorLinear = pow(baseColor, vec3(gamma));\n\n        // physically correct BRDF normalizes by PI\n        const float PI = 3.14159;\n        vec3 totalLight = mainLighting + ambientLighting + additionalLight;\n        totalLight = min(totalLight, vec3(PI, PI, PI));\n        vec3 outColor = vec3((baseColorLinear / PI) * totalLight);\n\n        // apply gamma correction to the computed color\n        outColor = pow(outColor, vec3(1.0/gamma));\n\n        return outColor;\n      }\n      "])))))}}).apply(null,i))||(e.exports=r)},"+soW":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("TMur"),n("xoE+"),n("jBNx"),n("0LE5"),n("Rdxj"),n("DtIM"),n("aWgr"),n("mmEe"),n("GG08"),n("4p4v")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d){function p(e){return function(t,n){var i=e.toMap(t);return i&&c.pointToPoint(i,i,n)?i:null}}function f(e,t){var n=r.createScreenPointArray(),i=d.create(),a=o.vec3f64.create();return function(o,s){r.screenPointObjectToArray(o,n),d.fromScreenAtEye(e.state.camera,n,i);var l=e.renderCoordsHelper.intersectManifoldClosestSilhouette(i,t,a);return e.renderCoordsHelper.fromRenderCoords(l,s)}}Object.defineProperty(t,"__esModule",{value:!0}),t.createForGraphic=function(e,t,n){switch(s.getGraphicEffectiveElevationMode(t)){case"on-the-ground":return p(e);case"absolute-height":return f(e,e.toMap(n,{include:[t]}).z);default:return null}},t.createForGraphicAtLocation=function(e,t,n){switch(s.getGraphicEffectiveElevationMode(t)){case"on-the-ground":return p(e);case"absolute-height":return f(e,n.z);default:return null}},t.createOnTheGround=p,t.createAbsoluteHeight=f,t.createCameraAlignedWorldUp=function(e,t){var s=o.vec3f64.create();if(!e.renderCoordsHelper.toRenderCoords(t,s))return null;var c=a.vec3.length(s),p=o.vec3f64.create();e.renderCoordsHelper.worldUpAtPosition(s,p);var f=u.create(),h=r.createScreenPointArray(),v=o.vec3f64.create(),m=d.create();return function(t,o){var g=e.state.camera,y=a.vec3.cross(f,p,a.vec3.subtract(v,s,g.eye));return a.vec3.cross(y,y,p),u.fromPositionAndNormal(s,y,f),d.fromScreenAtEye(g,r.screenPointObjectToArray(t,h),m),u.intersectRay(f,m,v)?(a.vec3.subtract(v,v,s),l.vector.projectPoint(p,v,v),"global"===e.viewingMode&&a.vec3.length(v)*i.sign(a.vec3.dot(p,v))<.001-c&&a.vec3.subtract(v,a.vec3.scale(v,p,.001),s),a.vec3.add(v,v,s),e.renderCoordsHelper.fromRenderCoords(v,new n.Point,o)):null}}}).apply(null,i))||(e.exports=r)},"+v1/":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("2Atf"),n("qsST"),n("LxLY"),n("jBNx"),n("W9tT"),n("0LE5"),n("Rdxj"),n("aWgr"),n("VfPl"),n("rjU6"),n("+nCE"),n("tUyH"),n("FNtW"),n("CIy2"),n("ILj8"),n("LZD4"),n("s6rJ"),n("ZeO9"),n("hlOa")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_){var S=r.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial"),P=function(e){function t(t,n){var i=e.call(this,n)||this;return i.techniqueConfig=new _.NativeLineTechniqueConfiguration,i.params=b.copyParameters(t,M),i}return n(t,e),t.prototype.setParameterValues=function(e){var t=this.params;for(var n in e)t[n]=e[n];this.notifyDirty("matChanged")},t.prototype.getParameters=function(){return this.params},t.prototype.getTechniqueConfig=function(e){this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.transparent=this.params.color[3]<1||this.params.width<1;var t=a.isSome(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=t,this.techniqueConfig.stippleOffColorEnabled=t&&a.isSome(this.params.stippleOffColor),this.techniqueConfig.stippleIntegerRepeatsEnabled=t&&this.params.stippleIntegerRepeats,this.techniqueConfig},t.prototype.getPassParameters=function(){return this.params},t.prototype.intersect=function(e,t,n,i,r,a,o,s,l){l?this.intersectLineGeometry(e,t,n,i,o):b.intersectDrapedRenderLineGeometry(e,i,a,1,o)},t.prototype.intersectLineGeometry=function(e,t,n,i,r){if(i.options.selectionMode&&!p.isAllHidden(t.componentVisibilities,e.componentOffsets)){if(!m.isTranslationMatrix(n))return void S.error("intersection assumes a translation-only matrix");var a=e.data.getVertexAttr().position.data,o=i.camera,c=F;s.vec2.copy(c,i.point),l.vec3.set(G[0],c[0]-2,c[1]+2,0),l.vec3.set(G[1],c[0]+2,c[1]+2,0),l.vec3.set(G[2],c[0]+2,c[1]-2,0),l.vec3.set(G[3],c[0]-2,c[1]-2,0);for(var d=0;d<4;d++)o.unprojectPoint(G[d],B[d]);u.plane.fromPoints(o.eye,B[0],B[1],H),u.plane.fromPoints(o.eye,B[1],B[2],U),u.plane.fromPoints(o.eye,B[2],B[3],q),u.plane.fromPoints(o.eye,B[3],B[0],k);var f=Number.MAX_VALUE;for(d=0;d<a.length-5;d+=3)if(D[0]=a[d]+n[12],D[1]=a[d+1]+n[13],D[2]=a[d+2]+n[14],R[0]=a[d+3]+n[12],R[1]=a[d+4]+n[13],R[2]=a[d+5]+n[14],!(u.plane.signedDistance(H,D)<0&&u.plane.signedDistance(H,R)<0||u.plane.signedDistance(U,D)<0&&u.plane.signedDistance(U,R)<0||u.plane.signedDistance(q,D)<0&&u.plane.signedDistance(q,R)<0||u.plane.signedDistance(k,D)<0&&u.plane.signedDistance(k,R)<0)){if(o.projectPoint(D,z),o.projectPoint(R,L),z[2]<0&&L[2]>0){l.vec3.subtract(T,D,R);var h=-u.plane.signedDistance((v=o.frustum).planes[4],D)/l.vec3.dot(T,v.planes[4]);l.vec3.scale(T,T,h),l.vec3.add(D,D,T),o.projectPoint(D,z)}else if(z[2]>0&&L[2]<0){var v;l.vec3.subtract(T,R,D),h=-u.plane.signedDistance((v=o.frustum).planes[4],R)/l.vec3.dot(T,v.planes[4]),l.vec3.scale(T,T,h),l.vec3.add(R,R,T),o.projectPoint(R,L)}else if(z[2]<0&&L[2]<0)continue;z[2]=0,L[2]=0;var g=u.lineSegment.distance2(u.lineSegment.fromPoints(z,L,V),c);g<f&&(f=g,l.vec3.copy(E,D),l.vec3.copy(j,R))}var y=i.rayBeginPoint,b=i.rayEndPoint;if(f<4){var x=Number.MAX_VALUE;if(u.lineSegment.closestLineSegmentPoint(u.lineSegment.fromPoints(E,j,V),u.lineSegment.fromPoints(y,b,N),I)){l.vec3.subtract(I,I,y);var _=l.vec3.length(I);l.vec3.scale(I,I,1/_),x=_/l.vec3.distance(y,b)}r(x,I)}}},t.prototype.computeAttachmentOrigin=function(e,t){var n=e.data,i="getVertexAttr"in n?n.getVertexAttr():"vertexAttr"in n?n.vertexAttr:null;return i?f.computeAttachmentOriginLines(i[m.VertexAttrConstants.POSITION],null,t):null},t.prototype.createBufferWriter=function(){var e=this.params.vertexColors?y.PositionColorLayout:y.PositionLayout;return a.isNone(this.params.stipplePattern)?new y.DefaultBufferWriter(e):new O(e.clone().vec3f(m.VertexAttrConstants.AUXPOS1))},t.prototype.createRenderer=function(e,t){return new x(e,t,this)},t.prototype.getGLMaterials=function(){return{color:A,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:C}},t}(v.Material),w=function(e){function t(t){var n=e.call(this,t)||this;return n.output=t.output,n.updateParameters(),n}return n(t,e),t.prototype.updateParameters=function(){this.technique=this.techniqueRep.acquireAndReleaseExisting(_.NativeLineTechnique,this.material.getTechniqueConfig(this.output),this.technique)},t.prototype.beginSlot=function(e){return 4===e},t.prototype.getProgram=function(){return this.technique.program},t.prototype.getPrograms=function(){return null},t.prototype.bind=function(e,t){e.bindProgram(this.technique.program),this.technique.bindPipelineState(e),this.technique.bindPass(e,this.material.getPassParameters(),t)},t.prototype.release=function(){},t.prototype.bindView=function(e){this.technique.bindDraw(e)},t.prototype.bindInstance=function(e){this.technique.program.setUniformMatrix4fv("model",e.transformation)},t.prototype.getDrawMode=function(){return 1},t}(h.GLMaterial),A=function(e){function t(t){return e.call(this,i({},t,{output:0}))||this}return n(t,e),t}(w),C=function(e){function t(t){return e.call(this,i({},t,{output:4}))||this}return n(t,e),t}(w),O=function(){function e(e){this.vertexBufferLayout=e}return e.prototype.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},e.prototype.elementCount=function(e){return e.indices[m.VertexAttrConstants.POSITION].length},e.prototype.write=function(e,t,n,i){g.writeDefaultAttributes(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,n,i),this.writeAuxpos1(e,t,n,i)},e.prototype.writeAuxpos1=function(e,t,n,i){var r=n.getField(m.VertexAttrConstants.AUXPOS1,d.BufferViewVec3f),a=t.indices[m.VertexAttrConstants.POSITION],o=t.vertexAttr[m.VertexAttrConstants.POSITION].data,s=e.transformation,l=r.typedBufferStride,c=r.typedBuffer;i*=l;for(var u=0;u<a.length;u+=2)for(var p=3*a[u],f=o[p],h=o[p+1],v=o[p+2],g=s[0]*f+s[4]*h+s[8]*v+s[12],y=s[1]*f+s[5]*h+s[9]*v+s[13],b=s[2]*f+s[6]*h+s[10]*v+s[14],x=0;x<2;++x)c[i]=g,c[i+1]=y,c[i+2]=b,i+=l},e}(),M={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null},D=c.vec3f64.create(),R=c.vec3f64.create(),T=c.vec3f64.create(),I=c.vec3f64.create(),z=o.createRenderScreenPointArray3(),L=o.createRenderScreenPointArray3(),E=c.vec3f64.create(),j=c.vec3f64.create(),V=u.lineSegment.create(),N=u.lineSegment.create(),F=c.vec3f64.create(),G=[o.createRenderScreenPointArray3(),o.createRenderScreenPointArray3(),o.createRenderScreenPointArray3(),o.createRenderScreenPointArray3()],B=[c.vec3f64.create(),c.vec3f64.create(),c.vec3f64.create(),c.vec3f64.create()],H=u.plane.create(),U=u.plane.create(),q=u.plane.create(),k=u.plane.create();return P}).apply(null,i))||(e.exports=r)},"+wMf":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xoE+"),n("wPX3")],void 0===(r=(function(e,t,n,i){function r(e){return Math.abs(e*e*e)}function a(e,t,n,i){void 0===i&&(i=d);var a=n.parameters,o=n.paddingPixelsOverride;return i.scale=Math.min(a.divisor/(t-a.offset),1),i.factor=r(e),i.minPixelSize=a.minPixelSize,i.paddingPixels=o,i}function o(e,t){return 0===e?t.minPixelSize:t.minPixelSize*(1+2*t.paddingPixels/e)}function s(e,t){return Math.max(n.lerp(e*t.scale,e,t.factor),o(e,t))}function l(e,t,n){var i=a(e,t,n);return i.minPixelSize=0,i.paddingPixels=0,s(1,i)}Object.defineProperty(t,"__esModule",{value:!0}),t.getSettings=function(e){return new c(e,t.defaultDescription)},t.getLabelSettings=function(e){var n=t.defaultDescription.curvatureDependent;return new c(e,{curvatureDependent:{min:{curvature:n.min.curvature,tiltAngle:n.min.tiltAngle,scaleFallOffFactor:u.curvatureDependent.min.scaleFallOffFactor},max:{curvature:n.max.curvature,tiltAngle:n.max.tiltAngle,scaleFallOffFactor:u.curvatureDependent.max.scaleFallOffFactor}},scaleStart:t.defaultDescription.scaleStart,scaleFallOffRange:t.defaultDescription.scaleFallOffRange,minPixelSize:u.minPixelSize})},t.perspectiveFactor=r,t.scaleFactor=a,t.applyScaleFactor=s,t.applyScaleFactorVec2=function(e,t,i){void 0===i&&(i=[0,0]);var r=Math.min(Math.max(t.scale,o(e[1],t)/e[1]),1);return i[0]=n.lerp(e[0]*r,e[0],t.factor),i[1]=n.lerp(e[1]*r,e[1],t.factor),i},t.precomputeScale=l,t.precomputeScaleFactor=function(e,t,n,i){return i.scale=l(e,t,n),i.factor=0,i.minPixelSize=n.parameters.minPixelSize,i.paddingPixels=n.paddingPixelsOverride,i},t.applyPrecomputedScaleFactorVec2=function(e,t,n){void 0===n&&(n=[0,0]);var i=Math.min(Math.max(t.scale,o(e[1],t)/e[1]),1);return n[0]=e[0]*i,n[1]=e[1]*i,n},t.scale=function(e,t,n,i){return s(e,a(t,n,i))};var c=function(){function e(e,t,n,i){void 0===n&&(n={camera:{distance:0,fovY:0},divisor:0,offset:0,minPixelSize:0,paddingPixels:0}),this.viewingMode=e,this.description=t,this.parameters=n,this._paddingPixelsOverride=i,"local"===this.viewingMode?(this.coverageCompensation=this.surfaceCoverageCompensationLocal,this.calculateCurvatureDependentParameters=this.calculateCurvatureDependentParametersLocal):(this.coverageCompensation=this.surfaceCoverageCompensationGlobal,this.calculateCurvatureDependentParameters=this.calculateCurvatureDependentParametersGlobal)}return Object.defineProperty(e.prototype,"paddingPixelsOverride",{get:function(){return this._paddingPixelsOverride||this.parameters.paddingPixels},enumerable:!0,configurable:!0}),e.prototype.update=function(e){return!(this.parameters&&this.parameters.camera.fovY===e.fovY&&this.parameters.camera.distance===e.distance||(this.calculateParameters(e,this.parameters),0))},e.prototype.overridePadding=function(t){return t!==this.paddingPixelsOverride?new e(this.viewingMode,this.description,this.parameters,t):this},e.prototype.calculateParameters=function(e,t){var n=this.description,i=n.scaleStart,r=n.scaleFallOffRange,a=n.minPixelSize,o=e.fovY,s=e.distance,l=this.calculateCurvatureDependentParameters(e),c=this.coverageCompensation(e,l),u=l.tiltAngle,d=l.scaleFallOffFactor,p=Math.sin(u)*s,f=.5*Math.PI-u-o*(.5-i*c),h=p/Math.cos(f),v=(h-d*(p/Math.cos(f+o*r*c)))/(1-d);return t.camera.fovY=e.fovY,t.camera.distance=e.distance,t.offset=v,t.divisor=h-v,t.minPixelSize=a,t},e.prototype.calculateCurvatureDependentParametersLocal=function(e,t){return void 0===t&&(t=p),t.tiltAngle=this.description.curvatureDependent.min.tiltAngle,t.scaleFallOffFactor=this.description.curvatureDependent.min.scaleFallOffFactor,t},e.prototype.calculateCurvatureDependentParametersGlobal=function(e,t){void 0===t&&(t=p);var r=this.description.curvatureDependent,a=1+e.distance/i.earthRadius,o=Math.sqrt(a*a-1),s=[r.min.curvature,r.max.curvature],l=s[0],c=n.clamp((o-l)/(s[1]-l),0,1),u=[r.min,r.max],d=u[0],f=u[1];return t.tiltAngle=n.lerp(d.tiltAngle,f.tiltAngle,c),t.scaleFallOffFactor=n.lerp(d.scaleFallOffFactor,f.scaleFallOffFactor,c),t},e.prototype.surfaceCoverageCompensationLocal=function(e,t){return(e.fovY-t.tiltAngle)/e.fovY},e.prototype.surfaceCoverageCompensationGlobal=function(e,t){var n=i.earthRadius*i.earthRadius,r=t.tiltAngle+.5*Math.PI,a=e.fovY,o=e.distance,s=o*o+n-2*Math.cos(r)*o*i.earthRadius,l=Math.sqrt(s),c=Math.sqrt(s-n);return(Math.acos(c/l)-Math.asin(i.earthRadius/(l/Math.sin(r)))+.5*a)/a},e}();t.defaultDescription={curvatureDependent:{min:{curvature:n.deg2rad(10),tiltAngle:n.deg2rad(12),scaleFallOffFactor:.5},max:{curvature:n.deg2rad(70),tiltAngle:n.deg2rad(40),scaleFallOffFactor:.8}},scaleStart:.3,scaleFallOffRange:.65,minPixelSize:0};var u={curvatureDependent:{min:{scaleFallOffFactor:.7},max:{scaleFallOffFactor:.95}},minPixelSize:14};t.copyParameters=function(e,t){return t.camera.distance=e.camera.distance,t.camera.fovY=e.camera.fovY,t.divisor=e.divisor,t.offset=e.offset,t.minPixelSize=e.minPixelSize,t};var d={scale:0,factor:0,minPixelSize:0,paddingPixels:0},p={tiltAngle:0,scaleFallOffFactor:0}}).apply(null,i))||(e.exports=r)},"/E+R":function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){function n(e,t){return t&&t.xoffset?Math.max(e,Math.abs(t.xoffset)):t&&t.yoffset?Math.max(e,Math.abs(t.yoffset)):e}function i(e,t){return"number"==typeof e?e:e&&e.stops&&e.stops.length?function(e){for(var t=0,n=0,i=0;i<e.length;i++){var r=e[i].size;"number"==typeof r&&(t+=r,n++)}return t/n}(e.stops):t}function r(e,t){if(!t)return e;var n=t.filter((function(e){return"size"===e.type})).map((function(t){var n=t.minSize;return(i(t.maxSize,e)+i(n,e))/2})),r=0,a=n.length;if(0===a)return e;for(var o=0;o<a;o++)r+=n[o];var s=Math.floor(r/a);return Math.max(s,e)}Object.defineProperty(t,"__esModule",{value:!0}),t.calculateTolerance=function(e){if(!e)return 6;var t="visualVariables"in e?r(6,e.visualVariables):6;if("simple"===e.type)return n(t,e.symbol);if("unique-value"===e.type){var i=t;return e.uniqueValueInfos.forEach((function(e){i=n(i,e.symbol)})),i}if("class-breaks"===e.type){var a=t;return e.classBreakInfos.forEach((function(e){a=n(a,e.symbol)})),a}return t}}).apply(null,i))||(e.exports=r)},"/Vvo":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("pcDC"),n("LxLY")],void 0===(r=(function(e,t,n,i){function r(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(var n=0;n<e.length;n++){var i=e[n],r=t[n];if(i.length!==r.length)return!1;for(var a=0;a<i.length;a++)if(i[a]!==r[a])return!1}return!0}function a(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(var n=0;n<e.length;n++)if(!r(e[n],t[n]))return!1;return!0}function o(e,t){return e===t||e&&t&&e.equals(t)}Object.defineProperty(t,"__esModule",{value:!0}),t.equals=function(e,t){return e===t||null!=e&&null!=t&&e.objectId===t.objectId&&!!function(e,t){if(e===t)return!0;if(i.isNone(e)||i.isNone(t))return!1;if(e.type!==t.type)return!1;switch(e.type){case"point":return function(e,t){return!!o(e.spatialReference,t.spatialReference)&&e.x===t.x&&e.y===t.y&&e.z===t.z&&e.m===t.m}(e,t);case"extent":return function(e,t){return e.hasZ===t.hasZ&&e.hasM===t.hasM&&!!o(e.spatialReference,t.spatialReference)&&e.xmin===t.xmin&&e.ymin===t.ymin&&e.zmin===t.zmin&&e.xmax===t.xmax&&e.ymax===t.ymax&&e.zmax===t.zmax}(e,t);case"polyline":return function(e,t){return e.hasZ===t.hasZ&&e.hasM===t.hasM&&!!o(e.spatialReference,t.spatialReference)&&a(e.paths,t.paths)}(e,t);case"polygon":return function(e,t){return e.hasZ===t.hasZ&&e.hasM===t.hasM&&!!o(e.spatialReference,t.spatialReference)&&a(e.rings,t.rings)}(e,t);case"multipoint":return function(e,t){return e.hasZ===t.hasZ&&e.hasM===t.hasM&&!!o(e.spatialReference,t.spatialReference)&&r(e.points,t.points)}(e,t);case"mesh":return!1;default:return void n.neverReached(e)}}(e.geometry,t.geometry)&&!!function(e,t){if(e===t)return!0;if(!e||!t)return!1;var n=Object.keys(e),i=Object.keys(t);if(n.length!==i.length)return!1;for(var r=0,a=n;r<a.length;r++){var o=a[r];if(e[o]!==t[o])return!1}return!0}(e.attributes,t.attributes)}}).apply(null,i))||(e.exports=r)},"1eB5":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("fese"),n("3kdR"),n("6t3m"),n("5UTK"),n("7zqm"),n("7Aei"),n("aExC")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c){var u,d,p,f,h;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new c.ShaderBuilder;return t.include(r.Transform,{linearDepth:!1}),t.include(a.VertexColor,e),t.include(s.LineStipple,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),t.vertex.code.add(l.glsl(u||(u=n(["\n    void main(void) {\n      vpos = (model * vec4(position, 1.0)).xyz;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n  "],["\n    void main(void) {\n      vpos = (model * vec4(position, 1.0)).xyz;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n  "])))),e.stippleEnabled&&(t.attributes.add("auxpos1","vec3"),t.vertex.uniforms.add("ndcToPixel","vec2"),t.vertex.code.add(l.glsl(d||(d=n(["\n    vec4 vpos2 = transformPosition(proj, view, (model * vec4(auxpos1, 1.0)).xyz);\n    float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);\n\n    stipplePatternUv = lineSegmentPixelSize * stipplePatternPixelSizeInv;\n    ","\n\n    // Cancel out perspective correct interpolation because we want this length the really represent\n    // the screen distance\n    stipplePatternUv *= gl_Position.w;\n    "],["\n    vec4 vpos2 = transformPosition(proj, view, (model * vec4(auxpos1, 1.0)).xyz);\n    float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);\n\n    stipplePatternUv = lineSegmentPixelSize * stipplePatternPixelSizeInv;\n    ","\n\n    // Cancel out perspective correct interpolation because we want this length the really represent\n    // the screen distance\n    stipplePatternUv *= gl_Position.w;\n    "])),e.stippleIntegerRepeatsEnabled?"stipplePatternUv = floor(stipplePatternUv + 0.5);":""))),t.vertex.code.add(l.glsl(p||(p=n(["\n  }\n  "],["\n  }\n  "])))),0===e.output&&(t.include(i.Slice,e),t.fragment.uniforms.add("constantColor","vec4").add("alphaCoverage","float"),t.fragment.code.add(l.glsl(f||(f=n(["\n    void main() {\n      discardBySlice(vpos);\n\n      vec4 color = ",";\n\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n\n      gl_FragColor = highlightSlice(blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha), vpos);\n    }\n    "],["\n    void main() {\n      discardBySlice(vpos);\n\n      vec4 color = ",";\n\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n\n      gl_FragColor = highlightSlice(blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha), vpos);\n    }\n    "])),e.attributeColor?"vcolor":"constantColor"))),4===e.output&&(t.include(i.Slice,e),t.include(o.HighlightData),t.fragment.uniforms.add("depthTex","sampler2D"),t.fragment.uniforms.add("highlightViewportPixelSz","vec4"),t.fragment.code.add(l.glsl(h||(h=n(["\n    void main() {\n      discardBySlice(vpos);\n\n      discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n\n      gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n    }\n    "],["\n    void main() {\n      discardBySlice(vpos);\n\n      discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n\n      gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n    }\n    "]))))),t}}).apply(null,i))||(e.exports=r)},"1eTA":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("LxLY"),n("FXVB"),n("1m5D"),n("Rdxj"),n("O7NG"),n("DtIM"),n("XsEe"),n("woUR"),n("5T2R"),n("9ZJu"),n("+soW"),n("ys4y"),n("4ziW"),n("+v1/"),n("RC9r"),n("N78w"),n("wOtw")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y){function b(e,t){return"on-the-ground"!==t.mode&&!(n.isNone(e.geometry)||!e.geometry.hasZ)}Object.defineProperty(t,"__esModule",{value:!0}),t.createGraphicMoveXYManipulator=function(e,t){return new g.GraphicManipulator({graphic:t,view:e,selectable:!0,cursor:"move"})},t.createGraphicMoveXYScreenDragToMap=function(e,t,i){return y.createXYConstrainedFromProject(p.createForGraphic(e,t.graphic,i.start),n.expect(t.graphic.geometry).spatialReference)},t.canMoveZ=b,t.createGraphicMoveZManipulator=function(e){var t=e.graphic,n=e.view;if(!l.enableEditing3D())return null;var d=s.getGraphicEffectiveElevationInfo(t);if(!b(t,d))return null;var p=[a.vec3f64.fromValues(0,0,0),a.vec3f64.fromValues(0,0,90)],g=new f(h.createPolylineGeometry(p),"move-z"),y=h.createConeGeometry(20,5,16,!1),x=new f(y),_=[a.vec3f64.fromValues(0,0,0),a.vec3f64.fromValues(0,0,110)],S=r.mat4f64.create();i.mat4.translate(S,S,[0,0,90]),i.mat4.rotateX(S,S,Math.PI/2);var P=r.mat4f64.create();i.mat4.translate(P,P,[0,0,90]),i.mat4.rotateX(P,P,Math.PI/2),i.mat4.scale(P,P,[1.2,1.2,1]);var w=a.vec3f64.fromValues(0,.5,.9),A=o.vec4f64.fromValues(w[0],w[1],w[2],1),C=function(e){return e>1?function(e){var t=new m({color:A,width:e},"move-z");return t.renderOccluded=4,t}(e):function(){var e=new v({color:A},"move-z");return e.renderOccluded=4,e}()};return new c.Manipulator3D({view:n,renderObjects:[{geometry:g,material:C(1),stateMask:1},{geometry:x,transform:S,material:u.createManipulatorMaterial(w,1),stateMask:1},{geometry:g,material:C(2),stateMask:2},{geometry:x,transform:P,material:u.createManipulatorMaterial(w,1),stateMask:2}],collisionType:{type:"line",paths:[_]},autoScaleRenderObjects:!1,worldSized:!1,radius:4,selectable:!1,cursor:"ns-resize",elevationInfo:d,worldOriented:null==e.worldOriented||e.worldOriented,visible:!!t.visible})},t.createGraphicMoveZScreenDragToMap=function(e,t){var n=y.createZConstrainedFromProject(p.createCameraAlignedWorldUp(e,t.elevationAlignedLocation),t.location.spatialReference);return d.dragAtLocation(e,n,t.elevationAlignedLocation)}}).apply(null,i))||(e.exports=r)},"1f+t":function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){function n(e,t,n){for(var i=0;i<n;++i)t[2*i]=e[i],t[2*i+1]=e[i]-t[2*i]}Object.defineProperty(t,"__esModule",{value:!0}),t.encodeDouble=function(e,t){r[0]=e,r[1]=e-r[0],t[0]=r[0],t[1]=r[1]},t.encodeDoubleArray=n,t.decodeDoubleArray=function(e,t,n){for(var i=0;i<n;++i)t[i]=e[2*i]+e[2*i+1]},t.encodeDoubleArraySplit=function(e,t,a,o){for(var s=0;s<o;++s)i[0]=e[s],n(i,r,1),t[s]=r[0],a[s]=r[1]};var i=new Float64Array(1),r=new Float32Array(2)}).apply(null,i))||(e.exports=r)},"2o+p":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o,s,l,c,u;Object.defineProperty(t,"__esModule",{value:!0}),t.ScreenSizePerspective=function(e){e.vertex.code.add(i.glsl(r||(r=n(["\n    float screenSizePerspectiveMinSize(float size, vec4 factor) {\n      float nonZeroSize = 1.0 - step(size, 0.0);\n\n      return (\n        factor.z * (\n          1.0 +\n          nonZeroSize *                // Multiply by nzs ensures if size is 0, then we ignore\n                                      // proportionally scaled padding\n          2.0 * factor.w / (\n            size + (1.0 - nonZeroSize) // Adding 1 - nzs ensures we divide either by size, or by 1\n          )\n        )\n      );\n    }\n  "],["\n    float screenSizePerspectiveMinSize(float size, vec4 factor) {\n      float nonZeroSize = 1.0 - step(size, 0.0);\n\n      return (\n        factor.z * (\n          1.0 +\n          nonZeroSize *                // Multiply by nzs ensures if size is 0, then we ignore\n                                      // proportionally scaled padding\n          2.0 * factor.w / (\n            size + (1.0 - nonZeroSize) // Adding 1 - nzs ensures we divide either by size, or by 1\n          )\n        )\n      );\n    }\n  "])))),e.vertex.code.add(i.glsl(a||(a=n(["\n    float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n      return absCosAngle * absCosAngle * absCosAngle;\n    }\n  "],["\n    float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n      return absCosAngle * absCosAngle * absCosAngle;\n    }\n  "])))),e.vertex.code.add(i.glsl(o||(o=n(["\n    vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n      return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\n    }\n  "],["\n    vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n      return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\n    }\n  "])))),e.vertex.code.add(i.glsl(s||(s=n(["\n    float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n      return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n    }\n  "],["\n    float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n      return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n    }\n  "])))),e.vertex.code.add(i.glsl(l||(l=n(["\n    float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "],["\n    float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "])))),e.vertex.code.add(i.glsl(c||(c=n(["\n    vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n      return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n    }\n  "],["\n    vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n      return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n    }\n  "])))),e.vertex.code.add(i.glsl(u||(u=n(["\n    vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "],["\n    vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "]))))}}).apply(null,i))||(e.exports=r)},"35hF":function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.defaultColor=[252,146,31,255],t.defaultOutlineColor=[153,153,153,255],t.defaultPointSymbolJSON={type:"esriSMS",style:"esriSMSCircle",size:6,color:t.defaultColor,outline:{width:.75,color:[153,153,153,255]}},t.defaultPolylineSymbolJSON={type:"esriSLS",style:"esriSLSSolid",width:.75,color:t.defaultColor},t.defaultPolygonSymbolJSON={type:"esriSFS",style:"esriSFSSolid",color:[252,146,31,196],outline:{width:.75,color:[255,255,255,191]}},t.defaultTextSymbolJSON={type:"esriTS",color:[255,255,255,255],font:{family:"arial-unicode-ms",size:10,weight:"bold"},horizontalAlignment:"center",kerning:!0,haloColor:[0,0,0,255],haloSize:1,rotated:!1,text:"",xoffset:0,yoffset:0,angle:0},t.errorPointSymbolJSON={type:"esriSMS",style:"esriSMSCircle",color:[0,0,0,255],outline:null,size:10.5},t.errorPolylineSymbolJSON={type:"esriSLS",style:"esriSLSSolid",color:[0,0,0,255],width:1.5},t.errorPolygonSymbolJSON={type:"esriSFS",style:"esriSFSSolid",color:[0,0,0,255],outline:null}}).apply(null,i))||(e.exports=r)},"3PFg":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){function r(e,t){(t.vvSize||t.vvColor)&&e.attributes.add("instanceFeatureAttribute","vec4"),t.vvSize?(e.vertex.uniforms.add("vvSizeMinSize","vec3"),e.vertex.uniforms.add("vvSizeMaxSize","vec3"),e.vertex.uniforms.add("vvSizeOffset","vec3"),e.vertex.uniforms.add("vvSizeFactor","vec3"),e.vertex.uniforms.add("vvSymbolRotationMatrix","mat3"),e.vertex.uniforms.add("vvSymbolAnchor","vec3"),e.vertex.code.add(i.glsl(a||(a=n(["\n      vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {\n        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\n        return vec4(vvSymbolRotationMatrix * (vvScale * (position + vvSymbolAnchor)), 1.0);\n      }\n    "],["\n      vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {\n        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\n        return vec4(vvSymbolRotationMatrix * (vvScale * (position + vvSymbolAnchor)), 1.0);\n      }\n    "])))),e.vertex.code.add(i.glsl(o||(o=n(["\n      const float eps = 1.192092896e-07;\n      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {\n        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize + eps, vvSizeMaxSize);\n        return vec4(vvSymbolRotationMatrix * _normal / vvScale, 1.0);\n      }\n\n      vec4 vvLocalNormal(vec3 _normal) {\n        return vvTransformNormal(_normal, instanceFeatureAttribute);\n      }\n\n      vec4 localPosition() {\n        return vvTransformPosition(position, instanceFeatureAttribute);\n      }\n    "],["\n      const float eps = 1.192092896e-07;\n      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {\n        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize + eps, vvSizeMaxSize);\n        return vec4(vvSymbolRotationMatrix * _normal / vvScale, 1.0);\n      }\n\n      vec4 vvLocalNormal(vec3 _normal) {\n        return vvTransformNormal(_normal, instanceFeatureAttribute);\n      }\n\n      vec4 localPosition() {\n        return vvTransformPosition(position, instanceFeatureAttribute);\n      }\n    "]))))):e.vertex.code.add(i.glsl(s||(s=n(["\n      vec4 localPosition() { return vec4(position, 1.0); }\n\n      vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }\n    "],["\n      vec4 localPosition() { return vec4(position, 1.0); }\n\n      vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }\n    "])))),t.vvColor?(e.vertex.defines.addInt("VV_COLOR_N",8),e.vertex.code.add(i.glsl(l||(l=n(["\n      uniform float vvColorValues[VV_COLOR_N];\n      uniform vec4 vvColorColors[VV_COLOR_N];\n\n      vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\n        float value = featureAttribute.y;\n        if (value <= values[0]) {\n          return colors[0];\n        }\n\n        for (int i = 1; i < VV_COLOR_N; ++i) {\n          if (values[i] >= value) {\n            float f = (value - values[i-1]) / (values[i] - values[i-1]);\n            return mix(colors[i-1], colors[i], f);\n          }\n        }\n        return colors[VV_COLOR_N - 1];\n      }\n\n      vec4 vvColor() {\n        return vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\n      }\n    "],["\n      uniform float vvColorValues[VV_COLOR_N];\n      uniform vec4 vvColorColors[VV_COLOR_N];\n\n      vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\n        float value = featureAttribute.y;\n        if (value <= values[0]) {\n          return colors[0];\n        }\n\n        for (int i = 1; i < VV_COLOR_N; ++i) {\n          if (values[i] >= value) {\n            float f = (value - values[i-1]) / (values[i] - values[i-1]);\n            return mix(colors[i-1], colors[i], f);\n          }\n        }\n        return colors[VV_COLOR_N - 1];\n      }\n\n      vec4 vvColor() {\n        return vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\n      }\n    "]))))):e.vertex.code.add(i.glsl(c||(c=n(["\n      vec4 vvColor() { return vec4(1.0); }\n    "],["\n      vec4 vvColor() { return vec4(1.0); }\n    "]))))}var a,o,s,l,c;Object.defineProperty(t,"__esModule",{value:!0}),t.VisualVariables=r,function(e){function t(e,t){t.vvSizeEnabled&&(e.setUniform3fv("vvSizeMinSize",t.vvSizeMinSize),e.setUniform3fv("vvSizeMaxSize",t.vvSizeMaxSize),e.setUniform3fv("vvSizeOffset",t.vvSizeOffset),e.setUniform3fv("vvSizeFactor",t.vvSizeFactor)),t.vvColorEnabled&&(e.setUniform1fv("vvColorValues",t.vvColorValues),e.setUniform4fv("vvColorColors",t.vvColorColors))}e.bindUniformsWithOpacity=function(e,n){t(e,n),n.vvOpacityEnabled&&(e.setUniform1fv("vvOpacityValues",n.vvOpacityValues),e.setUniform1fv("vvOpacityOpacities",n.vvOpacityOpacities))},e.bindUniformsForSymbols=function(e,n){t(e,n),n.vvSizeEnabled&&(e.setUniform3fv("vvSymbolAnchor",n.vvSymbolAnchor),e.setUniformMatrix3fv("vvSymbolRotationMatrix",n.vvSymbolRotationMatrix))}}(r=t.VisualVariables||(t.VisualVariables={}))}).apply(null,i))||(e.exports=r)},"3RHn":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("KBgh"),n("0LE5"),n("Rdxj"),n("CIy2")],void 0===(r=(function(e,t,n,i,r,a){var o=function(){function e(t,n,o,s){this.primitiveIndices=t,this._numIndexPerPrimitive=n,this.indices=o,this._position=s,this.center=r.vec3f64.create(),a.assert(t.length>=1),a.assert(o.length%this._numIndexPerPrimitive==0),a.assert(o.length>=t.length*this._numIndexPerPrimitive),a.assert(3===this._position.size||4===this._position.size);var l=this._position,c=l.data,u=l.offsetIdx,d=l.strideIdx,p=0,f=t.length,h=u+d*o[this._numIndexPerPrimitive*t[p]];for(e.tmpIndices.clear(),e.tmpIndices.push(h),this.bbMin=r.vec3f64.fromValues(c[h],c[h+1],c[h+2]),this.bbMax=r.vec3f64.clone(this.bbMin);p<f;++p)for(var v=this._numIndexPerPrimitive*t[p],m=0;m<this._numIndexPerPrimitive;++m){e.tmpIndices.push(h=u+d*o[v+m]);var g=c[h];this.bbMin[0]=Math.min(g,this.bbMin[0]),this.bbMax[0]=Math.max(g,this.bbMax[0]),g=c[h+1],this.bbMin[1]=Math.min(g,this.bbMin[1]),this.bbMax[1]=Math.max(g,this.bbMax[1]),g=c[h+2],this.bbMin[2]=Math.min(g,this.bbMin[2]),this.bbMax[2]=Math.max(g,this.bbMax[2])}i.vec3.lerp(this.center,this.bbMin,this.bbMax,.5),this.bsRadius=.5*Math.max(Math.max(this.bbMax[0]-this.bbMin[0],this.bbMax[1]-this.bbMin[1]),this.bbMax[2]-this.bbMin[2]);var y=this.bsRadius*this.bsRadius;for(p=0;p<e.tmpIndices.length;++p){var b=c[h=e.tmpIndices.data[p]]-this.center[0],x=c[h+1]-this.center[1],_=c[h+2]-this.center[2],S=b*b+x*x+_*_;if(!(S<=y)){var P=Math.sqrt(S),w=.5*(P-this.bsRadius);this.bsRadius=this.bsRadius+w,y=this.bsRadius*this.bsRadius;var A=w/P;this.center[0]+=b*A,this.center[1]+=x*A,this.center[2]+=_*A}}e.tmpIndices.clear()}return e.prototype.getCenter=function(){return this.center},e.prototype.getBSRadius=function(){return this.bsRadius},e.prototype.getBBMin=function(){return this.bbMin},e.prototype.getBBMax=function(){return this.bbMax},e.prototype.getPrimitiveIndices=function(){return this.primitiveIndices},e.prototype.getIndices=function(){return this.indices},e.prototype.getPosition=function(){return this._position},e.prototype.getChildren=function(){if(this._children)return this._children;if(i.vec3.squaredDistance(this.bbMin,this.bbMax)>1){for(var t=i.vec3.lerp(r.vec3f64.create(),this.bbMin,this.bbMax,.5),n=this.primitiveIndices.length,a=new Uint8Array(n),o=new Array(8),s=0;s<8;++s)o[s]=0;var l=this._position,c=l.data,u=l.offsetIdx,d=l.strideIdx;for(s=0;s<n;++s){for(var p=0,f=this._numIndexPerPrimitive*this.primitiveIndices[s],h=u+d*this.indices[f],v=c[h],m=c[h+1],g=c[h+2],y=1;y<this._numIndexPerPrimitive;++y){var b=c[h=u+d*this.indices[f+y]],x=c[h+1],_=c[h+2];b<v&&(v=b),x<m&&(m=x),_<g&&(g=_)}v<t[0]&&(p|=1),m<t[1]&&(p|=2),g<t[2]&&(p|=4),a[s]=p,++o[p]}var S=0;for(s=0;s<8;++s)o[s]>0&&++S;if(S<2)return;var P=new Array(8);for(s=0;s<8;++s)P[s]=o[s]>0?new Uint32Array(o[s]):void 0;for(s=0;s<8;++s)o[s]=0;for(s=0;s<n;++s)P[p=a[s]][o[p]++]=this.primitiveIndices[s];for(this._children=new Array(8),s=0;s<8;++s)void 0!==P[s]&&(this._children[s]=new e(P[s],this._numIndexPerPrimitive,this.indices,this._position))}return this._children},e}();return function(e){e.tmpIndices=new n({deallocator:null})}(o||(o={})),o}).apply(null,i))||(e.exports=r)},"3iei":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.DecodeNormal=function(e){var t=i.glsl(r||(r=n(["\n    vec3 decodeNormal(vec2 f) {\n      float z = 1.0 - abs(f.x) - abs(f.y);\n      return vec3(f + sign(f) * min(z, 0.0), z);\n    }\n  "],["\n    vec3 decodeNormal(vec2 f) {\n      float z = 1.0 - abs(f.x) - abs(f.y);\n      return vec3(f + sign(f) * min(z, 0.0), z);\n    }\n  "])));e.fragment.code.add(t),e.vertex.code.add(t)}}).apply(null,i))||(e.exports=r)},"3kdR":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("FXVB"),n("oZZu"),n("7Aei")],void 0===(r=(function(e,t,n,i,r,a){function o(e,t){e.vertex.code.add(a.glsl(t.linearDepth?s||(s=n(["\n    vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {\n      vec4 eye = view * vec4(pos, 1.0);\n      depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n      return proj * eye;\n    }\n    "],["\n    vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {\n      vec4 eye = view * vec4(pos, 1.0);\n      depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n      return proj * eye;\n    }\n    "])):l||(l=n(["\n    vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {\n      // Make sure the order of operations is the same as in transformPositionWithDepth.\n      return proj * (view * vec4(pos, 1.0));\n    }\n    "],["\n    vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {\n      // Make sure the order of operations is the same as in transformPositionWithDepth.\n      return proj * (view * vec4(pos, 1.0));\n    }\n    "]))))}Object.defineProperty(t,"__esModule",{value:!0}),t.Transform=o,function(e){e.bindUniforms=function(e,t){i.mat4.translate(c,t.view,t.origin),e.setUniform3fv("localOrigin",t.origin),e.setUniformMatrix4fv("view",c)}}(o=t.Transform||(t.Transform={}));var s,l,c=r.mat4f32.create()}).apply(null,i))||(e.exports=r)},"4ziW":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("0LE5"),n("vlC2"),n("Rdxj"),n("aWgr"),n("83/a"),n("AgDx"),n("CIy2")],void 0===(r=(function(e,t,n,i,r,a,o,s,l){var c,u,d,p,f=o.Vec3Compact;!function(e){for(var t=.5,n=[[-t,-t,t],[t,-t,t],[t,t,t],[-t,t,t],[-t,-t,-t],[t,-t,-t],[t,t,-t],[-t,t,-t]],i=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],r=[0,0,1,0,1,1,0,1],a=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],o=new Array(36),c=0;c<6;c++)for(var u=0;u<6;u++)o[6*c+u]=c;var d=new Array(36);for(c=0;c<6;c++)d[6*c+0]=0,d[6*c+1]=1,d[6*c+2]=2,d[6*c+3]=2,d[6*c+4]=3,d[6*c+5]=0;e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);for(var t=new Float32Array(24),c=0;c<8;c++)t[3*c]=n[c][0]*e[0],t[3*c+1]=n[c][1]*e[1],t[3*c+2]=n[c][2]*e[2];var u={};u[l.VertexAttrConstants.POSITION]=new Uint32Array(a),u[l.VertexAttrConstants.NORMAL]=new Uint32Array(o),u[l.VertexAttrConstants.UV0]=new Uint32Array(d);var p={};return p[l.VertexAttrConstants.POSITION]={size:3,data:t},p[l.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(i)},p[l.VertexAttrConstants.UV0]={size:2,data:new Float32Array(r)},new s.GeometryData(p,u)}}(c||(c={})),function(e){var t=.5,n=[[-t,0,-t],[t,0,-t],[t,0,t],[-t,0,t],[0,-t,0],[0,t,0]],i=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],r=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],a=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);for(var t=new Float32Array(18),o=0;o<6;o++)t[3*o]=n[o][0]*e[0],t[3*o+1]=n[o][1]*e[1],t[3*o+2]=n[o][2]*e[2];var c={};c[l.VertexAttrConstants.POSITION]=new Uint32Array(r),c[l.VertexAttrConstants.NORMAL]=new Uint32Array(a);var u={};return u[l.VertexAttrConstants.POSITION]={size:3,data:t},u[l.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(i)},new s.GeometryData(u,c)}}(u||(u={})),function(e){var t=i.vec3f32.fromValues(-.5,0,-.5),r=i.vec3f32.fromValues(.5,0,-.5),a=i.vec3f32.fromValues(0,0,.5),o=i.vec3f32.fromValues(0,.5,0),c=i.vec3f32.create(),u=i.vec3f32.create(),d=i.vec3f32.create(),p=i.vec3f32.create(),f=i.vec3f32.create();n.vec3.subtract(c,t,o),n.vec3.subtract(u,t,r),n.vec3.cross(d,c,u),n.vec3.normalize(d,d),n.vec3.subtract(c,r,o),n.vec3.subtract(u,r,a),n.vec3.cross(p,c,u),n.vec3.normalize(p,p),n.vec3.subtract(c,a,o),n.vec3.subtract(u,a,t),n.vec3.cross(f,c,u),n.vec3.normalize(f,f);var h=[t,r,a,o],v=[0,-1,0,d[0],d[1],d[2],p[0],p[1],p[2],f[0],f[1],f[2]],m=[0,1,2,3,1,0,3,2,1,3,0,2],g=[0,0,0,1,1,1,2,2,2,3,3,3];e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);for(var t=new Float32Array(12),n=0;n<4;n++)t[3*n]=h[n][0]*e[0],t[3*n+1]=h[n][1]*e[1],t[3*n+2]=h[n][2]*e[2];var i={};i[l.VertexAttrConstants.POSITION]=new Uint32Array(m),i[l.VertexAttrConstants.NORMAL]=new Uint32Array(g);var r={};return r[l.VertexAttrConstants.POSITION]={size:3,data:t},r[l.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(v)},new s.GeometryData(r,i)}}(d||(d={})),function(e){function t(e,t,i,r,a){return!(Math.abs(n.vec3.dot(t,e))>a||(n.vec3.cross(i,e,t),n.vec3.normalize(i,i),n.vec3.cross(r,i,e),n.vec3.normalize(r,r),0))}function p(e,n,i,r,a,o,s){return t(e,n,a,o,s)||t(e,i,a,o,s)||t(e,r,a,o,s)}e.createBoxGeometry=c.createGeometry,e.createDiamondGeometry=u.createGeometry,e.createTetrahedronGeometry=d.createGeometry,e.createSphereGeometry=function(e,t,n,i,r,a,o){e=e||50,i=void 0!==i?i:-Math.PI,r=void 0!==r?r:2*Math.PI,a=void 0!==a?a:.5*-Math.PI,o=void 0!==o?o:Math.PI;for(var c=Math.max(3,Math.floor(t)||8),u=Math.max(2,Math.floor(n)||6),d=(c+1)*(u+1),p=new Float32Array(3*d),f=new Float32Array(3*d),h=new Float32Array(2*d),v=[],m=0,g=0;g<=u;g++){for(var y=[],b=g/u,x=a+b*o,_=Math.cos(x),S=0;S<=c;S++){var P=S/c,w=i+P*r,A=Math.cos(w)*_,C=Math.sin(x),O=-Math.sin(w)*_;p[3*m]=A*e,p[3*m+1]=C*e,p[3*m+2]=O*e,f[3*m]=A,f[3*m+1]=C,f[3*m+2]=O,h[2*m]=P,h[2*m+1]=b,y.push(m),++m}v.push(y)}var M=new Uint32Array(2*c*(u-1)*3);for(m=0,g=0;g<u;g++)for(S=0;S<c;S++){var D=v[g][S],R=v[g][S+1],T=v[g+1][S+1],I=v[g+1][S];0===g?(M[m++]=D,M[m++]=T,M[m++]=I):g===u-1?(M[m++]=D,M[m++]=R,M[m++]=T):(M[m++]=D,M[m++]=R,M[m++]=T,M[m++]=T,M[m++]=I,M[m++]=D)}l.assert(m===M.length);var z={};z[l.VertexAttrConstants.POSITION]=M,z[l.VertexAttrConstants.NORMAL]=M,z[l.VertexAttrConstants.UV0]=M;var L={};return L[l.VertexAttrConstants.POSITION]={size:3,data:p},L[l.VertexAttrConstants.NORMAL]={size:3,data:f},L[l.VertexAttrConstants.UV0]={size:2,data:h},new s.GeometryData(L,z)},e.createPolySphereGeometry=function(e,t,n){function i(t,n){var i;t>n&&(t=(i=[n,t])[0],n=i[1]);var a=t.toString()+"."+n.toString();if(d[a])return d[a];var o=r.length;return r.length+=3,f.add(r,3*t,r,3*n,r,o),f.scale(r,o,e/f.length(r,o)),d[a]=o/=3,o}var r,a,o=e;if(n)r=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],a=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{var c=o*(1+Math.sqrt(5))/2;r=[-o,c,0,o,c,0,-o,-c,0,o,-c,0,0,-o,c,0,o,c,0,-o,-c,0,o,-c,c,0,-o,c,0,o,-c,0,-o,-c,0,o],a=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(var u=0;u<r.length;u+=3)f.scale(r,u,e/f.length(r,u));var d={};for(u=0;u<t;u++){for(var p=a.length,h=new Uint32Array(4*p),v=0;v<p;v+=3){var m=a[v],g=a[v+1],y=a[v+2],b=i(m,g),x=i(g,y),_=i(y,m),S=4*v;h[S]=m,h[S+1]=b,h[S+2]=_,h[S+3]=g,h[S+4]=x,h[S+5]=b,h[S+6]=y,h[S+7]=_,h[S+8]=x,h[S+9]=b,h[S+10]=x,h[S+11]=_}a=h,d={}}var P=new Float32Array(r);for(u=0;u<P.length;u+=3)f.normalize(P,u);var w={};w[l.VertexAttrConstants.POSITION]=a,w[l.VertexAttrConstants.NORMAL]=a;var A={};return A[l.VertexAttrConstants.POSITION]={size:3,data:new Float32Array(r)},A[l.VertexAttrConstants.NORMAL]={size:3,data:P},new s.GeometryData(A,w)},e.createPointGeometry=function(e,t,n,i,r,a,o,c){var u=t?new Float64Array([t[0],t[1],t[2]]):new Float32Array([0,0,0]),d=e?new Float32Array([e[0],e[1],e[2]]):new Float32Array([0,0,1]),p=a?new Float32Array(a):new Float32Array([0,0]),f=n?new Uint8Array([255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]):new Uint8Array([255,255,255,255]),h=null!=i&&2===i.length?new Float32Array(i):new Float32Array([1,1]),v={};if(v[l.VertexAttrConstants.POSITION]={size:3,data:u},v[l.VertexAttrConstants.NORMAL]={size:3,data:d},v[l.VertexAttrConstants.UV0]={size:p.length,data:p},v[l.VertexAttrConstants.COLOR]={size:4,data:f},v[l.VertexAttrConstants.SIZE]={size:2,data:h},null!=r){var m=new Float32Array([r[0],r[1],r[2],r[3]]);v[l.VertexAttrConstants.AUXPOS1]={size:4,data:m}}if(null!=o){var g=new Float32Array([o[0],o[1],o[2],o[3]]);v[l.VertexAttrConstants.AUXPOS2]={size:4,data:g}}return null!=c?(s.GeometryData.call(c,v,s.GeometryData.DefaultIndices,s.GeometryData.DefaultOffsets,"point"),c):new s.GeometryData(v,s.GeometryData.DefaultIndices,s.GeometryData.DefaultOffsets,"point")},e.updatePointGeometry=function(e,t,n,i,r,a,o,s){var c,u=s.vertexAttributes;return null!=e&&((c=u[l.VertexAttrConstants.NORMAL].data)[0]=e[0],c[1]=e[1],c[2]=e[2]),null!=t&&((c=u[l.VertexAttrConstants.POSITION].data)[0]=t[0],c[1]=t[1],c[2]=t[2]),null!=n&&((c=u[l.VertexAttrConstants.COLOR].data)[0]=n[0],c[1]=n[1],c[2]=n[2],c[3]=n[3]),null!=i&&((c=u[l.VertexAttrConstants.SIZE].data)[0]=i[0],c[1]=i[1]),null!=r&&((c=u[l.VertexAttrConstants.AUXPOS1].data)[0]=r[0],c[1]=r[1],c[2]=r[2],c[3]=r[3]),null!=a&&((c=u[l.VertexAttrConstants.UV0].data)[0]=a[0],c[1]=a[1]),null!=o&&((c=u[l.VertexAttrConstants.AUXPOS2].data)[0]=o[0],c[1]=o[1],c[2]=o[2],c[3]=o[3]),s},e.createPointArrayGeometry=function(e,t){for(var n=new Float32Array(3*e.length),i=new Float32Array(t?3*e.length:3),r=new Uint32Array(e.length),a=new Uint32Array(e.length),o=0;o<e.length;o++)n[3*o]=e[o][0],n[3*o+1]=e[o][1],n[3*o+2]=e[o][2],t&&(i[3*o]=t[o][0],i[3*o+1]=t[o][1],i[3*o+2]=t[o][2]),r[o]=o,a[o]=0;t||(i[0]=0,i[1]=1,i[2]=0);var c=new Float32Array(2);c[0]=0,c[1]=0;var u={};u[l.VertexAttrConstants.POSITION]=r,u[l.VertexAttrConstants.NORMAL]=t?r:a,u[l.VertexAttrConstants.UV0]=a;var d={};return d[l.VertexAttrConstants.POSITION]={size:3,data:n},d[l.VertexAttrConstants.NORMAL]={size:3,data:i},d[l.VertexAttrConstants.UV0]={size:2,data:c},new s.GeometryData(d,u,s.GeometryData.DefaultOffsets,"point")},e.createTriangleGeometry=function(){var e=new Float32Array([0,0,0,0,0,100,100,0,0]),t=new Uint32Array([0,1,2]),n=new Float32Array([0,1,0]),i=new Uint32Array([0,0,0]),r=new Float32Array([0,0]),a=new Uint32Array([0,0,0]),o={};o[l.VertexAttrConstants.POSITION]=t,o[l.VertexAttrConstants.NORMAL]=i,o[l.VertexAttrConstants.UV0]=a;var c={};return c[l.VertexAttrConstants.POSITION]={size:3,data:e},c[l.VertexAttrConstants.NORMAL]={size:3,data:n},c[l.VertexAttrConstants.UV0]={size:2,data:r},new s.GeometryData(c,o)},e.createSquareGeometry=function(e){var t=new Float32Array(12);if(e)for(var n=0;n<4;n++)for(var i=0;i<3;i++)t[3*n+i]=e[n][i];else t[0]=-1,t[1]=-1,t[2]=0,t[3]=1,t[4]=-1,t[5]=0,t[6]=1,t[7]=1,t[8]=0,t[9]=-1,t[10]=1,t[11]=0;var r=new Uint32Array([0,1,2,2,3,0]),a=new Float32Array([0,0,1]),o=new Uint32Array([0,0,0,0,0,0]),c=new Float32Array([0,0,1,0,1,1,0,1]),u=new Uint8Array([255,255,255,255]),d={};d[l.VertexAttrConstants.POSITION]=r,d[l.VertexAttrConstants.NORMAL]=o,d[l.VertexAttrConstants.UV0]=r,d[l.VertexAttrConstants.COLOR]=o;var p={};return p[l.VertexAttrConstants.POSITION]={size:3,data:t},p[l.VertexAttrConstants.NORMAL]={size:3,data:a},p[l.VertexAttrConstants.UV0]={size:2,data:c},p[l.VertexAttrConstants.COLOR]={size:4,data:u},new s.GeometryData(p,d)},e.createConeGeometry=function(e,t,n,r,a,o){void 0===a&&(a=!0),void 0===o&&(o=!0);var c=0,u=t,d=e,p=i.vec3f32.fromValues(0,c,0),f=i.vec3f32.fromValues(0,c+d,0),h=i.vec3f32.fromValues(0,-1,0),v=i.vec3f32.fromValues(0,1,0);r&&(c=d,f=i.vec3f32.fromValues(0,0,0),p=i.vec3f32.fromValues(0,c,0),h=i.vec3f32.fromValues(0,1,0),v=i.vec3f32.fromValues(0,-1,0));var m=[f,p],g=[h,v],y=n+2,b=Math.sqrt(d*d+u*u);if(r)for(var x=n-1;x>=0;x--){var _=x*(2*Math.PI/n),S=i.vec3f32.fromValues(Math.cos(_)*u,c,Math.sin(_)*u);m.push(S);var P=i.vec3f32.fromValues(d*Math.cos(_)/b,-u/b,d*Math.sin(_)/b);g.push(P)}else for(x=0;x<n;x++)_=x*(2*Math.PI/n),S=i.vec3f32.fromValues(Math.cos(_)*u,c,Math.sin(_)*u),m.push(S),P=i.vec3f32.fromValues(d*Math.cos(_)/b,u/b,d*Math.sin(_)/b),g.push(P);var w=new Uint32Array(2*(n+2)*3),A=new Uint32Array(2*(n+2)*3),C=0,O=0;if(a){for(x=3;x<m.length;x++)w[C++]=1,w[C++]=x-1,w[C++]=x,A[O++]=0,A[O++]=0,A[O++]=0;w[C++]=m.length-1,w[C++]=2,w[C++]=1,A[O++]=0,A[O++]=0,A[O++]=0}if(o){for(x=3;x<m.length;x++)w[C++]=x,w[C++]=x-1,w[C++]=0,A[O++]=x,A[O++]=x-1,A[O++]=1;w[C++]=0,w[C++]=2,w[C++]=m.length-1,A[O++]=1,A[O++]=2,A[O++]=g.length-1}var M=new Float32Array(3*y);for(x=0;x<y;x++)M[3*x]=m[x][0],M[3*x+1]=m[x][1],M[3*x+2]=m[x][2];var D=new Float32Array(3*y);for(x=0;x<y;x++)D[3*x]=g[x][0],D[3*x+1]=g[x][1],D[3*x+2]=g[x][2];var R={};R[l.VertexAttrConstants.POSITION]=w,R[l.VertexAttrConstants.NORMAL]=A;var T={};return T[l.VertexAttrConstants.POSITION]={size:3,data:M},T[l.VertexAttrConstants.NORMAL]={size:3,data:D},new s.GeometryData(T,R)},e.createCylinderGeometry=function(e,t,r,a,o,c){var u=a?i.vec3f32.clone(a):i.vec3f32.fromValues(1,0,0),d=o?i.vec3f32.clone(o):i.vec3f32.fromValues(0,0,0),p=void 0===c||c,f=i.vec3f32.create();n.vec3.normalize(f,u);var h=i.vec3f32.create();n.vec3.scale(h,f,Math.abs(e));var v=i.vec3f32.create();n.vec3.scale(v,h,-.5),n.vec3.add(v,v,d);var m=i.vec3f32.fromValues(0,1,0);Math.abs(1-n.vec3.dot(f,m))<.2&&n.vec3.set(m,0,0,1);var g=i.vec3f32.create();n.vec3.cross(g,f,m),n.vec3.normalize(g,g),n.vec3.cross(m,g,f);var y=2*r+(p?2:0),b=r+(p?2:0),x=new Float32Array(3*y),_=new Float32Array(3*b),S=new Float32Array(2*y),P=new Uint32Array(3*r*(p?4:2)),w=new Uint32Array(3*r*(p?4:2));p&&(x[3*(y-2)+0]=v[0],x[3*(y-2)+1]=v[1],x[3*(y-2)+2]=v[2],S[2*(y-2)]=0,S[2*(y-2)+1]=0,x[3*(y-1)+0]=x[3*(y-2)+0]+h[0],x[3*(y-1)+1]=x[3*(y-2)+1]+h[1],x[3*(y-1)+2]=x[3*(y-2)+2]+h[2],S[2*(y-1)]=1,S[2*(y-1)+1]=1,_[3*(b-2)+0]=-f[0],_[3*(b-2)+1]=-f[1],_[3*(b-2)+2]=-f[2],_[3*(b-1)+0]=f[0],_[3*(b-1)+1]=f[1],_[3*(b-1)+2]=f[2]);for(var A=function(e,t,n){P[e]=t,w[e]=n},C=0,O=i.vec3f32.create(),M=i.vec3f32.create(),D=0;D<r;D++){var R=D*(2*Math.PI/r);n.vec3.scale(O,m,Math.sin(R)),n.vec3.scale(M,g,Math.cos(R)),n.vec3.add(O,O,M),_[3*D+0]=O[0],_[3*D+1]=O[1],_[3*D+2]=O[2],n.vec3.scale(O,O,t),n.vec3.add(O,O,v),x[3*D+0]=O[0],x[3*D+1]=O[1],x[3*D+2]=O[2],S[2*D+0]=D/r,S[2*D+1]=0,x[3*(D+r)+0]=x[3*D+0]+h[0],x[3*(D+r)+1]=x[3*D+1]+h[1],x[3*(D+r)+2]=x[3*D+2]+h[2],S[2*(D+r)+0]=D/r,S[2*D+1]=1;var T=(D+1)%r;A(C++,D,D),A(C++,D+r,D),A(C++,T,T),A(C++,T,T),A(C++,D+r,D),A(C++,T+r,T)}if(p){for(D=0;D<r;D++)T=(D+1)%r,A(C++,y-2,b-2),A(C++,D,b-2),A(C++,T,b-2);for(D=0;D<r;D++)T=(D+1)%r,A(C++,D+r,b-1),A(C++,y-1,b-1),A(C++,T+r,b-1)}var I={};I[l.VertexAttrConstants.POSITION]=P,I[l.VertexAttrConstants.NORMAL]=w,I[l.VertexAttrConstants.UV0]=P;var z={};return z[l.VertexAttrConstants.POSITION]={size:3,data:x},z[l.VertexAttrConstants.NORMAL]={size:3,data:_},z[l.VertexAttrConstants.UV0]={size:2,data:S},new s.GeometryData(z,I)},e.createTubeGeometry=function(t,n,i,r,a){i=i||10,r=null==r||r,l.assert(t.length>1);for(var o=[],s=[],c=0;c<i;c++){o.push([0,-c-1,-(c+1)%i-1]);var u=c/i*2*Math.PI;s.push([Math.cos(u)*n,Math.sin(u)*n])}return e.createPathExtrusionGeometry(s,t,[[0,0,0]],o,r,a)},e.createPathExtrusionGeometry=function(e,t,o,c,u,d){void 0===d&&(d=i.vec3f32.fromValues(0,0,0));var f=e.length,v=new Float32Array(t.length*f*3+(6*o.length||0)),m=new Float32Array(t.length*f+(2*o.length||0)),g=new Float32Array(t.length*f*3+(o?6:0)),y=(t.length-1)*f*6+3*c.length*2,b=new Uint32Array(y),x=new Uint32Array(y),_=0,S=0,P=0,w=0,A=0,C=i.vec3f32.create(),O=i.vec3f32.create(),M=i.vec3f32.create(),D=i.vec3f32.create(),R=i.vec3f32.create(),T=i.vec3f32.create(),I=i.vec3f32.create(),z=r.vec3f64.create(),L=i.vec3f32.create(),E=i.vec3f32.create(),j=i.vec3f32.create(),V=i.vec3f32.create(),N=i.vec3f32.create(),F=a.plane.create();n.vec3.set(L,0,1,0),n.vec3.subtract(O,t[1],t[0]),n.vec3.normalize(O,O),u?(n.vec3.add(z,t[0],d),n.vec3.normalize(M,z)):n.vec3.set(M,0,0,1),p(O,M,L,L,R,M,h),n.vec3.copy(D,M),n.vec3.copy(V,R);for(var G=0;G<o.length;G++)n.vec3.scale(T,R,o[G][0]),n.vec3.scale(z,M,o[G][2]),n.vec3.add(T,T,z),n.vec3.add(T,T,t[0]),v[_++]=T[0],v[_++]=T[1],v[_++]=T[2],m[P++]=0;for(g[S++]=-O[0],g[S++]=-O[1],g[S++]=-O[2],G=0;G<c.length;G++)b[w++]=c[G][0]>0?c[G][0]:-c[G][0]-1+o.length,b[w++]=c[G][1]>0?c[G][1]:-c[G][1]-1+o.length,b[w++]=c[G][2]>0?c[G][2]:-c[G][2]-1+o.length,x[A++]=0,x[A++]=0,x[A++]=0;for(var B=o.length,H=o.length-1,U=0;U<t.length;U++){var q=!1;U>0&&(n.vec3.copy(C,O),U<t.length-1?(n.vec3.subtract(O,t[U+1],t[U]),n.vec3.normalize(O,O)):q=!0,n.vec3.add(E,C,O),n.vec3.normalize(E,E),n.vec3.add(j,t[U-1],D),a.plane.fromPositionAndNormal(t[U],E,F),a.plane.intersectRay(F,a.ray.wrap(j,C),z)?(n.vec3.subtract(z,z,t[U]),n.vec3.normalize(M,z),n.vec3.cross(R,E,M),n.vec3.normalize(R,R)):p(E,D,V,L,R,M,h),n.vec3.copy(D,M),n.vec3.copy(V,R)),u&&(n.vec3.add(z,t[U],d),n.vec3.normalize(N,z));for(var k=0;k<f;k++)if(n.vec3.scale(T,R,e[k][0]),n.vec3.scale(z,M,e[k][1]),n.vec3.add(T,T,z),n.vec3.normalize(I,T),g[S++]=I[0],g[S++]=I[1],g[S++]=I[2],m[P++]=u?n.vec3.dot(T,N):T[2],n.vec3.add(T,T,t[U]),v[_++]=T[0],v[_++]=T[1],v[_++]=T[2],!q){var W=(k+1)%f;b[w++]=B+k,b[w++]=B+f+k,b[w++]=B+W,b[w++]=B+W,b[w++]=B+f+k,b[w++]=B+f+W;for(var Z=0;Z<6;Z++)x[A++]=b[w-6+Z]-H}B+=f}var X=t[t.length-1];for(G=0;G<o.length;G++)n.vec3.scale(T,R,o[G][0]),n.vec3.scale(z,M,o[G][1]),n.vec3.add(T,T,z),n.vec3.add(T,T,X),v[_++]=T[0],v[_++]=T[1],v[_++]=T[2],m[P++]=0;var Y=S/3;g[S++]=O[0],g[S++]=O[1],g[S++]=O[2];var J=B-f;for(G=0;G<c.length;G++)b[w++]=c[G][0]>=0?B+c[G][0]:-c[G][0]-1+J,b[w++]=c[G][2]>=0?B+c[G][2]:-c[G][2]-1+J,b[w++]=c[G][1]>=0?B+c[G][1]:-c[G][1]-1+J,x[A++]=Y,x[A++]=Y,x[A++]=Y;var K={};K[l.VertexAttrConstants.POSITION]=b,K[l.VertexAttrConstants.NORMAL]=x;var Q={};return Q[l.VertexAttrConstants.POSITION]={size:3,data:v},Q.zOffset={size:1,data:m},Q[l.VertexAttrConstants.NORMAL]={size:3,data:g},new s.GeometryData(Q,K)},e.createPolylineGeometry=function(e,t){l.assert(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),l.assert(3===e[0].length,"createPolylineGeometry(): malformed vertex"),l.assert(void 0===t||t.length===e.length,"createPolylineGeometry: need same number of points and normals"),l.assert(void 0===t||3===t[0].length,"createPolylineGeometry(): malformed normal");for(var n=new Float32Array(3*e.length),i=new Uint32Array(2*(e.length-1)),r=0,a=0,o=0;o<e.length;o++){for(var c=0;c<3;c++)n[r++]=e[o][c];o>0&&(i[a++]=o-1,i[a++]=o)}var u={},d={};if(u[l.VertexAttrConstants.POSITION]=i,d[l.VertexAttrConstants.POSITION]={size:3,data:n},t){var p=new Float32Array(3*t.length),f=0;for(o=0;o<e.length;o++)for(c=0;c<3;c++)p[f++]=t[o][c];u[l.VertexAttrConstants.NORMAL]=i,d[l.VertexAttrConstants.NORMAL]={size:3,data:p}}return new s.GeometryData(d,u,s.GeometryData.DefaultOffsets,"line")},e.createExtrudedTriangle=function(e,t,n,i){for(var r,a,o=new Float32Array(18),c=[[-t,0,i/2],[n,0,i/2],[0,e,i/2],[-t,0,-i/2],[n,0,-i/2],[0,e,-i/2]],u=0;u<6;u++)o[3*u]=c[u][0],o[3*u+1]=c[u][1],o[3*u+2]=c[u][2];var d=((r={})[l.VertexAttrConstants.POSITION]=new Uint32Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]),r),p=((a={})[l.VertexAttrConstants.POSITION]={size:3,data:o},a);return new s.GeometryData(p,d)},e.transformInPlace=function(e,t){for(var i=e.vertexAttributes[l.VertexAttrConstants.POSITION].data,r=0;r<i.length;r+=3)n.vec3.set(v,i[r],i[r+1],i[r+2]),n.vec3.transformMat4(v,v,t),i[r]=v[0],i[r+1]=v[1],i[r+2]=v[2]},e.addVertexColors=function(e,t){var n=t||[1,1,1,1],i=new Uint8Array(4);i[0]=255*n[0],i[1]=255*n[1],i[2]=255*n[2],i[3]=255*(n.length>3?n[3]:1);var r={},a=e.getVertexAttr();for(var o in a)r[o]=a[o];r[l.VertexAttrConstants.COLOR]={size:4,data:i};var c={};for(var o in e.indices)c[o]=e.indices[o];return c[l.VertexAttrConstants.COLOR]=new Uint32Array(c[l.VertexAttrConstants.POSITION].length),new s.GeometryData(r,c,e.componentOffsets,e.primitiveType)},e.addNormals=function(e){for(var t=e.getVertexAttr(),i=e.indices,r=o.Vec3Compact.subtract,a=new Float32Array(i.position.length/3*3),s=t.position.data,c=0,u=i.position,d=new Uint32Array(u.length),p=0;p<u.length;p+=3){r(s,3*u[p],s,3*u[p+2],m,0),r(s,3*u[p],s,3*u[p+1],v,0),n.vec3.cross(v,v,m),n.vec3.normalize(v,v);var f=c/3;a[c++]=v[0],a[c++]=v[1],a[c++]=v[2],d[p]=f,d[p+1]=f,d[p+2]=f}t[l.VertexAttrConstants.NORMAL]={size:3,data:a,offsetIdx:0,strideIdx:3},i[l.VertexAttrConstants.NORMAL]=d},e.cgToGIS=function(e,t){void 0===t&&(t=e);var n=e.getVertexAttr(),i=n.position.data,r=n.normal.data,a=t.getVertexAttr(),o=a.position.data,s=a.normal.data;if(r)for(var l=0;l<r.length;l+=3){var c=r[l+1];s[l+1]=-r[l+2],s[l+2]=c}if(i)for(l=0;l<i.length;l+=3)c=i[l+1],o[l+1]=-i[l+2],o[l+2]=c;return t},e.makeOrthoBasisDirUp=t,e.makeOrthoBasisDirUpFallback=p}(p||(p={}));var h=.99619469809,v=i.vec3f32.create(),m=i.vec3f32.create();return p}).apply(null,i))||(e.exports=r)},"5T2R":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("LxLY"),n("FXVB"),n("0LE5"),n("ZcgO"),n("BwdQ"),n("JjCO"),n("ys4y"),n("4ziW"),n("TP2F"),n("AvU8")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d){function p(e,t){var n=1!==t,i=new u({diffuse:e,transparent:n,writeDepth:!n,cullFace:2,opacity:t,castShadows:!1,softwareInstanced:!0},"manipulator");return i.renderOccluded=4,i}function f(e,t,n,i){var a=r.vec3.normalize(s.sv3d.get(),e),o=r.vec3.normalize(s.sv3d.get(),t),l=r.vec3.cross(s.sv3d.get(),a,o);return i[0]=a[0],i[1]=a[1],i[2]=a[2],i[3]=0,i[4]=o[0],i[5]=o[1],i[6]=o[2],i[7]=0,i[8]=l[0],i[9]=l[1],i[10]=l[2],i[11]=0,i[12]=n[0],i[13]=n[1],i[14]=n[2],i[15]=1,i}Object.defineProperty(t,"__esModule",{value:!0}),t.createManipulatorMaterial=p,t.createSphereManipulator=function(e,t,n){return new d.Manipulator3D({view:e,renderObjects:[{geometry:new l(c.createSphereGeometry(1,32,32),"manipulator"),material:p(t,n)}]})},t.calculateInputRotationTransform=function(e,t,n,a){var o=r.vec3.subtract(s.sv3d.get(),e,n),l=f(o,r.vec3.cross(s.sv3d.get(),a,o),n,s.sm4d.get());i.mat4.invert(l,l);var c=r.vec3.transformMat4(s.sv3d.get(),t,l);return Math.atan2(c[1],c[0])},t.calculateTranslateRotateFromBases=f,t.placeManipulatorAtGraphic=function(e,t){var i=e.view.getViewForGraphic(t),r=n.isSome(i)&&"computeAttachmentOrigin"in i?i.computeAttachmentOrigin(t,e.view.spatialReference):null;n.isSome(r)?e.elevationAlignedLocation=r:function(e,t){if(!n.isNone(t)){var i=o.computeCentroid(t);n.isNone(i)||(e.location=a.hydrateGeometry(i))}}(e,t.geometry)}}).apply(null,i))||(e.exports=r)},"5UTK":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.HighlightData=function(e){e.fragment.code.add(i.glsl(r||(r=n(["\n    vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\n      float sceneDepth = texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\n      if (fragCoord.z > sceneDepth + 5e-7) {\n        return vec4(1.0, 1.0, 0.0, 1.0);\n      }\n      else {\n        return vec4(1.0, 0.0, 1.0, 1.0);\n      }\n    }\n  "],["\n    vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\n      float sceneDepth = texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\n      if (fragCoord.z > sceneDepth + 5e-7) {\n        return vec4(1.0, 1.0, 0.0, 1.0);\n      }\n      else {\n        return vec4(1.0, 0.0, 1.0, 1.0);\n      }\n    }\n  "]))))}}).apply(null,i))||(e.exports=r)},"6t3m":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o;Object.defineProperty(t,"__esModule",{value:!0}),t.VertexColor=function(e,t){t.attributeColor?(e.attributes.add("color","vec4"),e.varyings.add("vColor","vec4"),e.vertex.code.add(i.glsl(r||(r=n(["\n      void forwardVertexColor() { vColor = color; }\n    "],["\n      void forwardVertexColor() { vColor = color; }\n    "])))),e.vertex.code.add(i.glsl(a||(a=n(["\n      void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }\n    "],["\n      void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }\n    "]))))):e.vertex.code.add(i.glsl(o||(o=n(["\n      void forwardVertexColor() {}\n      void forwardNormalizedVertexColor() {}\n    "],["\n      void forwardVertexColor() {}\n      void forwardNormalizedVertexColor() {}\n    "]))))}}).apply(null,i))||(e.exports=r)},"7Aei":function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){function n(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];for(var i="",r=0;r<t.length;r++)i+=e[r]+t[r];return i+e[e.length-1]}Object.defineProperty(t,"__esModule",{value:!0}),t.glsl=n,function(e){e.int=function(e){return Math.round(e).toString()}}(n=t.glsl||(t.glsl={}))}).apply(null,i))||(e.exports=r)},"7Yqx":function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){function n(){var e=new Float32Array(16);return e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Object.defineProperty(t,"__esModule",{value:!0}),t.create=n,t.clone=function(e){var t=new Float32Array(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},t.fromValues=function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v){var m=new Float32Array(16);return m[0]=e,m[1]=t,m[2]=n,m[3]=i,m[4]=r,m[5]=a,m[6]=o,m[7]=s,m[8]=l,m[9]=c,m[10]=u,m[11]=d,m[12]=p,m[13]=f,m[14]=h,m[15]=v,m},t.createView=function(e,t){return new Float32Array(e,t,16)},t.IDENTITY=n()}).apply(null,i))||(e.exports=r)},"7zqm":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o,s;Object.defineProperty(t,"__esModule",{value:!0}),t.LineStipple=function(e,t){e.defines.addFloat("STIPPLE_ALPHA_COLOR_DISCARD",.001),e.defines.addFloat("STIPPLE_ALPHA_HIGHLIGHT_DISCARD",.5),t.stippleEnabled?function(e,t){e.vertex.uniforms.add("stipplePatternPixelSizeInv","float"),t.stippleUVMaxEnabled&&e.varyings.add("stipplePatternUvMax","float"),e.varyings.add("stipplePatternUv","float"),e.fragment.uniforms.add("stipplePatternTexture","sampler2D"),t.stippleOffColorEnabled&&e.fragment.uniforms.add("stippleOffColor","vec4"),e.fragment.code.add(i.glsl(r||(r=n(["\n  float getStippleAlpha() {\n    float stipplePatternUvClamped = stipplePatternUv * gl_FragCoord.w;\n    ","\n\n    return texture2D(stipplePatternTexture, vec2(mod(stipplePatternUvClamped, 1.0), 0.5)).a;\n  }"],["\n  float getStippleAlpha() {\n    float stipplePatternUvClamped = stipplePatternUv * gl_FragCoord.w;\n    ","\n\n    return texture2D(stipplePatternTexture, vec2(mod(stipplePatternUvClamped, 1.0), 0.5)).a;\n  }"])),t.stippleUVMaxEnabled?"stipplePatternUvClamped = clamp(stipplePatternUvClamped, 0.0, stipplePatternUvMax);":"")),e.fragment.code.add(i.glsl(t.stippleOffColorEnabled?a||(a=n(["\n    #define discardByStippleAlpha(stippleAlpha, threshold) {}\n    #define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)\n    "],["\n    #define discardByStippleAlpha(stippleAlpha, threshold) {}\n    #define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)\n    "])):o||(o=n(["\n    #define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }\n    #define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)\n    "],["\n    #define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }\n    #define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)\n    "]))))}(e,t):function(e){e.fragment.code.add(i.glsl(s||(s=n(["\n  float getStippleAlpha() { return 1.0; }\n\n  #define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}\n  #define blendStipple(color, _stippleAlpha_) color\n  "],["\n  float getStippleAlpha() { return 1.0; }\n\n  #define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}\n  #define blendStipple(color, _stippleAlpha_) color\n  "]))))}(e)}}).apply(null,i))||(e.exports=r)},"8TPw":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("3iei"),n("7Aei")],void 0===(r=(function(e,t,n,i,r){var a,o;Object.defineProperty(t,"__esModule",{value:!0}),t.NormalAttribute=function(e,t){0===t.normalType&&(e.attributes.add("normal","vec3"),e.vertex.code.add(r.glsl(a||(a=n(["\n      vec3 normalModel() {\n        return normal;\n      }\n    "],["\n      vec3 normalModel() {\n        return normal;\n      }\n    "]))))),1===t.normalType&&(e.include(i.DecodeNormal),e.attributes.add("normalCompressed","vec2"),e.vertex.code.add(r.glsl(o||(o=n(["\n      vec3 normalModel() {\n        return decodeNormal(normalCompressed);\n      }\n    "],["\n      vec3 normalModel() {\n        return decodeNormal(normalCompressed);\n      }\n    "])))))}}).apply(null,i))||(e.exports=r)},"9DjX":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("LxLY"),n("YX1r"),n("51bw"),n("FXVB"),n("1m5D"),n("EuvN"),n("lLWD"),n("0LE5"),n("vlC2"),n("Rdxj"),n("2fXB"),n("O7NG"),n("aWgr"),n("2eYJ"),n("/dtL"),n("ZJC8")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g){function y(e,t){return n.isNone(e)||null==e.layerUid?null:n.isSome(t.graphicsView)&&e.layerUid===t.graphicsView.mockLayerId?t.graphics:t.map.findLayerByUid(e.layerUid)}function b(e,t){if(n.isNone(e))return null;var i=y(e,t);if(n.isNone(i))return null;if(i===t.graphics)return n.isSome(t.graphicsView)?n.expect(t.graphicsView.getGraphicFromGraphicUid(e.graphicUid)):null;var r=t.allLayerViews.find((function(e){return e.layer===i}));return r?function(e,t){return!e||e.suspended?null:"getGraphicFromIntersectorMetadata"in e&&t?e.getGraphicFromIntersectorMetadata(t):"getGraphicFromGraphicUid"in e&&null!=t.graphicUid?e.getGraphicFromGraphicUid(t.graphicUid):null}(r,e):null}Object.defineProperty(t,"__esModule",{value:!0}),t.sliceFilterPredicate=function(e){return function(t,n,i){return c.vec3.lerp(O,t,n,i),!v.extrusionContainsPoint(e,O)}},t.IntersectorOptions=function(){this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.storeTerrainResults=!0,this.store=2};var x=function(){function e(){this._transform=o.mat4f64.create(),this._transformInverse=new _({value:this._transform},a.mat4.invert,o.mat4f64.create),this._transformInverseTranspose=new _(this._transformInverse,a.mat4.transpose,o.mat4f64.create),this._transformTranspose=new _({value:this._transform},a.mat4.transpose,o.mat4f64.create),this._transformInverseRotation=new _({value:this._transform},i.mat3.normalFromMat4Legacy,r.mat3f64.create)}return e.prototype.invalidateLazyTransforms=function(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()},Object.defineProperty(e.prototype,"transform",{get:function(){return this._transform},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inverse",{get:function(){return this._transformInverse.value},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inverseTranspose",{get:function(){return this._transformInverseTranspose.value},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inverseRotation",{get:function(){return this._transformInverseRotation.value},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"transpose",{get:function(){return this._transformTranspose.value},enumerable:!0,configurable:!0}),e.prototype.setTransformMatrix=function(e){a.mat4.copy(this._transform,e)},e.prototype.multiplyTransform=function(e){a.mat4.multiply(this._transform,this._transform,e)},e.prototype.set=function(e){a.mat4.copy(this._transform,e),this.invalidateLazyTransforms()},e.prototype.setAndInvalidateLazyTransforms=function(e,t){this.setTransformMatrix(e),this.multiplyTransform(t),this.invalidateLazyTransforms()},e}();t.IntersectorTransform=x;var _=function(){function e(e,t,n){this.original=e,this.update=t,this.dirty=!0,this.transform=n()}return e.prototype.invalidate=function(){this.dirty=!0},Object.defineProperty(e.prototype,"value",{get:function(){return this.dirty&&(this.update(this.transform,this.original.value),this.dirty=!1),this.transform},enumerable:!0,configurable:!0}),e}(),S=function(){function e(){this.min=new P,this.max=new P,this.hud=new P,this.terrain=new P}return e.prototype.init=function(e){this.min.init(e),this.max.init(e),this.hud.init(e),this.terrain.init(e),this.all=[]},e}();t.IntersectorResults=S;var P=function(){function e(e){this.normal=d.vec3f64.create(),this.transformation=o.mat4f64.create(),this._ray=h.ray.create(),this.init(e)}return Object.defineProperty(e.prototype,"ray",{get:function(){return this._ray},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"hasIntersectionPoint",{get:function(){return null!=this.dist},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"distanceInRenderSpace",{get:function(){if(null!=this.dist)return c.vec3.scale(M,this.ray.direction,this.dist),c.vec3.length(M)},enumerable:!0,configurable:!0}),e.prototype.getIntersectionPoint=function(e){return!!this.hasIntersectionPoint&&(c.vec3.scale(M,this.ray.direction,this.dist),c.vec3.add(e,this.ray.origin,M),!0)},e.prototype.getTransformedNormal=function(e){return c.vec3.copy(D,this.normal),D[3]=0,p.vec4.transformMat4(D,D,this.transformation),c.vec3.copy(e,D),c.vec3.normalize(e,e),e},e.prototype.set=function(e,t,n,i,r,o,s,l,u,p){e instanceof g&&(e={type:"stage",obj:e}),this.dist=n,c.vec3.copy(this.normal,i),a.mat4.copy(this.transformation,r),this.target=e,this.name=t,this.drapedLayerOrder=o,this.center=s?d.vec3f64.clone(s):null,this.geometryId=l,this.triangleNr=u,this.drapedLayerGraphicOrder=p},e.prototype.copyFrom=function(e){h.ray.copy(e._ray,this._ray),this.dist=e.dist,this.target=e.target,this.name=e.name,this.drapedLayerOrder=e.drapedLayerOrder,this.center=e.center?d.vec3f64.clone(e.center):null,this.geometryId=e.geometryId,this.triangleNr=e.triangleNr,this.intersector=e.intersector,this.drapedLayerGraphicOrder=e.drapedLayerGraphicOrder,c.vec3.copy(this.normal,e.normal),a.mat4.copy(this.transformation,e.transformation)},e.prototype.init=function(e){this.dist=void 0,this.target=void 0,this.name=void 0,this.drapedLayerOrder=void 0,this.drapedLayerGraphicOrder=void 0,this.center=null,this.geometryId=null,this.triangleNr=null,this.intersector="Stage",e?h.ray.copy(e,this._ray):this._ray=h.ray.create()},e.prototype.toOwner=function(e){if(!this.target)return null;switch(this.target.type){case"stage":return y(this.target.obj.getMetadata(),e);case"external":switch(this.intersector){case"PointRenderer":return function(e,t){var n=e.metadata.layerUid;return null!=n?t.map.findLayerByUid(n):null}(this.target,e);case"I3S":case"LodRenderer":case"DrapedRenderer":return y(this.target.metadata,e);case"TerrainRenderer":return e.map&&e.map.ground}}return null},e.prototype.toGraphic=function(e){if(!this.target)return null;switch(this.target.type){case"stage":return b(this.target.obj.getMetadata(),e);case"external":switch(this.intersector){case"PointRenderer":return function(e){return e.metadata.createGraphic()}(this.target);case"I3S":case"LodRenderer":case"DrapedRenderer":return b(this.target.metadata,e)}}return null},e}();t.IntersectorResult=P;var w=function(){function e(e){this.offset=e,this.tmpVertex=d.vec3f64.create()}return e.prototype.applyToVertex=function(e,t,n){var i=e+this.localOrigin[0],r=t+this.localOrigin[1],a=n+this.localOrigin[2],o=this.offset/Math.sqrt(i*i+r*r+a*a);return this.tmpVertex[0]=e+i*o,this.tmpVertex[1]=t+r*o,this.tmpVertex[2]=n+a*o,this.tmpVertex},e.prototype.applyToAABB=function(e){var t=e[0]+this.localOrigin[0],n=e[1]+this.localOrigin[1],i=e[2]+this.localOrigin[2],r=e[3]+this.localOrigin[0],a=e[4]+this.localOrigin[1],o=e[5]+this.localOrigin[2],s=this.offset/Math.sqrt(t*t+n*n+i*i);e[0]+=t*s,e[1]+=n*s,e[2]+=i*s;var l=this.offset/Math.sqrt(r*r+a*a+o*o);return e[3]+=r*l,e[4]+=a*l,e[5]+=o*l,e},e}();t.TerrainVerticalOffsetGlobalViewingMode=w;var A=function(){function e(e){this.offset=e,this.componentLocalOriginLength=0,this.tmpVertex=d.vec3f64.create(),this.mbs=f.vec4f64.create(),this.obb={center:d.vec3f64.create(),halfSize:u.vec3f32.create(),quaternion:null}}return Object.defineProperty(e.prototype,"localOrigin",{set:function(e){this.componentLocalOriginLength=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])},enumerable:!0,configurable:!0}),e.prototype.applyToVertex=function(e,t,n){var i=e,r=t,a=n+this.componentLocalOriginLength,o=this.offset/Math.sqrt(i*i+r*r+a*a);return this.tmpVertex[0]=e+i*o,this.tmpVertex[1]=t+r*o,this.tmpVertex[2]=n+a*o,this.tmpVertex},e.prototype.applyToAABB=function(e){var t=e[0],n=e[1],i=e[2]+this.componentLocalOriginLength,r=e[3],a=e[4],o=e[5]+this.componentLocalOriginLength,s=this.offset/Math.sqrt(t*t+n*n+i*i);e[0]+=t*s,e[1]+=n*s,e[2]+=i*s;var l=this.offset/Math.sqrt(r*r+a*a+o*o);return e[3]+=r*l,e[4]+=a*l,e[5]+=o*l,e},e.prototype.applyToMbs=function(e){var t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),n=this.offset/t;return this.mbs[0]=e[0]+e[0]*n,this.mbs[1]=e[1]+e[1]*n,this.mbs[2]=e[2]+e[2]*n,this.mbs[3]=e[3]+e[3]*this.offset/t,this.mbs},e.prototype.applyToObb=function(e){var t=e.center,n=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);this.obb.center[0]=t[0]+t[0]*n,this.obb.center[1]=t[1]+t[1]*n,this.obb.center[2]=t[2]+t[2]*n,c.vec3.transformQuat(this.obb.halfSize,e.halfSize,e.quaternion),c.vec3.add(this.obb.halfSize,this.obb.halfSize,e.center);var i=this.offset/Math.sqrt(this.obb.halfSize[0]*this.obb.halfSize[0]+this.obb.halfSize[1]*this.obb.halfSize[1]+this.obb.halfSize[2]*this.obb.halfSize[2]);return this.obb.halfSize[0]+=this.obb.halfSize[0]*i,this.obb.halfSize[1]+=this.obb.halfSize[1]*i,this.obb.halfSize[2]+=this.obb.halfSize[2]*i,c.vec3.subtract(this.obb.halfSize,this.obb.halfSize,e.center),s.quat.conjugate(R,e.quaternion),c.vec3.transformQuat(this.obb.halfSize,this.obb.halfSize,R),this.obb.halfSize[0]*=this.obb.halfSize[0]<0?-1:1,this.obb.halfSize[1]*=this.obb.halfSize[1]<0?-1:1,this.obb.halfSize[2]*=this.obb.halfSize[2]<0?-1:1,this.obb.quaternion=e.quaternion,this.obb},e}();t.I3SVerticalOffsetGlobalViewingMode=A;var C=function(){function e(e){this.offset=e,this.sphere=m.create(),this.tmpVertex=d.vec3f64.create()}return e.prototype.applyToVertex=function(e,t,n){var i=this.objectTransform.transform,r=i[0]*e+i[4]*t+i[8]*n+i[12],a=i[1]*e+i[5]*t+i[9]*n+i[13],o=i[2]*e+i[6]*t+i[10]*n+i[14],s=this.offset/Math.sqrt(r*r+a*a+o*o),l=this.objectTransform.inverse;return this.tmpVertex[0]=l[0]*(r+=r*s)+l[4]*(a+=a*s)+l[8]*(o+=o*s)+l[12],this.tmpVertex[1]=l[1]*r+l[5]*a+l[9]*o+l[13],this.tmpVertex[2]=l[2]*r+l[6]*a+l[10]*o+l[14],this.tmpVertex},e.prototype.applyToMinMax=function(e,t){var n=this.offset/Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);e[0]+=e[0]*n,e[1]+=e[1]*n,e[2]+=e[2]*n;var i=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*i,t[1]+=t[1]*i,t[2]+=t[2]*i},e.prototype.applyToAABB=function(e){var t=this.offset/Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);e[0]+=e[0]*t,e[1]+=e[1]*t,e[2]+=e[2]*t;var n=this.offset/Math.sqrt(e[3]*e[3]+e[4]*e[4]+e[5]*e[5]);return e[3]+=e[3]*n,e[4]+=e[4]*n,e[5]+=e[5]*n,e},e.prototype.applyToBoundingSphere=function(e,t){var n=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),i=this.offset/n;return this.sphere.center[0]=t[0]+t[0]*i,this.sphere.center[1]=t[1]+t[1]*i,this.sphere.center[2]=t[2]+t[2]*i,this.sphere.radius=e+e*this.offset/n,this.sphere},e}();t.Object3DVerticalOffsetGlobalViewingMode=C,t.VerticalOffsetForGlobalViewingMode=function(e){this.terrain=new w(e),this.i3s=new A(e),this.object3D=new C(e)},t.TERRAIN_ID="terrain";var O=d.vec3f64.create(),M=d.vec3f64.create(),D=f.vec4f64.create(),R=l.quatf64.create()}).apply(null,i))||(e.exports=r)},"9FJH":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("2Atf"),n("xhoE"),n("EiD/"),n("tUyH"),n("s6rJ")],void 0===(r=(function(e,t,n,i,r,a,o){var s=function(e){function t(t){var n=e.call(this,t)||this,i=t.textureRep;n.textureRep=i,n.textureId=t.textureId,n.initTransparent=!!t.initTextureTransparent;var r=function(e){return o.acquireIfNotUndefined(e,i,n.initTransparent)};return n.glTextureRef=r(n.textureId),t.normalTextureId&&(n.glTextureRefNormal=r(t.normalTextureId)),t.emissiveTextureId&&(n.glTextureRefEmission=r(t.emissiveTextureId)),t.occlusionTextureId&&(n.glTextureRefOcclusion=r(t.occlusionTextureId)),t.metallicRoughnessTextureId&&(n.glTextureRefRoughnessMetallness=r(t.metallicRoughnessTextureId)),n}return i(t,e),t.prototype.dispose=function(){o.releaseIfNotUndefined(this.textureId,this.textureRep)},t.prototype.updateTexture=function(e){e!==this.textureId&&(o.releaseIfNotUndefined(this.textureId,this.textureRep),this.textureId=e,this.glTextureRef=o.acquireIfNotUndefined(this.textureId,this.textureRep,this.initTransparent))},t.prototype.bindTexture=function(e,t){null!=this.glTextureRef&&(t.setUniform1i("tex",r.DefaultTextureUnits.DIFFUSE),e.bindTexture(this.glTextureRef.getGLTexture(),r.DefaultTextureUnits.DIFFUSE)),this.glTextureRefNormal&&(t.setUniform1i("normalTexture",r.DefaultTextureUnits.NORMAL),e.bindTexture(this.glTextureRefNormal.getGLTexture(),r.DefaultTextureUnits.NORMAL)),this.glTextureRefEmission&&(t.setUniform1i("texEmission",r.DefaultTextureUnits.EMISSION),e.bindTexture(this.glTextureRefEmission.getGLTexture(),r.DefaultTextureUnits.EMISSION)),this.glTextureRefOcclusion&&(t.setUniform1i("texOcclusion",r.DefaultTextureUnits.OCCLUSION),e.bindTexture(this.glTextureRefOcclusion.getGLTexture(),r.DefaultTextureUnits.OCCLUSION)),this.glTextureRefRoughnessMetallness&&(t.setUniform1i("texMetallicRoughness",r.DefaultTextureUnits.METALLIC_ROUGHNESS),e.bindTexture(this.glTextureRefRoughnessMetallness.getGLTexture(),r.DefaultTextureUnits.METALLIC_ROUGHNESS))},t.prototype.bindTextureScale=function(e,t){var n=this.glTextureRef&&this.glTextureRef.getGLTexture();n&&n.descriptor.textureCoordinateScaleFactor?t.setUniform2fv("textureCoordinateScaleFactor",n.descriptor.textureCoordinateScaleFactor):t.setUniform2f("textureCoordinateScaleFactor",1,1)},t}(a.GLMaterial);return function(e){e.makeCtorParameters=function(e,t){return n({},e,t)}}(s||(s={})),s}).apply(null,i))||(e.exports=r)},"9ZJu":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("2Atf"),n("xoE+"),n("LxLY"),n("jBNx")],void 0===(r=(function(e,t,n,i,r,a){Object.defineProperty(t,"__esModule",{value:!0}),t.dragAtLocation=function(e,t,o){if(r.isNone(t))return null;var s=null,l=0,c=0;return function(r){if("start"===r.action&&((s=e.toScreen(o)).x<0||s.x>e.width||s.y<0||s.y>e.height?s=null:(l=r.start.x-s.x,c=r.start.y-s.y)),null==s)return null;var u=i.clamp(r.screenPoint.x-l,0,e.width),d=i.clamp(r.screenPoint.y-c,0,e.height),p=a.createScreenPoint(u,d);return t(n({},r,{start:s,screenPoint:p}))}}}).apply(null,i))||(e.exports=r)},"9dVJ":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("WMxK"),n("bMXq"),n("cmSR"),n("nobt"),n("fese"),n("3kdR"),n("uci5"),n("lF8C"),n("6t3m"),n("cqYc"),n("xDGw"),n("uEh2"),n("aluc"),n("eYHx"),n("+5nk"),n("5UTK"),n("cGZG"),n("piY7"),n("zdOl"),n("cj3m"),n("3PFg"),n("r0i9"),n("JvNb"),n("7Aei"),n("aExC")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_,S,P,w,A,C,O){var M,D,R,T,I,z,L,E,j,V,N,F,G,B,H,U,q,k,W,Z,X,Y,J,K,Q,$,ee,te,ne,ie,re,ae,oe,se,le,ce,ue,de,pe,fe,he,ve,me,ge,ye,be,xe,_e,Se,Pe,we,Ae,Ce,Oe,Me,De,Re,Te,Ie,ze,Le;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new O.ShaderBuilder,Ee=t.vertex.code,je=t.fragment.code;return Ee.add(C.glsl(M||(M=n(["\n    // --- Default Material:\n    // ","\n    // ---\n  "],["\n    // --- Default Material:\n    // ","\n    // ---\n  "])),JSON.stringify(e))),je.add(C.glsl(D||(D=n(["\n    // --- Default Material:\n    // ","\n    // ---\n  "],["\n    // --- Default Material:\n    // ","\n    // ---\n  "])),JSON.stringify(e))),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3"),t.include(c.PositionAttribute),t.varyings.add("vpos","vec3"),t.include(P.VisualVariables,e),e.instanced&&e.instancedDoublePrecision?(t.attributes.add("modelOriginHi","vec3"),t.attributes.add("modelOriginLo","vec3"),t.attributes.add("model","mat3"),t.attributes.add("modelNormal","mat3")):(t.vertex.uniforms.add("model","mat4"),t.vertex.uniforms.add("modelNormal","mat4")),e.instancedDoublePrecision?(t.include(w.DoublePrecision,e),t.vertex.uniforms.add("viewOriginHi","vec3"),t.vertex.uniforms.add("viewOriginLo","vec3"),Ee.add(C.glsl(R||(R=n(["\n    vec3 calculateVPos() {\n      return model * localPosition().xyz;\n    }\n    "],["\n    vec3 calculateVPos() {\n      return model * localPosition().xyz;\n    }\n    "]))))):Ee.add(C.glsl(T||(T=n(["\n    vec3 calculateVPos() {\n      return (model * localPosition()).xyz;\n    }\n    "],["\n    vec3 calculateVPos() {\n      return (model * localPosition()).xyz;\n    }\n    "])))),t.include(f.VerticalOffset,e),0===e.output&&(t.include(l.Transform,{linearDepth:!1}),0===e.normalType&&e.offsetBackfaces&&t.include(o.Offset),t.include(v.ComputeNormalTexture,e),t.include(p.VertexNormal,e),e.instancedColor&&t.attributes.add("instanceColor","vec4"),t.varyings.add("localvpos","vec3"),t.include(u.TextureCoordinateAttribute,e),t.include(a.ForwardLinearDepth,e),e.symbolColor?(t.include(i.DecodeSymbolColor),t.attributes.add("symbolColor","vec4"),t.varyings.add("colorMixMode","mediump float")):t.fragment.uniforms.add("colorMixMode","int"),t.include(d.VertexColor,e),t.vertex.uniforms.add("externalColor","vec4"),t.varyings.add("vcolorExt","vec4"),t.vertex.defines.addFloat("SYMBOL_ALPHA_CUTOFF",.001),Ee.add(C.glsl(I||(I=n(["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n    "],["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n    "])),e.instancedColor?"vcolorExt *= instanceColor;":"")),e.symbolColor&&Ee.add(C.glsl(z||(z=n(["\n        int symbolColorMixMode;\n        vcolorExt *= decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // = 1/255;\n        colorMixMode = float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n      "],["\n        int symbolColorMixMode;\n        vcolorExt *= decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // = 1/255;\n        colorMixMode = float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n      "])))),Ee.add(C.glsl(L||(L=n(["\n        if (vcolorExt.a < SYMBOL_ALPHA_CUTOFF) {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n    "],["\n        if (vcolorExt.a < SYMBOL_ALPHA_CUTOFF) {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n    "])))),e.instancedDoublePrecision?(0===e.normalType&&Ee.add(C.glsl(E||(E=n(["\n          vNormalWorld = normalize(modelNormal * vvLocalNormal(normalModel()).xyz);\n        "],["\n          vNormalWorld = normalize(modelNormal * vvLocalNormal(normalModel()).xyz);\n        "])))),Ee.add(C.glsl(j||(j=n(["\n          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          vpos -= originDelta;\n      "],["\n          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          vpos -= originDelta;\n      "]))))):0===e.normalType&&Ee.add(C.glsl(V||(V=n(["\n          vNormalWorld = normalize((modelNormal * vvLocalNormal(normalModel())).xyz);\n        "],["\n          vNormalWorld = normalize((modelNormal * vvLocalNormal(normalModel())).xyz);\n        "])))),Ee.add(C.glsl(N||(N=n(["\n          ","\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "],["\n          ","\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "])),e.verticalOffsetEnabled?"vpos += calculateVerticalOffset(vpos, localOrigin);":"",e.vertexTangets?"transformVertexTangent(mat3(modelNormal));":"",0===e.normalType&&e.offsetBackfaces?"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);":"")),t.include(s.Slice,e),t.include(g.EvaluateSceneLighting,e),t.include(m.EvaluateAmbientOcclusion,e),t.include(r.DiscardOrAdjustAlpha,e),e.receiveShadows&&t.include(S.ReadShadowMap,e),t.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("specular","vec3").add("opacity","float").add("layerOpacity","float"),e.treeRendering&&t.fragment.uniforms.add("view","mat4"),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),3===e.normalType&&t.extensions.add("GL_OES_standard_derivatives"),t.include(_.PhysicallyBasedRenderingParameters,e),t.include(x.PhysicallyBasedRendering,e),t.include(A.MixExternalColor,{stages:1}),t.include(b.Normals,e),je.add(C.glsl(F||(F=n(["\n        void main() {\n          discardBySlice(vpos);\n    "],["\n        void main() {\n          discardBySlice(vpos);\n    "])))),e.hasColorTexture?(je.add(C.glsl(G||(G=n(["\n          vec4 texColor = texture2D(tex, vuv0);\n      "],["\n          vec4 texColor = texture2D(tex, vuv0);\n      "])))),e.textureAlphaPremultiplied&&je.add(C.glsl(B||(B=n(["\n            texColor.rgb /= texColor.a;\n        "],["\n            texColor.rgb /= texColor.a;\n        "])))),je.add(C.glsl(H||(H=n(["\n            discardOrAdjustAlpha(texColor);\n      "],["\n            discardOrAdjustAlpha(texColor);\n      "]))))):je.add(C.glsl(U||(U=n(["\n            vec4 texColor = vec4(1.0);\n      "],["\n            vec4 texColor = vec4(1.0);\n      "])))),je.add(C.glsl(q||(q=n(["\n            shadingParams.viewDirection = normalize(vpos - camPos);\n    "],["\n            shadingParams.viewDirection = normalize(vpos - camPos);\n    "])))),je.add(C.glsl(3===e.normalType?k||(k=n(["\n        vec3 normal = normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n      "],["\n        vec3 normal = normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n      "])):W||(W=n(["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);\n      "],["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);\n      "])))),e.usePBR&&je.add(C.glsl(Z||(Z=n(["applyPBRFactors();"],["applyPBRFactors();"])))),je.add(C.glsl(X||(X=n(["\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "],["\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "])))),t.fragment.code.add(C.glsl(e.receiveShadows?Y||(Y=n(["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "])):0===e.viewingMode?J||(J=n(["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "],["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "])):K||(K=n(["\n        float shadow = 0.0;\n      "],["\n        float shadow = 0.0;\n      "])))),je.add(C.glsl(Q||(Q=n(["\n        vec3 matColor = max(ambient, diffuse);\n    "],["\n        vec3 matColor = max(ambient, diffuse);\n    "])))),e.attributeColor?je.add(C.glsl($||($=n(["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "],["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "])))):(je.add(C.glsl(ee||(ee=n(["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "],["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "])))),e.usePBR&&je.add(C.glsl(te||(te=n(["\n          if (int(colorMixMode) == 3 /* replace */) {\n            reflectance = 0.2;\n            roughness = 0.6;\n            metalness = 0.0;\n          }\n        "],["\n          if (int(colorMixMode) == 3 /* replace */) {\n            reflectance = 0.2;\n            roughness = 0.6;\n            metalness = 0.0;\n          }\n        "]))))),e.hasNormalTexture?(je.add(C.glsl(e.vertexTangets?ne||(ne=n(["\n        mat3 tangentSpace = computeTangentSpace(normal);\n        "],["\n        mat3 tangentSpace = computeTangentSpace(normal);\n        "])):ie||(ie=n(["\n        mat3 tangentSpace = computeTangentSpace(normal, vpos, vuv0);\n        "],["\n        mat3 tangentSpace = computeTangentSpace(normal, vpos, vuv0);\n        "])))),je.add(C.glsl(re||(re=n(["\n        vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);\n      "],["\n        vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);\n      "]))))):je.add(C.glsl(ae||(ae=n(["\n        vec3 shadedNormal = normal;\n      "],["\n        vec3 shadedNormal = normal;\n      "])))),e.treeRendering&&je.add(C.glsl(oe||(oe=n(["\n        shadedNormal = normalize(vNormalWorld);\n        albedo_ *= 1.2;\n        vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView = clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n\n        float transmittance = 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff = vColor.r;\n        float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight += backLightFactor * lightingMainIntensity;\n    "],["\n        shadedNormal = normalize(vNormalWorld);\n        albedo_ *= 1.2;\n        vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView = clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n\n        float transmittance = 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff = vColor.r;\n        float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight += backLightFactor * lightingMainIntensity;\n    "])))),je.add(C.glsl(e.usePBR?se||(se=n(["\n        float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n        vec3 normalGround = normalize(vpos + localOrigin);\n        vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);\n      "],["\n        float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n        vec3 normalGround = normalize(vpos + localOrigin);\n        vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);\n      "])):le||(le=n(["\n        vec3 shadedColor = evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n      "],["\n        vec3 shadedColor = evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n      "])))),je.add(C.glsl(ce||(ce=n(["\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "],["\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "]))))),1!==e.output&&3!==e.output||(t.include(l.Transform,{linearDepth:!0}),t.include(u.TextureCoordinateAttribute,e),t.include(P.VisualVariables,e),t.include(h.OutputDepth,e),t.include(s.Slice,e),t.vertex.uniforms.add("nearFar","vec2"),t.varyings.add("depth","float"),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),Ee.add(C.glsl(ue||(ue=n(["\n      void main(void) {\n        vpos = calculateVPos();\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n    "])))),e.instancedDoublePrecision&&Ee.add(C.glsl(de||(de=n(["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "],["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "])))),e.verticalOffsetEnabled&&Ee.add(C.glsl(pe||(pe=n(["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "])))),Ee.add(C.glsl(fe||(fe=n(["\n        gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "])))),t.include(r.DiscardOrAdjustAlpha,e),je.add(C.glsl(he||(he=n(["\n      void main(void) {\n        discardBySlice(vpos);\n    "],["\n      void main(void) {\n        discardBySlice(vpos);\n    "])))),e.hasColorTexture&&je.add(C.glsl(ve||(ve=n(["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "],["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "])))),je.add(C.glsl(me||(me=n(["\n        outputDepth(depth);\n      }\n    "],["\n        outputDepth(depth);\n      }\n    "]))))),2===e.output&&(3===e.normalType&&t.extensions.add("GL_OES_standard_derivatives"),t.include(l.Transform,{linearDepth:!1}),t.include(p.VertexNormal,e),t.include(u.TextureCoordinateAttribute,e),t.include(P.VisualVariables,e),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),t.vertex.uniforms.add("viewNormal","mat4"),t.varyings.add("vPositionView","vec3"),Ee.add(C.glsl(ge||(ge=n(["\n      void main(void) {\n        vpos = calculateVPos();\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n    "])))),e.instancedDoublePrecision?(0===e.normalType&&Ee.add(C.glsl(ye||(ye=n(["\n        vNormalWorld = normalize((viewNormal * vec4(modelNormal * vvLocalNormal(normalModel()).xyz, 1.0)).xyz);\n        "],["\n        vNormalWorld = normalize((viewNormal * vec4(modelNormal * vvLocalNormal(normalModel()).xyz, 1.0)).xyz);\n        "])))),Ee.add(C.glsl(be||(be=n(["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "],["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "]))))):0===e.normalType&&Ee.add(C.glsl(xe||(xe=n(["\n        vNormalWorld = normalize((viewNormal * modelNormal * vvLocalNormal(normalModel())).xyz);\n        "],["\n        vNormalWorld = normalize((viewNormal * modelNormal * vvLocalNormal(normalModel())).xyz);\n        "])))),e.verticalOffsetEnabled&&Ee.add(C.glsl(_e||(_e=n(["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "])))),Ee.add(C.glsl(Se||(Se=n(["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "])))),t.include(s.Slice,e),t.include(r.DiscardOrAdjustAlpha,e),je.add(C.glsl(Pe||(Pe=n(["\n      void main() {\n        discardBySlice(vpos);\n    "],["\n      void main() {\n        discardBySlice(vpos);\n    "])))),e.hasColorTexture&&je.add(C.glsl(we||(we=n(["\n          vec4 texColor = texture2D(tex, vuv0);\n          discardOrAdjustAlpha(texColor);\n      "],["\n          vec4 texColor = texture2D(tex, vuv0);\n          discardOrAdjustAlpha(texColor);\n      "])))),je.add(C.glsl(3===e.normalType?Ae||(Ae=n(["\n        vec3 normal = normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n      "],["\n        vec3 normal = normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n      "])):Ce||(Ce=n(["\n        vec3 normal = normalize(vNormalWorld);\n        if (gl_FrontFacing == false) normal = -normal;\n      "],["\n        vec3 normal = normalize(vNormalWorld);\n        if (gl_FrontFacing == false) normal = -normal;\n      "])))),je.add(C.glsl(Oe||(Oe=n(["\n        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "],["\n        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "]))))),4===e.output&&(t.include(l.Transform,{linearDepth:!1}),t.include(u.TextureCoordinateAttribute,e),t.include(P.VisualVariables,e),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),Ee.add(C.glsl(Me||(Me=n(["\n      void main(void) {\n        vpos = calculateVPos();\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n    "])))),e.instancedDoublePrecision&&Ee.add(C.glsl(De||(De=n(["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "],["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "])))),e.verticalOffsetEnabled&&Ee.add(C.glsl(Re||(Re=n(["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "])))),Ee.add(C.glsl(Te||(Te=n(["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "])))),t.include(s.Slice,e),t.include(r.DiscardOrAdjustAlpha,e),t.include(y.HighlightData),t.fragment.uniforms.add("depthTex","sampler2D"),t.fragment.uniforms.add("highlightViewportPixelSz","vec4"),je.add(C.glsl(Ie||(Ie=n(["\n      void main() {\n        discardBySlice(vpos);\n    "],["\n      void main() {\n        discardBySlice(vpos);\n    "])))),e.hasColorTexture&&je.add(C.glsl(ze||(ze=n(["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "],["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "])))),je.add(C.glsl(Le||(Le=n(["\n        gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "],["\n        gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "]))))),t}}).apply(null,i))||(e.exports=r)},A3J9:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("Q2wQ"),n("HZ3d"),n("eIBl"),n("LxLY"),n("8MXS"),n("FXVB"),n("1m5D"),n("Rdxj"),n("woUR"),n("5T2R"),n("+soW"),n("Z0CD"),n("ys4y"),n("4ziW"),n("o5p5"),n("sGGe"),n("bF8Q"),n("wOtw")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_){var S;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.Highlighted=512}(S||(S={}));var P=function(){function e(e){this._handles=new o,this.tool=e.tool}return e.prototype.destroy=function(){this._clear()},e.prototype._clear=function(){this._handles.removeAll(),this.tool.manipulators.remove(this.discManipulator),this.discManipulator=null},Object.defineProperty(e.prototype,"focused",{get:function(){return this.discManipulator.focused},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"dragging",{get:function(){return this.discManipulator.dragging},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"renderLocation",{get:function(){return this.discManipulator.renderLocation},enumerable:!0,configurable:!0}),e.prototype.recreateManipulators=function(){var e=this;this._clear(),this.discManipulator=this.createDiscManipulator(),this.tool.manipulators.add(this.discManipulator);var t=this.createDragAction(),n=x.createManipulatorDragHandler(this.discManipulator,this.createDragEventMappingFunction(),t);this._handles.add(n),this._handles.add([l.init(this.tool.graphic,"geometry",(function(){f.placeManipulatorAtGraphic(e.discManipulator,e.tool.graphic)})),this.discManipulator.events.on("immediate-click",(function(e){e.stopPropagation()})),l.init(this.tool.graphic,["visible","layer.visible"],(function(){e.discManipulator.visible=e.tool.graphic.visible&&e.tool.graphic.layer.visible}))]),this._handles.add([this.discManipulator.events.on("focus",(function(){e.tool.updateManipulators()}))])},e.prototype.updateManipulators=function(e,t){this.discManipulator.modelTransform=e,this.discManipulator.state=t?S.Highlighted:0},e.prototype.createDiscManipulator=function(){var e=this.tool.view,t=new m(g.createCylinderGeometry(v.DISC_HEIGHT,1,v.GEOMETRY_SEGMENTS,d.vec3f64.fromValues(0,0,1),d.vec3f64.fromValues(0,0,0)),"graphic-transform-disc"),n=c.mat4.fromScaling(u.mat4f64.create(),d.vec3f64.fromValues(v.DISC_RADIUS,v.DISC_RADIUS,v.DISC_RADIUS)),i=this.createMaterial(),r=this.createMaterial(.5);return new p.Manipulator3D({view:e,renderObjects:[{geometry:t,material:i,transform:n,stateMask:S.Highlighted},{geometry:t,material:r,transform:n}],worldSized:!1,autoScaleRenderObjects:!1,focusMultiplier:1,touchMultiplier:1,radius:v.DISC_COLLISION_RADIUS,elevationInfo:{mode:"on-the-ground",offset:0},collisionType:{type:"disc",direction:d.vec3f64.fromValues(0,0,1)}})},e.prototype.createMaterial=function(e){void 0===e&&(e=1);var t=v.HANDLE_COLOR.concat([e]),n=new y({color:t,transparent:1!==e,cullFace:2},"graphic-transform");return n.renderOccluded=2,n},e.prototype.createDragEventMappingFunction=function(){var e=this;return function(t){var n=_.createXYConstrainedFromProject(h.createForGraphicAtLocation(e.tool.view,e.tool.graphic,t.elevationAlignedLocation),s.expect(e.tool.graphic.geometry).spatialReference);return s.isNone(n)?null:function(e){var t=n(e);return s.isNone(t)?null:t}}},e.prototype.createDragAction=function(){var e=this,t=b.createGraphicDragAction(this.tool.graphic);return function(n){switch("start"===n.action&&e.tool.emit("graphic-translate-start",{graphic:e.tool.graphic}),t(n),n.action){case"update":e.tool.emit("graphic-translate",{graphic:e.tool.graphic,dx:n.deltaX,dy:n.deltaY,dz:n.deltaZ,type:"translate"});break;case"end":e.tool.emit("graphic-translate-stop",{graphic:e.tool.graphic})}}},e}();t.GraphicXYTransform=P}).apply(null,i))||(e.exports=r)},AASg:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){return function(){function e(){}return e.copyIntervals=function(e){for(var t=[],n=0;n<e.length;n++){var i=e[n];t.push([i[0],i[1]])}return t},e.convertFaceToIndexRange=function(e,t){for(var n=0;n<e.length;n++){var i=e[n];i[0]=i[0]*t,i[1]=i[1]*t+(t-1)}},e.sortIntervals=function(e){return e.sort((function(e,t){return e[0]===t[0]?e[1]>t[1]?1:e[1]<t[1]?-1:0:e[0]>t[0]?1:e[0]<t[0]?-1:0}))},e.intersectIntervals=function(e,t){if(e.length<=0)return[];for(var n=[],i=0;i<e.length;i++){var r=e[i];if(!(r[1]<t[0]||r[0]>t[1])){var a=[r[0],r[1]];a[0]<t[0]&&(a[0]=t[0]),a[1]>t[1]&&(a[1]=t[1]),n.push(a)}}return n},e.mergeIntervals=function(e){if(e.length<=0)return[];var t=[];e=this.sortIntervals(e),t.push(e[0]);for(var n=1;n<e.length;n++){var i=t[t.length-1];i[1]+1<e[n][0]?t.push(e[n]):i[1]<e[n][1]&&(i[1]=e[n][1],t.pop(),t.push(i))}return t},e.invertIntervals=function(e,t){for(var n=[],i=0,r=0;r<e.length;r++){var a=e[r];a[0]>i&&n.push([i,a[0]-1]),i=a[1]+1}return i<=t&&n.push([i,t]),n},e.offsetIntervals=function(e,t){for(var n=[],i=0;i<e.length;i++){var r=e[i];n.push([r[0]+t,r[1]+t])}return n},e}()}).apply(null,i))||(e.exports=r)},AgDx:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("rjU6"),n("+nCE"),n("CIy2")],void 0===(r=(function(e,t,n,i,r){function a(e){var t=r.getFirstObjectValue(e);return null==t?0:t.data.length/t.size}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(t,r,o,s){void 0===r&&(r=e.DefaultIndices),void 0===o&&(o=e.DefaultOffsets),void 0===s&&(s="triangle"),this.preinterleaved=!1;var l={};for(var c in t){var u=t[c],d=u.size;l[c]={data:u.data,size:d,offsetIdx:0,strideIdx:d}}if(r===e.DefaultIndices){var p=a(l),f=i.generateDefaultIndexArray(p);for(var h in r={},l)r[h]=f}this._id=i.getNewId(),this._vertexAttributes=l,this._indices=r,this._componentOffsets=n.createOffsets(o),this._primitiveType=s}return Object.defineProperty(e.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"vertexAttributes",{get:function(){return this._vertexAttributes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"indices",{get:function(){return this._indices},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"componentOffsets",{get:function(){return this._componentOffsets},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"indexCount",{get:function(){var e=r.getFirstObjectValue(this._indices);return null==e?0:e.length},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"primitiveType",{get:function(){return this._primitiveType},enumerable:!0,configurable:!0}),e.prototype.getVertexAttr=function(){return this.vertexAttributes},e.prototype.toRenderData=function(){return{id:this._id.toString(),preinterleaved:!1,indices:this._indices,vertexAttr:this._vertexAttributes}},e.prototype.getIndices=function(e){return this._indices[e]},e.prototype.getAttribute=function(e){return this._vertexAttributes[e]},e.prototype.estimateGpuMemoryUsage=function(){var e=0;return this._indices[r.VertexAttrConstants.POSITION]&&(e+=3*this._indices[r.VertexAttrConstants.POSITION].length*4),this._indices[r.VertexAttrConstants.NORMAL]&&(e+=3*this._indices[r.VertexAttrConstants.NORMAL].length*4),this._indices[r.VertexAttrConstants.UV0]&&(e+=2*this._indices[r.VertexAttrConstants.UV0].length*4),this._indices[r.VertexAttrConstants.COLOR]&&(e+=1*this._indices[r.VertexAttrConstants.COLOR].length*4),e},e.DefaultIndices={},e.DefaultOffsets=new Uint32Array(0),e}();t.GeometryData=o}).apply(null,i))||(e.exports=r)},AvU8:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("2Atf"),n("Gtr7"),n("pcDC"),n("BcWh"),n("LxLY"),n("jBNx"),n("Vx27"),n("1dvD"),n("YX1r"),n("51bw"),n("FXVB"),n("1m5D"),n("W9tT"),n("ab6c"),n("0LE5"),n("Rdxj"),n("lRq4"),n("ZcgO"),n("aWgr"),n("mmEe"),n("JjCO"),n("m4lJ"),n("9DjX"),n("ZO6V"),n("ZJC8")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_,S,P,w,A,C,O,M){function D(e){return 0!==e[12]||0!==e[13]||0!==e[14]}Object.defineProperty(t,"__esModule",{value:!0});var R=function(e){function t(t){var n=e.call(this,t)||this;return n.hideOnGrab=!1,n.moveOnDrag=!0,n.snapToPointer=!0,n.collisionType={type:"point"},n.collisionPriority=0,n.renderObjects=[],n.autoScaleRenderObjects=!0,n._radius=10,n._worldSized=!1,n._focusMultiplier=2,n._touchMultiplier=2.5,n.interactive=!0,n.selectable=!1,n.cursor=null,n.dragging=!1,n._areAnyEngineObjectsVisible=!1,n.events=new s({target:n}),n._position=b.vec3f64.create(),n._modelTransform=v.mat4f64.create(),n._dragOffset=null,n._dirtyScreenPoint=c.createScreenPoint(),n._dirtyScreenPointArray=c.createScreenPointArray(),n._dirtyRenderScreenPointArray=c.createRenderScreenPointArray3(),n._dirtyOriginScreenPointArray=c.createScreenPointArray(),n._dirtyScreenPixelSize=1,n._screenPositionDirty=!0,n._engineResourcesAddedToStage=!1,n._engineResources=null,n._attached=!1,n._engineLayerId=null,n._materialIdReferences=null,n._hitResult={onSurface:!1,surfaceType:"ground"},n}return i(t,e),t.prototype.initialize=function(){var e=this;this._intersector=new A(this.view.viewingMode),this._mapPoint=_.makeDehydratedPoint(0,0,0,this.view.spatialReference),this.events.on("drag",(function(t){return e.drag(t)}))},t.prototype.destroy=function(){this._removeResourcesFromStage(),this._engineResources=null,this._set("view",null),this._camera=null},Object.defineProperty(t.prototype,"alignment",{get:function(){return this._get("alignment")},set:function(e){this._set("alignment",e),this.constructed&&this._refreshMapPoint()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"visible",{set:function(e){e!==this._get("visible")&&(this._set("visible",e),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"radius",{get:function(){return this._radius},set:function(e){e!==this._radius&&(this._radius=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"worldSized",{get:function(){return this._worldSized},set:function(e){e!==this._worldSized&&(this._worldSized=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"focusMultiplier",{get:function(){return this._focusMultiplier},set:function(e){this._focusMultiplier=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"touchMultiplier",{get:function(){return this._touchMultiplier},set:function(e){this._touchMultiplier=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"modelTransform",{get:function(){return this._modelTransform},set:function(e){D(e)&&(this._screenPositionDirty=!0),h.mat4.copy(this._modelTransform,e),this._updateEngineObject()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"position",{get:function(){return this._position},set:function(e){this.view.renderCoordsHelper.fromRenderCoords(e,this._mapPoint,this._mapPoint.spatialReference),this._refreshMapPoint()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"mapPoint",{get:function(){return this._mapPoint},set:function(e){_.clonePoint(e,this._mapPoint),this._refreshMapPoint()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"grabbing",{set:function(e){e!==this._get("grabbing")&&(this._set("grabbing",e),this._updateEngineObject()),e||(this._dragOffset=null)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"hovering",{set:function(e){e!==this._get("hovering")&&(this._set("hovering",e),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"selected",{set:function(e){e!==this._get("selected")&&(this._set("selected",e),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"state",{set:function(e){e!==this._get("state")&&(this._set("state",e),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"areAnyEngineObjectsVisible",{get:function(){return this._areAnyEngineObjectsVisible},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"surfaceType",{get:function(){return this._hitResult.onSurface?this._hitResult.surfaceType:null},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"focused",{get:function(){return this._focused},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_focused",{get:function(){return this._get("hovering")||this._get("grabbing")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"screenPoint",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyScreenPoint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_screenPointArray",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyScreenPointArray},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_renderScreenPointArray",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyRenderScreenPointArray},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_originScreenPointArray",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyOriginScreenPointArray},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_screenPixelSize",{get:function(){return this._updateScreenSpaceProperties(),this._dirtyScreenPixelSize},enumerable:!0,configurable:!0}),t.prototype._updateScreenSpaceProperties=function(){if(this._screenPositionDirty){this._screenPositionDirty=!1,this._dirtyScreenPixelSize=this._camera.computeScreenPixelSizeAt(this._position);var e,t=D(this._modelTransform);if(t){var n=this._calculateModelTransformOffset(k);e=y.vec3.add(n,n,this._position)}else e=this._position;this._camera.projectPoint(e,this._dirtyRenderScreenPointArray),this._camera.renderToScreen(this._dirtyRenderScreenPointArray,this._dirtyScreenPointArray),c.screenPointArrayToObject(this._dirtyScreenPointArray,this._dirtyScreenPoint),t?(this._camera.projectPoint(this._position,z),this._camera.renderToScreen(z,this._dirtyOriginScreenPointArray)):m.vec2.copy(this._dirtyOriginScreenPointArray,this._dirtyScreenPointArray)}},t.prototype.intersectionDistance=function(e,t){if(!this._get("visible"))return null;var n=c.screenPointObjectToArray(e,I),i=this._getCollisionRadius(t),r=-1*this._get("collisionPriority");switch(this.collisionType.type){case"point":if(m.vec2.squaredDistance(this._screenPointArray,n)<i*i)return this._renderScreenPointArray[2]+r;break;case"line":for(var a=this.collisionType.paths,s=this._getWorldToScreenObjectScale(),l=this._calculateObjectTransform(s,N),u=i*this._screenPixelSize,d=S.ray.fromScreen(this._camera,n,E),f=0,h=a;f<h.length;f++)if(0!==(z=h[f]).length)for(var v=y.vec3.transformMat4(G,z[0],l),g=1;g<z.length;g++){var b=y.vec3.transformMat4(B,z[g],l);if(null!=(V=S.lineSegment.closestRayDistance2(S.lineSegment.fromPoints(v,b,L),d))&&V<u*u){var x=y.vec3.add(w.sv3d.get(),v,b);y.vec3.scale(x,x,.5);var _=c.castRenderScreenPointArray(w.sv3d.get());return this._camera.projectPoint(x,_),_[2]+r}y.vec3.copy(v,b)}break;case"disc":var P=this.collisionType.direction,A=(s=this._getWorldToScreenObjectScale(),l=this._calculateObjectTransform(s,N),u=i*this._screenPixelSize,d=S.ray.fromScreen(this._camera,n,E),p.mat3.fromMat4(j,l)),C=y.vec3.transformMat3(U,P,A),O=this._calculateModelTransformPosition(q);if(S.plane.fromPositionAndNormal(O,C,F),S.plane.intersectRay(F,d,M=H)&&y.vec3.squaredDistance(M,O)<u*u)return this._renderScreenPointArray[2]+r;break;case"ribbon":var M,D=this.collisionType;if(a=D.paths,P=D.direction,s=this._getWorldToScreenObjectScale(),l=this._calculateObjectTransform(s,N),u=i*this._camera.computeScreenPixelSizeAt(this._position),d=S.ray.fromScreen(this._camera,n,E),A=p.mat3.fromMat4(j,l),C=y.vec3.transformMat3(U,P,A),O=this._calculateModelTransformPosition(q),S.plane.fromPositionAndNormal(O,C,F),!S.plane.intersectRay(F,d,M=H))break;for(var R=0,T=a;R<T.length;R++){var z;if(0!==(z=T[R]).length)for(v=y.vec3.transformMat4(G,z[0],l),g=1;g<z.length;g++){var V;if(b=y.vec3.transformMat4(B,z[g],l),null!=(V=S.lineSegment.distance2(S.lineSegment.fromPoints(v,b,L),M))&&V<u*u)return x=y.vec3.add(w.sv3d.get(),v,b),y.vec3.scale(x,x,.5),_=c.castRenderScreenPointArray(w.sv3d.get()),this._camera.projectPoint(x,_),_[2]+r;y.vec3.copy(v,b)}}break;default:o.neverReached(this.collisionType)}return null},t.prototype.drag=function(e){if(this.moveOnDrag){var t=c.screenPointObjectToArray(e.screenPoint,I);l.isNone(this._dragOffset)&&this.grabbing&&!this.snapToPointer&&(this._dragOffset=m.vec2.subtract(g.vec2f32.create(),t,this._originScreenPointArray)),l.isSome(this._dragOffset)&&m.vec2.subtract(t,t,this._dragOffset),this.view.sceneIntersectionHelper.intersectToolIntersectorScreen(t,this._intersector,"on-the-ground"===this.alignment?T:null);var n=this._intersector.results.min,i=H;n.getIntersectionPoint(i)?(this.position=i,this._hitResult.onSurface=!0,this._hitResult.surfaceType="TerrainRenderer"===n.intersector?"ground":"feature"):this._hitResult.onSurface=!1}},t.prototype.attach=function(e){if(void 0===e&&(e={manipulator3D:{}}),this.view._stage){var t=e.manipulator3D;if(this._engineLayerId=t.engineLayerId,l.isNone(this._engineLayerId)){var n=new O("manipulator-3d",{isPickable:!1});this.view._stage.add(0,n),this.view._stage.addToViewContent([n.id]),this._engineLayerId=n.id,t.engineLayerId=n.id}t.engineLayerReferences=(t.engineLayerReferences||0)+1,this._materialIdReferences=t.materialIdReferences,l.isNone(this._materialIdReferences)&&(this._materialIdReferences=new Map,t.materialIdReferences=this._materialIdReferences),this._camera=this.view.state.camera,this._attached=!0,this._updateEngineObject(),P.canProject(this._mapPoint.spatialReference,this.view.spatialReference)||(this.mapPoint=_.makeDehydratedPoint(0,0,0,this.view.spatialReference))}},t.prototype.detach=function(e){void 0===e&&(e={manipulator3D:{}});var t=e.manipulator3D;t.engineLayerReferences--;var n=0===t.engineLayerReferences;n&&(t.engineLayerId=null),this._removeResourcesFromStage(n),this._engineResources=null,this._engineLayerId=null,this._materialIdReferences=null,this._camera=null,this._attached=!1},t.prototype.onViewChange=function(){this._camera=this.view.state.camera,this._screenPositionDirty=!0,this._updateEngineObject()},t.prototype.onElevationChange=function(e){this.view.renderCoordsHelper.fromRenderCoords(this.position,W,e.spatialReference)&&x.containsPoint(e.extent,W)&&this._refreshMapPoint(!0)},t.prototype._refreshMapPoint=function(e){switch(void 0===e&&(e=!1),this.alignment){case"none":break;case"on-the-ground":var t=this.view.elevationProvider.getElevation(this.mapPoint,"ground");if(t===this._mapPoint.z&&e)return;this._mapPoint.z=t;break;default:o.neverReached(this.alignment)}this._screenPositionDirty=!0,this._hitResult.onSurface=!1,this.view.renderCoordsHelper.toRenderCoords(this._mapPoint,this._position),this._updateEngineObject()},t.prototype._updateEngineObject=function(){if(this._areAnyEngineObjectsVisible=!1,this._attached){if(!1===this._get("visible"))return void this._removeResourcesFromStage();var e=this._getWorldToScreenObjectScale(),t=N;if(!0===this._get("autoScaleRenderObjects")){var n=this._getFocusedSize(this._radius,this._focused)*e;this._calculateObjectTransform(n,t)}else this._calculateObjectTransform(e,t);for(var i=this._ensureEngineResources().objectsByState,r=(this._focused?2:1)|(this._get("selected")?8:4),a=this._get("hideOnGrab")&&this._get("grabbing"),o=0,s=i;o<s.length;o++){var l=s[o],c=l.stateMask,u=l.objects;if(a)for(var d=0,p=u;d<p.length;d++)(b=p[d]).hideAllComponents();else{var f=!(0!=(15&c))||(r&c)==(15&c),h=!(0!=(65520&c))||(this._get("state")&c)==(65520&c);if(f&&h)for(var v=0,m=u;v<m.length;v++)(b=m[v]).unhideAllComponents(),b.objectTransformation=t,this._areAnyEngineObjectsVisible=!0;else for(var g=0,y=u;g<y.length;g++){var b;(b=y[g]).hideAllComponents()}}}}},t.prototype._ensureEngineResources=function(){if(l.isNone(this._engineResources)){var e=this.view._stage.getContent(0,l.expect(this._engineLayerId)),t=[],n=new Set;this.renderObjects.forEach((function(e){var i=e.material;n.has(i)||(t.push(i),n.add(i))}));var i=new Map;this.renderObjects.forEach((function(e){var t=new M({idHint:"manipulator"});!function(e,t){var n=t.geometry,i=t.material,r=t.transform;Array.isArray(n)?n.forEach((function(t){return e.addGeometry(t,i,r)})):e.addGeometry(n,i,r)}(t,e);var n=e.stateMask||0,r=i.get(n)||[];r.push(t),i.set(n,r)}));var r=[];i.forEach((function(e,t){r.push({stateMask:t,objects:e})})),this._engineResources={objectsByState:r,layer:e,materials:t}}return this._addResourcesToStage(),this._engineResources},t.prototype._addResourcesToStage=function(){var e=this;if(!this._engineResourcesAddedToStage&&!l.isNone(this._engineResources)){var t=this._engineResources,n=t.objectsByState,i=t.layer;t.materials.forEach((function(t){var n=l.expect(e._materialIdReferences),i=n.get(t.id)||0;0===i&&e.view._stage.add(3,t),n.set(t.id,i+1)})),n.forEach((function(t){t.objects.forEach((function(t){i.addObject(t),e.view._stage.add(1,t)}))})),this._engineResourcesAddedToStage=!0}},t.prototype._removeResourcesFromStage=function(e){var t=this;if(void 0===e&&(e=!1),this._engineResourcesAddedToStage&&!l.isNone(this._engineResources)){var n=this._engineResources,i=n.layer,r=n.materials;n.objectsByState.forEach((function(e){e.objects.forEach((function(e){i.removeObject(e),t.view._stage.remove(1,e.id)}))})),r.forEach((function(e){var n=l.expect(t._materialIdReferences),i=n.get(e.id);1===i?(t.view._stage.remove(3,e.id),n.delete(e.id)):n.set(e.id,i-1)})),e&&this.view._stage.remove(0,i.id),this._engineResourcesAddedToStage=!1}},t.prototype._getCollisionRadius=function(e){return this._getFocusedSize(this._radius,!0)*("touch"===e?this._touchMultiplier:1)},t.prototype._getFocusedSize=function(e,t){return e*(t?this._focusMultiplier:1)},t.prototype._getWorldToScreenObjectScale=function(){return this._worldSized?1:this._screenPixelSize},t.prototype._calculateModelTransformPosition=function(e){var t=this._getWorldToScreenObjectScale(),n=this._calculateObjectTransform(t,V);return y.vec3.set(e,n[12],n[13],n[14])},t.prototype._calculateModelTransformOffset=function(e){var t=this._calculateModelTransformPosition(e);return y.vec3.subtract(e,t,this._position)},t.prototype._calculateObjectTransform=function(e,t){return h.mat4.set(t,e,0,0,0,0,e,0,0,0,0,e,0,0,0,0,1),h.mat4.multiply(t,t,this._modelTransform),t[12]+=this._position[0],t[13]+=this._position[1],t[14]+=this._position[2],t[15]=1,t},n([u.property({constructOnly:!0,nonNullable:!0})],t.prototype,"view",void 0),n([u.property({value:"none",nonNullable:!0})],t.prototype,"alignment",null),n([u.property()],t.prototype,"hideOnGrab",void 0),n([u.property()],t.prototype,"moveOnDrag",void 0),n([u.property()],t.prototype,"snapToPointer",void 0),n([u.property()],t.prototype,"collisionType",void 0),n([u.property({type:d.Integer})],t.prototype,"collisionPriority",void 0),n([u.property({constructOnly:!0})],t.prototype,"renderObjects",void 0),n([u.property()],t.prototype,"autoScaleRenderObjects",void 0),n([u.property({value:!0})],t.prototype,"visible",null),n([u.property()],t.prototype,"radius",null),n([u.property()],t.prototype,"worldSized",null),n([u.property()],t.prototype,"focusMultiplier",null),n([u.property()],t.prototype,"touchMultiplier",null),n([u.property()],t.prototype,"interactive",void 0),n([u.property()],t.prototype,"selectable",void 0),n([u.property()],t.prototype,"cursor",void 0),n([u.property({value:!1})],t.prototype,"grabbing",null),n([u.property()],t.prototype,"dragging",void 0),n([u.property({value:!1})],t.prototype,"hovering",null),n([u.property({value:!1})],t.prototype,"selected",null),n([u.property({value:0})],t.prototype,"state",null),n([u.property({dependsOn:["hovering","grabbing"]})],t.prototype,"focused",null),n([u.subclass("esri.views.interactive.Manipulator3D")],t)}(u.declared(a));t.Manipulator3D=R;var T={include:new Set};T.include.add(C.TERRAIN_ID);var I=c.createScreenPointArray(),z=c.createRenderScreenPointArray3(),L=S.lineSegment.create(),E=S.ray.create(),j=f.mat3f64.create(),V=v.mat4f64.create(),N=v.mat4f64.create(),F=S.plane.create(),G=b.vec3f64.create(),B=b.vec3f64.create(),H=b.vec3f64.create(),U=b.vec3f64.create(),q=b.vec3f64.create(),k=b.vec3f64.create(),W=b.vec3f64.create()}).apply(null,i))||(e.exports=r)},BwdQ:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xoE+"),n("LxLY"),n("FXVB"),n("1m5D"),n("DIqE"),n("Rdxj"),n("2fXB"),n("O7NG"),n("WRgd"),n("lRq4"),n("0FS0"),n("ZPQp"),n("ZcgO"),n("mmEe")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v){function m(e){var t=e.paths[0];if(!t||0===t.length)return null;var n=f.getPointOnPath(t,f.getPathLength(t)/2);return h.makeDehydratedPoint(n[0],n[1],n[2],e.spatialReference)}function g(e,t,n){var i=n?e:h.clonePoint(e);return t&&e?v.pointToPoint(e,i,t)?i:null:i}function y(e){if(Array.isArray(e)){for(var t=0,n=e;t<n.length;t++)if(!y(n[t]))return!1;return!0}return null==e||e>=0}Object.defineProperty(t,"__esModule",{value:!0}),t.computeCentroid=function(e,t){if("point"===e.type)return g(e,t,!1);if(h.isHydratedGeometry(e))switch(e.type){case"extent":return g(e.center,t,!1);case"polygon":return g(e.centroid,t,!1);case"polyline":return g(m(e),t,!0);case"mesh":return g(e.extent.center,t,!1)}else switch(e.type){case"extent":return g(function(e){var t=n.isFinite(e.zmin);return h.makeDehydratedPoint(.5*(e.xmax+e.xmin),.5*(e.ymax+e.ymin),t?.5*(e.zmax+e.zmin):void 0,e.spatialReference)}(e),t,!0);case"polygon":return g(function(e){var t=e.rings[0];if(!t||0===t.length)return null;var n=p.ringsCentroid(e.rings,e.hasZ);return h.makeDehydratedPoint(n[0],n[1],n[2],e.spatialReference)}(e),t,!0);case"polyline":return g(m(e),t,!0)}},t.enlargeExtent=function(e,t,n){if(e){t||(t=d.create());var i=.5*e.width*(n-1),r=.5*e.height*(n-1);return e.width<1e-7*e.height?i+=r/20:e.height<1e-7*e.width&&(r+=i/20),l.vec4.set(t,e.xmin-i,e.ymin-r,e.xmax+i,e.ymax+r),t}return null},t.updateVertexAttributeAuxpos1w=function(e,t){for(var n=0;n<e.geometries.length;++n){var i=e.geometries[n].data.vertexAttributes.auxpos1;i&&i.data[3]!==t&&(i.data[3]=t,e.geometryVertexAttrsUpdated(n))}},t.mixinColorAndOpacity=function(e,t){var n=c.vec4f64.clone(c.vec4f64.ONES);return i.isSome(e)&&(n[0]=e[0],n[1]=e[1],n[2]=e[2]),i.isSome(t)?n[3]=t:i.isSome(e)&&e.length>3&&(n[3]=e[3]),n},t.overrideColor=function(e,t,n,r,a,o){void 0===o&&(o=[0,0,0,0]);for(var s=0;s<3;++s)o[s]=i.isSome(e)&&null!=e[s]?e[s]:i.isSome(n)&&null!=n[s]?n[s]:a[s];return o[3]=i.isSome(t)?t:i.isSome(r)?r:a[3],o},t.computeObjectScale=function(e,t,n,i){void 0===e&&(e=s.vec3f64.ONES),void 0===i&&(i=1);var r=new Array(3);if(null==t||null==n)r[0]=1,r[1]=1,r[2]=1;else{for(var a=void 0,o=0,l=2;l>=0;l--){var c=e[l],u=void 0,d=null!=c,p=n[l];"symbolValue"===c||0===l&&!a&&!d?u=0!==p?t[l]/p:1:d&&"proportional"!==c&&isFinite(c)&&(u=0!==p?c/p:1),null!=u&&(r[l]=u,a=u,o=Math.max(o,Math.abs(u)))}for(l=2;l>=0;l--)null==r[l]?r[l]=a:0===r[l]&&(r[l]=.001*o)}for(l=2;l>=0;l--)r[l]/=i;return s.vec3f64.fromArray(r)},t.computeSizeWithResourceSize=function(e,t){var n=t.width,i=t.depth,r=t.height,a=t.isPrimitive?10:1;if(null==n&&null==r&&null==i)return[a*e[0],a*e[1],a*e[2]];for(var o,l=s.vec3f64.fromValues(n,i,r),c=0;c<3;c++){var u=l[c];if(null!=u){o=u/e[c];break}}for(c=0;c<3;c++)null==l[c]&&(l[c]=e[c]*o);return l},t.validateSymbolLayerSize=function(e){return function(e){return null!=e.isPrimitive}(e)&&(e=[e.width,e.depth,e.height]),y(e)?null:"Symbol sizes may not be negative values"},t.isValidSize=y,t.computeObjectRotation=function(e,t,n,i){void 0===i&&(i=a.mat4f64.create());var o=e||0,s=t||0,l=n||0;return 0!==o&&r.mat4.rotateZ(i,i,-o/180*Math.PI),0!==s&&r.mat4.rotateX(i,i,s/180*Math.PI),0!==l&&r.mat4.rotateY(i,i,l/180*Math.PI),i},t.demResolutionForBoundingBox=function(e,t){return null!=t.minDemResolution?t.minDemResolution:u.isPoint(e)?t.minDemResolutionForPoints:.01*u.maximumDimension(e)},t.namedAnchorToHUDMaterialAnchorPos={"bottom-left":o.vec2f64.fromValues(0,0),bottom:o.vec2f64.fromValues(.5,0),"bottom-right":o.vec2f64.fromValues(1,0),left:o.vec2f64.fromValues(0,.5),center:o.vec2f64.fromValues(.5,.5),right:o.vec2f64.fromValues(1,.5),"top-left":o.vec2f64.fromValues(0,1),top:o.vec2f64.fromValues(.5,1),"top-right":o.vec2f64.fromValues(1,1)}}).apply(null,i))||(e.exports=r)},CP88:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("tUyH"),n("v22c"),n("s6rJ"),n("hsRy")],void 0===(r=(function(e,t,n,i,r,a,o){Object.defineProperty(t,"__esModule",{value:!0});var s=function(e){function t(t){var n=e.call(this,t)||this;return n.techniqueConfig=new r.WaterTechniqueConfiguration,n.updateParameters(),n}return n(t,e),t.prototype.updateParameters=function(){this.params=a.copyParameters(this.material.getParameters()),this.selectProgram(0)},t.prototype.selectProgram=function(e){this.techniqueConfig.output=e,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.receiveShadows=this.params.receiveShadows,this.techniqueConfig.slice=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.technique=this.techniqueRep.acquireAndReleaseExisting(r.WaterTechnique,this.techniqueConfig,this.technique)},t.prototype.beginSlot=function(e){var t=4;return this.params.transparent&&(t=this.params.writeDepth?6:9),e===t},t.prototype.getProgram=function(){return this.technique.program},t.prototype.getPrograms=function(){return null},t.prototype._initTextures=function(e){this.texturePaths=[this.params.waveTexture,this.params.perturbationTexture],o.waterTextureRepo.initialize(e,this.texturePaths)},t.prototype._setWaveUniforms=function(e){e.setUniform1i("texWaveNormal",0),e.setUniform1i("texWavePerturbation",1),e.setUniform4f("waveParams",this.params.waveStrength,this.params.waveTextureRepeat,this.params.flowStrength,this.params.flowOffset),e.setUniform2f("waveDirection",this.params.waveDirection[0]*this.params.waveVelocity,this.params.waveDirection[1]*this.params.waveVelocity),e.setUniform1f("timeElapsed",.001*this.material.animation.time*this.params.animationSpeed)},t.prototype._updateShadowState=function(e){e.shadowMappingEnabled!==this.params.receiveShadows&&(this.material.setParameterValues({receiveShadows:e.shadowMappingEnabled}),this.updateParameters())},t.prototype.ensureResources=function(e){return o.waterTextureRepo.ready()||o.waterTextureRepo.loading()||this._initTextures(e),o.waterTextureRepo.ready()?2:1},t.prototype.bind=function(e,t){o.waterTextureRepo.ready()&&(this._updateShadowState(t),e.bindProgram(this.technique.program),e.setPipelineState(this.technique.pipeline),o.waterTextureRepo.bindRepo(e),this.technique.program.setUniform4fv("waterColor",this.params.color),this._setWaveUniforms(this.technique.program))},t.prototype.release=function(){},t.prototype.bindView=function(e){var t=this.technique.program;t.setUniform3fv("localOrigin",e.origin),a.bindView(e.origin,e.view,t),a.bindCamPos(e.origin,e.viewInvTransp,t),this.params.slicePlaneEnabled&&a.bindSlicePlane(e.origin,e.slicePlane,t),e.shadowMappingEnabled&&(e.shadowMap.bind(t),e.shadowMap.bindView(t,e.origin))},t.prototype.bindInstance=function(e){this.technique.program.setUniformMatrix4fv("model",e.transformation)},t.prototype.getDrawMode=function(){return 4},t}(i.GLMaterial);t.WaterGLMaterial=s;var l=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return n(t,e),t.prototype.updateParameters=function(){this.params=a.copyParameters(this.material.getParameters()),this.selectProgram(5)},t.prototype.bind=function(e){e.bindProgram(this.technique.program),e.setPipelineState(this.technique.pipeline),this.technique.program.setUniform4fv("waterColor",this.params.color)},t.prototype.bindView=function(e){this.technique.program.setUniform3fv("localOrigin",e.origin),a.bindView(e.origin,e.view,this.technique.program)},t.prototype.beginSlot=function(e){return null==e},t}(s);t.WaterDrapedGLMaterial=l;var c=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return n(t,e),t.prototype.updateParameters=function(){this.params=a.copyParameters(this.material.getParameters()),this.selectProgram(2)},t.prototype.bind=function(e){o.waterTextureRepo.ready()&&(e.bindProgram(this.technique.program),e.setPipelineState(this.technique.pipeline),o.waterTextureRepo.bindRepo(e),this._setWaveUniforms(this.technique.program))},t.prototype.bindView=function(e){this.technique.program.setUniform3fv("localOrigin",e.origin),a.bindView(e.origin,e.view,this.technique.program)},t.prototype.beginSlot=function(e){return 19===e},t}(s);t.WaterNormalGLMaterial=c}).apply(null,i))||(e.exports=r)},CsnI:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("qKT0"),n("PaEL"),n("zdOl"),n("3PFg"),n("r0i9"),n("W/V4"),n("FQ4r"),n("lBa0"),n("ff/U"),n("s6rJ"),n("9dVJ"),n("G0ER")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h){Object.defineProperty(t,"__esModule",{value:!0});var v=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return n(i,t),i.prototype.initializeProgram=function(e){var t=i.shader.get(),n=this.configuration,r=t.build({output:n.output,viewingMode:e.viewingMode,receiveShadows:n.receiveShadows,slicePlaneEnabled:n.slice,sliceHighlightDisabled:n.sliceHighlightDisabled,symbolColor:n.symbolColors,vvSize:n.vvSize,vvColor:n.vvColor,instanced:n.instanced,instancedColor:n.instancedColor,instancedDoublePrecision:n.instancedDoublePrecision,useOldSceneLightInterface:!1,usePBR:n.usePBR,hasMetalnessAndRoughnessTexture:n.hasMetalnessAndRoughnessTexture,hasEmissionTexture:n.hasEmissionTexture,hasOcclusionTexture:n.hasOcclusionTexture,hasNormalTexture:n.hasNormalTexture,hasColorTexture:n.hasColorTexture,receiveAmbientOcclusion:n.receiveAmbientOcclusion,usePBRforWater:!1,useCustomDTRExponentForWater:!1,normalType:n.normalsTypeDerivate?3:0,doubleSidedMode:n.doubleSidedMode,vertexTangets:n.vertexTangents,attributeTextureCoordinates:n.hasMetalnessAndRoughnessTexture||n.hasEmissionTexture||n.hasOcclusionTexture||n.hasNormalTexture||n.hasColorTexture?1:0,textureAlphaPremultiplied:n.textureAlphaPremultiplied,attributeColor:n.vertexColors,screenSizePerspectiveEnabled:n.screenSizePerspective,verticalOffsetEnabled:n.verticalOffset,offsetBackfaces:n.offsetBackfaces,doublePrecisionRequiresObfuscation:s.doublePrecisionRequiresObfuscation(e.rctx),alphaDiscardMode:n.alphaDiscardMode,treeRendering:n.treeRendering,supportsTextureAtlas:!1});return new h(e.rctx,r.generateSource("vertex"),r.generateSource("fragment"),d.Default3D)},i.prototype.bindPass=function(e,t,n){var i=this.configuration.output;0===i?(this.program.setUniform3fv("ambient",t.ambient),this.program.setUniform3fv("diffuse",t.diffuse),this.program.setUniform3fv("specular",t.specular),this.program.setUniform4fv("externalColor",t.externalColor),this.program.setUniform1i("colorMixMode",p.colorMixModes[t.colorMixMode]),this.program.setUniform1f("opacity",t.opacity),this.program.setUniform1f("layerOpacity",t.layerOpacity),this.configuration.usePBR&&a.PhysicallyBasedRenderingParameters.bindUniforms(this.program,t)):1===i||3===i?this.program.setUniform2fv("nearFar",n.nearFar):4===i&&r.OutputHighlight.bindOutputHighlight(e,this.program,n),o.VisualVariables.bindUniformsForSymbols(this.program,t),"mask"!==t.textureAlphaMode&&"maskBlend"!==t.textureAlphaMode||this.program.setUniform1f("textureAlphaCutoff",t.textureAlphaCutoff)},i.prototype.initializePipeline=function(){return null},i.shader=new l.ReloadableShaderModule(f,"./DefaultMaterial.glsl",e),i}(c.ShaderTechnique);t.DefaultMaterialTechnique=v;var m=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.output=0,t.alphaDiscardMode=1,t.doubleSidedMode=0,t.vertexColors=!1,t.offsetBackfaces=!1,t.symbolColors=!1,t.vvSize=!1,t.vvColor=!1,t.verticalOffset=!1,t.receiveShadows=!1,t.slice=!1,t.sliceHighlightDisabled=!1,t.receiveAmbientOcclusion=!1,t.screenSizePerspective=!1,t.textureAlphaPremultiplied=!1,t.treeRendering=!1,t.hasColorTexture=!1,t.usePBR=!1,t.hasMetalnessAndRoughnessTexture=!1,t.hasEmissionTexture=!1,t.hasOcclusionTexture=!1,t.hasNormalTexture=!1,t.instanced=!1,t.instancedColor=!1,t.instancedDoublePrecision=!1,t.vertexTangents=!1,t.normalsTypeDerivate=!1,t}return n(t,e),i([u.parameter({count:6})],t.prototype,"output",void 0),i([u.parameter({count:4})],t.prototype,"alphaDiscardMode",void 0),i([u.parameter({count:3})],t.prototype,"doubleSidedMode",void 0),i([u.parameter()],t.prototype,"vertexColors",void 0),i([u.parameter()],t.prototype,"offsetBackfaces",void 0),i([u.parameter()],t.prototype,"symbolColors",void 0),i([u.parameter()],t.prototype,"vvSize",void 0),i([u.parameter()],t.prototype,"vvColor",void 0),i([u.parameter()],t.prototype,"verticalOffset",void 0),i([u.parameter()],t.prototype,"receiveShadows",void 0),i([u.parameter()],t.prototype,"slice",void 0),i([u.parameter()],t.prototype,"sliceHighlightDisabled",void 0),i([u.parameter()],t.prototype,"receiveAmbientOcclusion",void 0),i([u.parameter()],t.prototype,"screenSizePerspective",void 0),i([u.parameter()],t.prototype,"textureAlphaPremultiplied",void 0),i([u.parameter()],t.prototype,"treeRendering",void 0),i([u.parameter()],t.prototype,"hasColorTexture",void 0),i([u.parameter()],t.prototype,"usePBR",void 0),i([u.parameter()],t.prototype,"hasMetalnessAndRoughnessTexture",void 0),i([u.parameter()],t.prototype,"hasEmissionTexture",void 0),i([u.parameter()],t.prototype,"hasOcclusionTexture",void 0),i([u.parameter()],t.prototype,"hasNormalTexture",void 0),i([u.parameter()],t.prototype,"instanced",void 0),i([u.parameter()],t.prototype,"instancedColor",void 0),i([u.parameter()],t.prototype,"instancedDoublePrecision",void 0),i([u.parameter()],t.prototype,"vertexTangents",void 0),i([u.parameter()],t.prototype,"normalsTypeDerivate",void 0),t}(u.ShaderTechniqueConfiguration);t.DefaultMaterialTechniqueConfiguration=m}).apply(null,i))||(e.exports=r)},"Cvn+":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("SyoC"),n("0LE5"),n("W0kZ")],void 0===(r=(function(e,t,n,i,r){return function(){function e(t,n,i,r,a,o){this.id=e._idGen.gen(t&&t.id),this.geometry=t,this.material=n,this.transformation=i,this.instanceParameters=r,this.origin=a,this.shaderTransformation=o}return e.prototype.getStaticTransformation=function(){return this.transformation},e.prototype.getShaderTransformation=function(){return this.shaderTransformation?this.shaderTransformation(this.transformation):this.transformation},e.prototype.computeAttachmentOrigin=function(e){return!!(this.material.computeAttachmentOrigin?this.material.computeAttachmentOrigin(this.geometry,e):this.geometry.computeAttachmentOrigin(e))&&(i.vec3.transformMat4(e,e,this.getStaticTransformation()),!0)},e._idGen=new r.IdGen,e.pool=new n(e,!0),e}()}).apply(null,i))||(e.exports=r)},DFuO:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("fese"),n("3kdR"),n("6t3m"),n("7Aei"),n("aExC")],void 0===(r=(function(e,t,n,i,r,a,o,s){var l,c;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new s.ShaderBuilder;return t.include(r.Transform,{linearDepth:!1}),t.include(a.VertexColor,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),t.vertex.code.add(o.glsl(l||(l=n(["\n    void main(void) {\n      vpos = (model * vec4(position, 1.0)).xyz;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n    }\n  "],["\n    void main(void) {\n      vpos = (model * vec4(position, 1.0)).xyz;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n    }\n  "])))),t.include(i.Slice,e),t.fragment.uniforms.add("eColor","vec4"),t.fragment.code.add(o.glsl(c||(c=n(["\n    void main() {\n      discardBySlice(vpos);\n      ","\n      gl_FragColor = highlightSlice(gl_FragColor, vpos);\n    }\n    "],["\n    void main() {\n      discardBySlice(vpos);\n      ","\n      gl_FragColor = highlightSlice(gl_FragColor, vpos);\n    }\n    "])),e.attributeColor?"gl_FragColor = vColor * eColor;":"gl_FragColor = eColor;")),t}}).apply(null,i))||(e.exports=r)},DKwL:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.RgbaFloatEncoding=function(e){var t=i.glsl(r||(r=n(["\n    // This is the maximum float value representable as 32bit fixed point,\n    // it is rgba2float(vec4(1)) inlined.\n    const float MAX_RGBA_FLOAT =\n      255.0 / 256.0 +\n      255.0 / 256.0 / 256.0 +\n      255.0 / 256.0 / 256.0 / 256.0 +\n      255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n    // Factors to convert to fixed point, i.e. factors (256^0, 256^1, 256^2, 256^3)\n    const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n    vec4 float2rgba(const float value) {\n      // Make sure value is in the domain we can represent\n      float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n      // Decompose value in 32bit fixed point parts represented as\n      // uint8 rgba components. Decomposition uses the fractional part after multiplying\n      // by a power of 256 (this removes the bits that are represented in the previous\n      // component) and then converts the fractional part to 8bits.\n      vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n      // Convert uint8 values (from 0 to 255) to floating point representation for\n      // the shader\n      const float toU8AsFloat = 1.0 / 255.0;\n\n      return fixedPointU8 * toU8AsFloat;\n    }\n\n    // Factors to convert rgba back to float\n    const vec4 RGBA_2_FLOAT_FACTORS = vec4(\n      255.0 / (256.0),\n      255.0 / (256.0 * 256.0),\n      255.0 / (256.0 * 256.0 * 256.0),\n      255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n    );\n\n    float rgba2float(vec4 rgba) {\n      // Convert components from 0->1 back to 0->255 and then\n      // add the components together with their corresponding\n      // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n      return dot(rgba, RGBA_2_FLOAT_FACTORS);\n    }\n  "],["\n    // This is the maximum float value representable as 32bit fixed point,\n    // it is rgba2float(vec4(1)) inlined.\n    const float MAX_RGBA_FLOAT =\n      255.0 / 256.0 +\n      255.0 / 256.0 / 256.0 +\n      255.0 / 256.0 / 256.0 / 256.0 +\n      255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n    // Factors to convert to fixed point, i.e. factors (256^0, 256^1, 256^2, 256^3)\n    const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n    vec4 float2rgba(const float value) {\n      // Make sure value is in the domain we can represent\n      float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n      // Decompose value in 32bit fixed point parts represented as\n      // uint8 rgba components. Decomposition uses the fractional part after multiplying\n      // by a power of 256 (this removes the bits that are represented in the previous\n      // component) and then converts the fractional part to 8bits.\n      vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n      // Convert uint8 values (from 0 to 255) to floating point representation for\n      // the shader\n      const float toU8AsFloat = 1.0 / 255.0;\n\n      return fixedPointU8 * toU8AsFloat;\n    }\n\n    // Factors to convert rgba back to float\n    const vec4 RGBA_2_FLOAT_FACTORS = vec4(\n      255.0 / (256.0),\n      255.0 / (256.0 * 256.0),\n      255.0 / (256.0 * 256.0 * 256.0),\n      255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n    );\n\n    float rgba2float(vec4 rgba) {\n      // Convert components from 0->1 back to 0->255 and then\n      // add the components together with their corresponding\n      // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n      return dot(rgba, RGBA_2_FLOAT_FACTORS);\n    }\n  "])));e.fragment.code.add(t),e.vertex.code.add(t)}}).apply(null,i))||(e.exports=r)},"E/g4":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o,s,l,c;Object.defineProperty(t,"__esModule",{value:!0}),t.RibbonVertexPosition=function(e,t){e.vertex.uniforms.add("symbolLineWidth","float"),t.vvSize?(e.attributes.add("sizeFeatureAttribute","float"),e.vertex.uniforms.add("vvSizeMinSize","vec3"),e.vertex.uniforms.add("vvSizeMaxSize","vec3"),e.vertex.uniforms.add("vvSizeOffset","vec3"),e.vertex.uniforms.add("vvSizeFactor","vec3"),e.vertex.code.add(i.glsl(r||(r=n(["\n    float getSize() {\n      return symbolLineWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;\n    }\n    "],["\n    float getSize() {\n      return symbolLineWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;\n    }\n    "]))))):(e.attributes.add("size","float"),e.vertex.code.add(i.glsl(a||(a=n(["\n    float getSize(){\n      return symbolLineWidth * size;\n    }\n    "],["\n    float getSize(){\n      return symbolLineWidth * size;\n    }\n    "]))))),t.vvOpacity?(e.attributes.add("opacityFeatureAttribute","float"),e.vertex.defines.addInt("VV_OPACITY_N",8),e.vertex.code.add(i.glsl(o||(o=n(["\n    uniform float vvOpacityValues[VV_OPACITY_N];\n    uniform float vvOpacityOpacities[VV_OPACITY_N];\n\n    float interpolateOpacity( float value ){\n      if (value <= vvOpacityValues[0]) {\n        return vvOpacityOpacities[0];\n      }\n\n      for (int i = 1; i < VV_OPACITY_N; ++i) {\n        if (vvOpacityValues[i] >= value) {\n          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n          return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);\n        }\n      }\n\n      return vvOpacityOpacities[VV_OPACITY_N - 1];\n    }\n\n    vec4 applyOpacity( vec4 color ){\n      return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));\n    }\n    "],["\n    uniform float vvOpacityValues[VV_OPACITY_N];\n    uniform float vvOpacityOpacities[VV_OPACITY_N];\n\n    float interpolateOpacity( float value ){\n      if (value <= vvOpacityValues[0]) {\n        return vvOpacityOpacities[0];\n      }\n\n      for (int i = 1; i < VV_OPACITY_N; ++i) {\n        if (vvOpacityValues[i] >= value) {\n          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n          return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);\n        }\n      }\n\n      return vvOpacityOpacities[VV_OPACITY_N - 1];\n    }\n\n    vec4 applyOpacity( vec4 color ){\n      return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));\n    }\n    "]))))):e.vertex.code.add(i.glsl(s||(s=n(["\n    vec4 applyOpacity( vec4 color ){\n      return color;\n    }\n    "],["\n    vec4 applyOpacity( vec4 color ){\n      return color;\n    }\n    "])))),t.vvColor?(e.attributes.add("colorFeatureAttribute","float"),e.vertex.defines.addInt("VV_COLOR_N",8),e.vertex.code.add(i.glsl(l||(l=n(["\n    uniform float vvColorValues[VV_COLOR_N];\n    uniform vec4 vvColorColors[VV_COLOR_N];\n\n    vec4 interpolateColor( float value ) {\n      if (value <= vvColorValues[0]) {\n        return vvColorColors[0];\n      }\n\n      for (int i = 1; i < VV_COLOR_N; ++i) {\n        if (vvColorValues[i] >= value) {\n          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n          return mix(vvColorColors[i-1], vvColorColors[i], f);\n        }\n      }\n\n      return vvColorColors[VV_COLOR_N - 1];\n    }\n\n    vec4 getColor(){\n      return applyOpacity(interpolateColor(colorFeatureAttribute));\n    }\n    "],["\n    uniform float vvColorValues[VV_COLOR_N];\n    uniform vec4 vvColorColors[VV_COLOR_N];\n\n    vec4 interpolateColor( float value ) {\n      if (value <= vvColorValues[0]) {\n        return vvColorColors[0];\n      }\n\n      for (int i = 1; i < VV_COLOR_N; ++i) {\n        if (vvColorValues[i] >= value) {\n          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n          return mix(vvColorColors[i-1], vvColorColors[i], f);\n        }\n      }\n\n      return vvColorColors[VV_COLOR_N - 1];\n    }\n\n    vec4 getColor(){\n      return applyOpacity(interpolateColor(colorFeatureAttribute));\n    }\n    "]))))):(e.attributes.add("color","vec4"),e.vertex.code.add(i.glsl(c||(c=n(["\n    vec4 getColor(){\n      return applyOpacity(color);\n    }\n    "],["\n    vec4 getColor(){\n      return applyOpacity(color);\n    }\n    "])))))}}).apply(null,i))||(e.exports=r)},"EiD/":function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultTextureUnits={DIFFUSE:0,COMPONENT_COLOR:1,NORMAL:2,EMISSION:3,OCCLUSION:4,METALLIC_ROUGHNESS:5}}).apply(null,i))||(e.exports=r)},EiS2:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("qKT0"),n("2Atf"),n("fese"),n("3kdR"),n("W/V4"),n("FQ4r"),n("lBa0"),n("ff/U"),n("DFuO"),n("G0ER"),n("qbr3")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f){Object.defineProperty(t,"__esModule",{value:!0});var h=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return n(i,t),i.prototype.initializeProgram=function(e){var t=i.shader.get(),n=this.configuration,r=t.build({attributeColor:n.vertexColors,slicePlaneEnabled:n.slicePlaneEnabled,sliceHighlightDisabled:n.sliceHighlightDisabled});return new p(e.rctx,r.generateSource("vertex"),r.generateSource("fragment"),u.Default3D)},i.prototype.bindPass=function(e,t,n){this.program.setUniform4fv("eColor",t.color)},i.prototype.bindDraw=function(e){o.Transform.bindUniforms(this.program,e),a.Slice.bindUniformsWithOrigin(this.program,this.configuration,e)},i.prototype.bindInstance=function(e){this.program.setUniformMatrix4fv("model",e.transformation)},i.prototype.initializePipeline=function(){var e=this.configuration,t=0===e.output?e.transparent&&f.separateBlendingParams(770,1,771,771):null;return f.makePipelineState({blending:t,polygonOffset:e.polygonOffset&&{factor:1,units:1},culling:function(e){return 0!==e&&{face:1===e?1028:1029,mode:2305}}(e.cullFace),depthTest:{func:513},depthWrite:e.writeDepth&&f.defaultDepthWriteParams,colorWrite:f.defaultColorWriteParams})},i.prototype.bindPipelineState=function(e){e.setPipelineState(this.pipeline)},i.shader=new s.ReloadableShaderModule(d,"./ColorMaterial.glsl",e),i}(l.ShaderTechnique);t.ColorMaterialTechnique=h;var v=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.output=0,t.cullFace=0,t.slicePlaneEnabled=!1,t.sliceHighlightDisabled=!1,t.vertexColors=!1,t.transparent=!1,t.polygonOffset=!1,t.writeDepth=!0,t}return n(t,e),i([c.parameter({count:6})],t.prototype,"output",void 0),i([c.parameter({count:3})],t.prototype,"cullFace",void 0),i([c.parameter()],t.prototype,"slicePlaneEnabled",void 0),i([c.parameter()],t.prototype,"sliceHighlightDisabled",void 0),i([c.parameter()],t.prototype,"vertexColors",void 0),i([c.parameter()],t.prototype,"transparent",void 0),i([c.parameter()],t.prototype,"polygonOffset",void 0),i([c.parameter()],t.prototype,"writeDepth",void 0),t}(c.ShaderTechniqueConfiguration);t.ColorMaterialTechniqueConfiguration=v}).apply(null,i))||(e.exports=r)},FNtW:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("W0kZ")],void 0===(r=(function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(t){this.supportsEdges=!1,this._parentStage=null,this._visible=!0,this._renderOccluded=1,this._renderPriority=0,this.id=e._idGen.gen(t)}return e.prototype.update=function(e){return!1},Object.defineProperty(e.prototype,"parentStage",{get:function(){return this._parentStage},enumerable:!0,configurable:!0}),e.prototype.addParentStage=function(e){this._parentStage=e},e.prototype.removeParentStage=function(){this._parentStage=null},Object.defineProperty(e.prototype,"visible",{get:function(){return this._visible},set:function(e){e!==this._visible&&(this._visible=e,this.notifyDirty("matChanged"))},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"renderOccluded",{get:function(){return this._renderOccluded},set:function(e){e!==this._renderOccluded&&(this._renderOccluded=e,this.notifyDirty("matChanged"))},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"renderPriority",{get:function(){return this._renderPriority},set:function(e){e!==this._renderPriority&&(this._renderPriority=e,this.notifyDirty("matChanged"))},enumerable:!0,configurable:!0}),e.prototype.isVisibleInPass=function(e){return!0},e.prototype.isVisible=function(){return this._visible},e.prototype.notifyDirty=function(e){this.parentStage&&this.parentStage.notifyDirty(this,e)},e._idGen=new n.IdGen,e}();t.Material=i}).apply(null,i))||(e.exports=r)},FQ4r:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){this._commonUniformStore=e.commonUniformStore,this._config=function(e){var t=e.__proto__.__configurationParameters,n={};n.key=e.key;for(var i=0,r=t;i<r.length;i++){var a=r[i];n[a]=e[a]}return n}(t),this._program=this.initializeProgram(e),this._commonUniformStore.subscribeProgram(this._program),this._pipeline=this.initializePipeline(e)}return e.prototype.dispose=function(){this._program&&(this._commonUniformStore.unsubscribeProgram(this._program),this._program.dispose(),this._program=null)},e.prototype.reload=function(e){this._program&&(this._commonUniformStore.unsubscribeProgram(this._program),this._program.dispose()),this._program=this.initializeProgram(e),this._commonUniformStore.subscribeProgram(this._program)},Object.defineProperty(e.prototype,"program",{get:function(){return this._program},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"pipeline",{get:function(){return this._pipeline},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"key",{get:function(){return this._config.key},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"configuration",{get:function(){return this._config},enumerable:!0,configurable:!0}),e.prototype.bindPass=function(e,t,n){},e.prototype.bindMaterial=function(e,t){},e.prototype.bindDraw=function(e){},e}();t.ShaderTechnique=n}).apply(null,i))||(e.exports=r)},HAIt:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("Q2wQ"),n("HZ3d"),n("eIBl"),n("LxLY"),n("8MXS"),n("5T2R"),n("1eTA"),n("sGGe"),n("bF8Q")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p){Object.defineProperty(t,"__esModule",{value:!0});var f=function(){function e(e){this._handles=new o,this.zManipulator=null,this.tool=e.tool}return e.prototype.destroy=function(){this._clear()},e.prototype._clear=function(){this._handles.removeAll(),s.isSome(this.zManipulator)&&this.tool.manipulators.remove(this.zManipulator),this.zManipulator=null},Object.defineProperty(e.prototype,"dragging",{get:function(){return s.isSome(this.zManipulator)&&this.zManipulator.dragging},enumerable:!0,configurable:!0}),e.prototype.recreateManipulators=function(){var e=this;if(this._clear(),this.zManipulator=u.createGraphicMoveZManipulator({view:this.tool.view,graphic:this.tool.graphic,worldOriented:!1}),s.isSome(this.zManipulator)){this.tool.manipulators.add(this.zManipulator);var t=this.createDragEventMappingFunction(),n=d.createGraphicDragAction(this.tool.graphic),i=p.createManipulatorDragHandler(this.zManipulator,t,n);this._handles.add(i),this._handles.add([l.init(this.tool.graphic,"geometry",(function(){s.isSome(e.zManipulator)&&c.placeManipulatorAtGraphic(e.zManipulator,e.tool.graphic)})),this.zManipulator.events.on("immediate-click",(function(e){e.stopPropagation()})),l.init(this.tool.graphic,["visible","layer.visible"],(function(){s.isSome(e.zManipulator)&&(e.zManipulator.visible=e.tool.graphic.visible&&e.tool.graphic.layer.visible)}))])}},e.prototype.updateManipulators=function(e){s.isSome(this.zManipulator)&&(this.zManipulator.modelTransform=e)},e.prototype.createDragEventMappingFunction=function(){var e=this;return function(t){var n=u.createGraphicMoveZScreenDragToMap(e.tool.view,t);return s.isNone(n)?null:function(t){var i=n(t);if(s.isNone(i))return null;switch(t.action){case"start":e.tool.emit("graphic-translate-start",{graphic:e.tool.graphic});break;case"update":e.tool.emit("graphic-translate",{graphic:e.tool.graphic,dx:i.deltaX,dy:i.deltaY,dz:i.deltaZ});break;case"end":e.tool.emit("graphic-translate-stop",{graphic:e.tool.graphic})}return i}}},e}();t.GraphicZTransform=f}).apply(null,i))||(e.exports=r)},HkM8:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o,s;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateAmbientLighting=function(e,t){var l=e.fragment,c=void 0!==t.lightingSphericalHarmonicsOrder?t.lightingSphericalHarmonicsOrder:2;0===c?(l.uniforms.add("lightingAmbientSH0","vec3"),l.code.add(i.glsl(r||(r=n(["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 => full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 => full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "]))))):1===c?(l.uniforms.add("lightingAmbientSH_R","vec4"),l.uniforms.add("lightingAmbientSH_G","vec4"),l.uniforms.add("lightingAmbientSH_B","vec4"),l.code.add(i.glsl(a||(a=n(["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec4 sh0 = vec4(\n          0.282095,\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y\n        );\n        vec3 ambientLight = vec3(\n          dot(lightingAmbientSH_R, sh0),\n          dot(lightingAmbientSH_G, sh0),\n          dot(lightingAmbientSH_B, sh0)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec4 sh0 = vec4(\n          0.282095,\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y\n        );\n        vec3 ambientLight = vec3(\n          dot(lightingAmbientSH_R, sh0),\n          dot(lightingAmbientSH_G, sh0),\n          dot(lightingAmbientSH_B, sh0)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "]))))):2===c&&(l.uniforms.add("lightingAmbientSH0","vec3"),l.uniforms.add("lightingAmbientSH_R1","vec4"),l.uniforms.add("lightingAmbientSH_G1","vec4"),l.uniforms.add("lightingAmbientSH_B1","vec4"),l.uniforms.add("lightingAmbientSH_R2","vec4"),l.uniforms.add("lightingAmbientSH_G2","vec4"),l.uniforms.add("lightingAmbientSH_B2","vec4"),l.code.add(i.glsl(o||(o=n(["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 => full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n\n        vec4 sh1 = vec4(\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y,\n          1.092548 * normal.x * normal.y\n        );\n        vec4 sh2 = vec4(\n          1.092548 * normal.y * normal.z,\n          0.315392 * (3.0 * normal.z * normal.z - 1.0),\n          1.092548 * normal.x * normal.z,\n          0.546274 * (normal.x * normal.x - normal.y * normal.y)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R1, sh1),\n          dot(lightingAmbientSH_G1, sh1),\n          dot(lightingAmbientSH_B1, sh1)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R2, sh2),\n          dot(lightingAmbientSH_G2, sh2),\n          dot(lightingAmbientSH_B2, sh2)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 => full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n\n        vec4 sh1 = vec4(\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y,\n          1.092548 * normal.x * normal.y\n        );\n        vec4 sh2 = vec4(\n          1.092548 * normal.y * normal.z,\n          0.315392 * (3.0 * normal.z * normal.z - 1.0),\n          1.092548 * normal.x * normal.z,\n          0.546274 * (normal.x * normal.x - normal.y * normal.y)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R1, sh1),\n          dot(lightingAmbientSH_G1, sh1),\n          dot(lightingAmbientSH_B1, sh1)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R2, sh2),\n          dot(lightingAmbientSH_G2, sh2),\n          dot(lightingAmbientSH_B2, sh2)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "])))),t.usePBR&&l.code.add(i.glsl(s||(s=n(["\n        // calculateAmbientRadiance is used calculate specular radiance of the sky\n        // - in the night calculateAmbientRadiance gives darker color compared to calculateAmbientComponent which integrates contributions of the moon\n        // - calculateAmbientRadiance gives more predictable color compared to calculateAmbientIrradiance that depends on normal\n        // - in future more physically accurate model should be established\n        vec3 calculateAmbientRadiance(float ssao)\n        {\n          // evaluate the sh ambient light\n          vec3 ambientLight ;\n          ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2; // returning the darker value in the night\n\n          return ambientLight *= (1.0 - ssao) * skyTransmittance; // skyTransmittance is slightly bluish giving more natural look\n        }\n      "],["\n        // calculateAmbientRadiance is used calculate specular radiance of the sky\n        // - in the night calculateAmbientRadiance gives darker color compared to calculateAmbientComponent which integrates contributions of the moon\n        // - calculateAmbientRadiance gives more predictable color compared to calculateAmbientIrradiance that depends on normal\n        // - in future more physically accurate model should be established\n        vec3 calculateAmbientRadiance(float ssao)\n        {\n          // evaluate the sh ambient light\n          vec3 ambientLight ;\n          ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2; // returning the darker value in the night\n\n          return ambientLight *= (1.0 - ssao) * skyTransmittance; // skyTransmittance is slightly bluish giving more natural look\n        }\n      "])))))}}).apply(null,i))||(e.exports=r)},ILj8:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("VfPl"),n("CIy2")],void 0===(r=(function(e,t,n,i){function r(e,t,n,i,r){var a=n.typedBuffer,o=n.typedBufferStride,s=e.length;if(i*=o,null==r||1===r)for(var l=0;l<s;++l)a[i]=t[c=2*e[l]],a[i+1]=t[c+1],i+=o;else for(l=0;l<s;++l)for(var c=2*e[l],u=0;u<r;++u)a[i]=t[c],a[i+1]=t[c+1],i+=o}function a(e,t,n,i,r){var a=n.typedBuffer,o=n.typedBufferStride,s=e.length;if(i*=o,null==r||1===r)for(var l=0;l<s;++l)a[i]=t[c=3*e[l]],a[i+1]=t[c+1],a[i+2]=t[c+2],i+=o;else for(l=0;l<s;++l)for(var c=3*e[l],u=0;u<r;++u)a[i]=t[c],a[i+1]=t[c+1],a[i+2]=t[c+2],i+=o}function o(e,t,n,i,r){var a=n.typedBuffer,o=n.typedBufferStride,s=e.length;if(i*=o,null==r||1===r)for(var l=0;l<s;++l)a[i]=t[c=4*e[l]],a[i+1]=t[c+1],a[i+2]=t[c+2],a[i+3]=t[c+3],i+=o;else for(l=0;l<s;++l)for(var c=4*e[l],u=0;u<r;++u)a[i]=t[c],a[i+1]=t[c+1],a[i+2]=t[c+2],a[i+3]=t[c+3],i+=o}function s(e,t,n,i,r,o){if(n){var s=n,l=i.typedBuffer,c=i.typedBufferStride,u=e.length;if(r*=c,null==o||1===o)for(var d=0;d<u;++d)l[r]=s[0]*(f=t[p=3*e[d]])+s[4]*(h=t[p+1])+s[8]*(v=t[p+2])+s[12],l[r+1]=s[1]*f+s[5]*h+s[9]*v+s[13],l[r+2]=s[2]*f+s[6]*h+s[10]*v+s[14],r+=c;else for(d=0;d<u;++d)for(var p,f,h,v,m=s[0]*(f=t[p=3*e[d]])+s[4]*(h=t[p+1])+s[8]*(v=t[p+2])+s[12],g=s[1]*f+s[5]*h+s[9]*v+s[13],y=s[2]*f+s[6]*h+s[10]*v+s[14],b=0;b<o;++b)l[r]=m,l[r+1]=g,l[r+2]=y,r+=c}else a(e,t,i,r,o)}function l(e,t,n,i,r,o){if(n){var s=n,l=i.typedBuffer,c=i.typedBufferStride,u=e.length;if(r*=c,null==o||1===o)for(var d=0;d<u;++d)l[r]=s[0]*(f=t[p=3*e[d]])+s[4]*(h=t[p+1])+s[8]*(v=t[p+2]),l[r+1]=s[1]*f+s[5]*h+s[9]*v,l[r+2]=s[2]*f+s[6]*h+s[10]*v,r+=c;else for(d=0;d<u;++d)for(var p,f,h,v,m=s[0]*(f=t[p=3*e[d]])+s[4]*(h=t[p+1])+s[8]*(v=t[p+2]),g=s[1]*f+s[5]*h+s[9]*v,y=s[2]*f+s[6]*h+s[10]*v,b=0;b<o;++b)l[r]=m,l[r+1]=g,l[r+2]=y,r+=c}else a(e,t,i,r,o)}function c(e,t,n,i,r,a){var o=i.typedBuffer,s=i.typedBufferStride,l=e.length;if(r*=s,null==a||1===a){if(4===n)for(var c=0;c<l;++c)o[r]=t[u=4*e[c]],o[r+1]=t[u+1],o[r+2]=t[u+2],o[r+3]=t[u+3],r+=s;else if(3===n)for(c=0;c<l;++c)o[r]=t[u=3*e[c]],o[r+1]=t[u+1],o[r+2]=t[u+2],o[r+3]=255,r+=s}else if(4===n)for(c=0;c<l;++c)for(var u=4*e[c],d=0;d<a;++d)o[r]=t[u],o[r+1]=t[u+1],o[r+2]=t[u+2],o[r+3]=t[u+3],r+=s;else if(3===n)for(c=0;c<l;++c)for(u=3*e[c],d=0;d<a;++d)o[r]=t[u],o[r+1]=t[u+1],o[r+2]=t[u+2],o[r+3]=255,r+=s}Object.defineProperty(t,"__esModule",{value:!0}),t.writeBufferVec2=r,t.writeBufferVec3=a,t.writeBufferVec4=o,t.writeBufferMat3f=function(e,t,n,i){var r=n.typedBuffer,a=n.typedBufferStride,o=e.length;i*=a;for(var s=0;s<o;++s){for(var l=9*e[s],c=0;c<9;++c)r[i+c]=t[l+c];i+=a}},t.writeBufferMat4f=function(e,t,n,i){var r=n.typedBuffer,a=n.typedBufferStride,o=e.length;i*=a;for(var s=0;s<o;++s){for(var l=16*e[s],c=0;c<16;++c)r[i+c]=t[l+c];i+=a}},t.writePosition=s,t.writeNormal=l,t.writeColor=c,t.writeMultipliedColor=function(e,t,n,i,r,a,o){var s=r.typedBuffer,l=r.typedBufferStride,c=e.length;if(a*=l,null==o||1===o){if(4===n)for(var u=0;u<c;++u)s[a]=t[p=4*e[u]]*i[0],s[a+1]=t[p+1]*i[1],s[a+2]=t[p+2]*i[2],s[a+3]=t[p+3]*i[3],a+=l;else if(3===n){var d=255*i[3];for(u=0;u<c;++u)s[a]=t[p=3*e[u]]*i[0],s[a+1]=t[p+1]*i[1],s[a+2]=t[p+2]*i[2],s[a+3]=d,a+=l}}else if(4===n)for(u=0;u<c;++u)for(var p=4*e[u],f=0;f<o;++f)s[a]=t[p]*i[0],s[a+1]=t[p+1]*i[1],s[a+2]=t[p+2]*i[2],s[a+3]=t[p+3]*i[3],a+=l;else if(3===n)for(d=255*i[3],u=0;u<c;++u)for(p=3*e[u],f=0;f<o;++f)s[a]=t[p]*i[0],s[a+1]=t[p+1]*i[1],s[a+2]=t[p+2]*i[2],s[a+3]=d,a+=l},t.writeDefaultAttributes=function(e,t,a,u,d,p){for(var f=0,h=t.fieldNames;f<h.length;f++){var v=h[f],m=e.vertexAttr[v],g=e.indices[v];if(m&&g)switch(v){case i.VertexAttrConstants.POSITION:i.assert(3===m.size);var y=d.getField(v,n.BufferViewVec3f);y&&s(g,m.data,a,y,p);break;case i.VertexAttrConstants.NORMAL:i.assert(3===m.size);var b=d.getField(v,n.BufferViewVec3f);b&&l(g,m.data,u,b,p);break;case i.VertexAttrConstants.UV0:i.assert(2===m.size);var x=d.getField(v,n.BufferViewVec2f);x&&r(g,m.data,x,p);break;case i.VertexAttrConstants.REGION:i.assert(4===m.size);var _=d.getField(v,n.BufferViewVec4u16);_&&o(g,m.data,_,p);break;case i.VertexAttrConstants.COLOR:i.assert(3===m.size||4===m.size);var S=d.getField(v,n.BufferViewVec4u8);S&&c(g,m.data,m.size,S,p);break;case i.VertexAttrConstants.SYMBOLCOLOR:i.assert(3===m.size||4===m.size);var P=d.getField(v,n.BufferViewVec4u8);P&&c(g,m.data,m.size,P,p);break;case i.VertexAttrConstants.TANGENT:i.assert(4===m.size);var w=d.getField(v,n.BufferViewVec4f);w&&o(g,m.data,w,p)}}}}).apply(null,i))||(e.exports=r)},JvNb:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("rCq5"),n("7Aei")],void 0===(r=(function(e,t,n,i,r){var a;Object.defineProperty(t,"__esModule",{value:!0}),t.MixExternalColor=function(e,t){e.include(i.ColorConversion,t);var o=r.glsl(a||(a=n(["\n    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      vec3 internalMixed = internalColor * textureColor;\n      vec3 allMixed = internalMixed * externalColor;\n\n      if (mode == ",") {\n        return allMixed;\n      }\n      else if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalColor;\n      }\n      else {\n        // tint (or something invalid)\n        float vIn = rgb2v(internalMixed);\n        vec3 hsvTint = rgb2hsv(externalColor);\n        vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);\n        return hsv2rgb(hsvOut);\n      }\n    }\n\n    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      float internalMixed = internalOpacity * textureOpacity;\n      float allMixed = internalMixed * externalOpacity;\n\n      if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalOpacity;\n      }\n      else {\n        // multiply or tint (or something invalid)\n        return allMixed;\n      }\n    }\n  "],["\n    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      vec3 internalMixed = internalColor * textureColor;\n      vec3 allMixed = internalMixed * externalColor;\n\n      if (mode == ",") {\n        return allMixed;\n      }\n      else if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalColor;\n      }\n      else {\n        // tint (or something invalid)\n        float vIn = rgb2v(internalMixed);\n        vec3 hsvTint = rgb2hsv(externalColor);\n        vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);\n        return hsv2rgb(hsvOut);\n      }\n    }\n\n    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      float internalMixed = internalOpacity * textureOpacity;\n      float allMixed = internalMixed * externalOpacity;\n\n      if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalOpacity;\n      }\n      else {\n        // multiply or tint (or something invalid)\n        return allMixed;\n      }\n    }\n  "])),r.glsl.int(1),r.glsl.int(2),r.glsl.int(3),r.glsl.int(2),r.glsl.int(3));switch(t.stages){case 0:e.vertex.code.add(o);break;case 1:e.fragment.code.add(o);break;default:e.vertex.code.add(o),e.fragment.code.add(o)}}}).apply(null,i))||(e.exports=r)},KRuQ:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("9opi"),n("qKT0"),n("Vx27")],void 0===(r=(function(e,t,n,i,r){Object.defineProperty(t,"__esModule",{value:!0}),t.AutoDisposableMixin=function(e){return function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t._isDisposed=!1,t}return n(t,e),t.prototype.dispose=function(){for(var e=this.__proto__.__managedDisposables__||[],t=e.length-1;t>=0;t--){var n=e[t];this[n]&&"function"==typeof this[n].dispose&&this[n].dispose(),this[n]=null}this._isDisposed=!0},Object.defineProperty(t.prototype,"isDisposed",{get:function(){return this._isDisposed},enumerable:!0,configurable:!0}),i([r.subclass("esri.views.3d.webgl-engine.lib.AutoDisposableMixin")],t)}(r.declared(e))};var a=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return n(t,e),i([r.subclass("esri.views.3d.webgl-engine.lib.AutoDisposable")],t)}(r.declared(t.AutoDisposableMixin((function(){}))));t.AutoDisposable=a,t.autoDispose=function(){return function(e,t){e.__managedDisposables__=e.__managedDisposables__||[],e.__managedDisposables__.push(t)}}}).apply(null,i))||(e.exports=r)},KT2k:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateMainLighting=function(e){var t=e.fragment;t.uniforms.add("lightingMainDirection","vec3"),t.uniforms.add("lightingMainIntensity","vec3"),t.uniforms.add("lightingFixedFactor","float"),t.code.add(i.glsl(r||(r=n(["\n    vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {\n      float dotVal = clamp(-dot(normal_global, lightingMainDirection), 0.0, 1.0);\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      return lightingMainIntensity * ((1.0 - shadowing) * dotVal);\n    }\n  "],["\n    vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {\n      float dotVal = clamp(-dot(normal_global, lightingMainDirection), 0.0, 1.0);\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      return lightingMainIntensity * ((1.0 - shadowing) * dotVal);\n    }\n  "]))))}}).apply(null,i))||(e.exports=r)},LZD4:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("2B1V"),n("CIy2"),n("ILj8")],void 0===(r=(function(e,t,n,i,r){Object.defineProperty(t,"__esModule",{value:!0}),t.PositionLayout=n.newLayout().vec3f(i.VertexAttrConstants.POSITION),t.PositionUVLayout=n.newLayout().vec3f(i.VertexAttrConstants.POSITION).vec2f(i.VertexAttrConstants.UV0),t.PositionColorLayout=n.newLayout().vec3f(i.VertexAttrConstants.POSITION).vec4u8(i.VertexAttrConstants.COLOR);var a=function(){function e(e){this.vertexBufferLayout=e}return e.prototype.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},e.prototype.elementCount=function(e){return e.indices[i.VertexAttrConstants.POSITION].length},e.prototype.write=function(e,t,n,i){r.writeDefaultAttributes(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,n,i)},e}();t.DefaultBufferWriter=a}).apply(null,i))||(e.exports=r)},N78w:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("2Atf"),n("Gtr7"),n("BcWh"),n("qsST"),n("LxLY"),n("jBNx"),n("Vx27"),n("W9tT"),n("0LE5"),n("Rdxj"),n("vtMp"),n("DtIM"),n("dXKx"),n("5ldw"),n("NbdF")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y){Object.defineProperty(t,"__esModule",{value:!0});var b=s.getLogger("esri.views.interactive.GraphicManipulator"),x=function(e){function t(t){var n=e.call(this,t)||this;return n.layer=null,n.interactive=!0,n.selectable=!1,n.dragging=!1,n.cursor=null,n.events=new o({target:n}),n._circleCollisionCache=null,n._originalSymbol=null,n}return i(t,e),Object.defineProperty(t.prototype,"graphic",{set:function(e){"mesh"!==l.get(e.geometry,"type")?(this._circleCollisionCache=null,this._originalSymbol=e.symbol,this._set("graphic",e)):b.error("Mesh geometries are not supported")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"elevationInfo",{get:function(){var e="elevationInfo"in this.graphic.layer&&this.graphic.layer.elevationInfo,t=v.getGraphicEffectiveElevationMode(this.graphic);return new g({mode:t,offset:e?e.offset:0})},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"focusedSymbol",{set:function(e){e!==this._get("focusedSymbol")&&(this._set("focusedSymbol",e),this._updateGraphicSymbol(),this._circleCollisionCache=null)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"grabbing",{set:function(e){if(e!==this._get("grabbing")){var t=this._focused;this._set("grabbing",e),this._updateGraphicSymbol(t)}},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"hovering",{set:function(e){if(e!==this._get("hovering")){var t=this._focused;this._set("hovering",e),this._updateGraphicSymbol(t)}},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"selected",{set:function(e){e!==this._get("selected")&&(this._set("selected",e),this._updateGraphicSymbol())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_focused",{get:function(){return this._get("hovering")||this._get("grabbing")},enumerable:!0,configurable:!0}),t.prototype.destroy=function(){this._resetGraphicSymbol(),this._set("view",null)},t.prototype.intersectionDistance=function(e){var t=this._get("graphic");if(!1===t.visible)return null;var n=this._get("focusedSymbol"),i=l.isSome(n)?n:t.symbol,r=t.geometry;if(l.isNone(r))return null;var a=this._get("view");return"2d"===a.type?this._intersectDistance2D(e,a,r,i):this._intersectDistance3D(e,a,t)},t.prototype.attach=function(){l.isNone(this.layer)||this.layer.add(this.graphic)},t.prototype.detach=function(){this._resetGraphicSymbol(),l.isNone(this.layer)||this.layer.remove(this.graphic)},t.prototype._updateGraphicSymbol=function(e){if(void 0===e&&(e=this._focused),e!==this._focused){var t=this.graphic.symbol;t!==this._originalSymbol&&t!==this.focusedSymbol&&(this._originalSymbol=t)}this.graphic.symbol=this._focused&&l.isSome(this.focusedSymbol)?this.focusedSymbol:this._originalSymbol},t.prototype._resetGraphicSymbol=function(){this.graphic.symbol=this._originalSymbol},t.prototype._intersectDistance2D=function(e,t,n,i){if(i=i||m.getDefaultSymbol2D(n),l.isNone(i))return null;var r=this._circleCollisionCache;if("point"!==n.type||"simple-marker"!==i.type){var a=y.intersectsDrapedGeometry(e,n,t);return l.isSome(a)?1:null}if(l.isNone(r)||!r.originalPoint.equals(n)){var o=n,s=t.spatialReference;h.canProject(o,s)&&(a=h.project(o,s),r={originalPoint:o.clone(),mapPoint:a,radiusPx:c.pt2px(i.size)},this._circleCollisionCache=r)}if(l.isSome(r)){var u=c.screenPointObjectToArray(e,S),p=t.state.toScreen(P,r.mapPoint.x,r.mapPoint.y),f=r.radiusPx;return d.vec2.squaredDistance(u,p)<f*f?1:null}return null},t.prototype._intersectDistance3D=function(e,t,n){var i=t.toMap(e,{include:[n]});if(!i)return null;var r=_;return t.renderCoordsHelper.toRenderCoords(i,r)?p.vec3.distance(r,t.state.camera.eye):null},n([u.property({constructOnly:!0,nonNullable:!0})],t.prototype,"graphic",null),n([u.property({readOnly:!0,dependsOn:["graphic"]})],t.prototype,"elevationInfo",null),n([u.property({constructOnly:!0,nonNullable:!0})],t.prototype,"view",void 0),n([u.property({value:null})],t.prototype,"focusedSymbol",null),n([u.property({constructOnly:!0})],t.prototype,"layer",void 0),n([u.property()],t.prototype,"interactive",void 0),n([u.property()],t.prototype,"selectable",void 0),n([u.property({value:!1})],t.prototype,"grabbing",null),n([u.property()],t.prototype,"dragging",void 0),n([u.property()],t.prototype,"hovering",null),n([u.property({value:!1})],t.prototype,"selected",null),n([u.property()],t.prototype,"cursor",void 0),n([u.subclass("esri.views.interactive.GraphicManipulator")],t)}(u.declared(a));t.GraphicManipulator=x;var _=f.vec3f64.create(),S=c.createScreenPointArray(),P=c.createScreenPointArray()}).apply(null,i))||(e.exports=r)},NbdF:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("TMur"),n("LxLY"),n("8uEs"),n("/E+R")],void 0===(r=(function(e,t,n,i,r,a){function o(e,t,i,a){var o;if(void 0===a&&(a=new n.Extent),"2d"===i.type)o=t*i.resolution;else if("3d"===i.type){var s=i.basemapTerrain,l=s.overlayManager,c=l?l.overlayPixelSizeInMapUnits(e):1;o=s&&!s.spatialReference.equals(i.spatialReference)?r.getMetersPerUnitForSR(s.spatialReference)/r.getMetersPerUnitForSR(i.spatialReference):t*c}var u=e.x-o,d=e.y-o,p=e.x+o,f=e.y+o,h=i.spatialReference;return a.xmin=Math.min(u,p),a.ymin=Math.min(d,f),a.xmax=Math.max(u,p),a.ymax=Math.max(d,f),a.spatialReference=h,a}Object.defineProperty(t,"__esModule",{value:!0}),t.createQueryGeometry=o,t.intersectsDrapedGeometry=function(e,t,n){var r=n.toMap(e);return i.isNone(r)?null:o(r,a.calculateTolerance(),n,s).intersects(t)?r:null};var s=new n.Extent}).apply(null,i))||(e.exports=r)},PaEL:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){function r(e){e.fragment.uniforms.add("depthTex","sampler2D"),e.fragment.uniforms.add("highlightViewportPixelSz","vec4"),e.fragment.code.add(i.glsl(a||(a=n(["\n    void outputHighlight() {\n      vec4 fragCoord = gl_FragCoord;\n\n      float sceneDepth = texture2D(depthTex, (fragCoord.xy - highlightViewportPixelSz.xy) * highlightViewportPixelSz.zw).r;\n      if (fragCoord.z > sceneDepth + 5e-6) {\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n      }\n      else {\n        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n      }\n    }\n  "],["\n    void outputHighlight() {\n      vec4 fragCoord = gl_FragCoord;\n\n      float sceneDepth = texture2D(depthTex, (fragCoord.xy - highlightViewportPixelSz.xy) * highlightViewportPixelSz.zw).r;\n      if (fragCoord.z > sceneDepth + 5e-6) {\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n      }\n      else {\n        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n      }\n    }\n  "]))))}var a;Object.defineProperty(t,"__esModule",{value:!0}),t.OutputHighlight=r,function(e){e.bindOutputHighlight=function(e,t,n){e.bindTexture(n.highlightDepthTexture,5),t.setUniform1i("depthTex",5),t.setUniform4f("highlightViewportPixelSz",0,0,1/n.viewport[2],1/n.viewport[3])}}(r=t.OutputHighlight||(t.OutputHighlight={}))}).apply(null,i))||(e.exports=r)},"PwS/":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("FXVB"),n("1m5D"),n("rjU6"),n("CIy2"),n("Kfys")],void 0===(r=(function(e,t,n,i,r,a,o){Object.defineProperty(t,"__esModule",{value:!0}),t.generateRenderGeometryVisibleIndexRanges=function(e){return e.instanceParameters.hidden?[]:r.generateVisibleIndexRanges(e.instanceParameters.componentVisibilities,e.componentOffsets)},t.generateRenderGeometryHighlightRanges=function(e){return e.instanceParameters.hidden?null:r.generateHighlightedIndexRanges(e.instanceParameters.componentVisibilities,e.instanceParameters.componentHighlights,e.componentOffsets)},t.doesRenderGeometryHaveHighlights=function(e){return!e.instanceParameters.hidden&&r.hasHighlights(e.instanceParameters.componentVisibilities,e.instanceParameters.componentHighlights,e.componentOffsets)},t.isRenderGeometryHidden=function(e){return!!e.instanceParameters.hidden||r.isAllHidden(e.instanceParameters.componentVisibilities,e.componentOffsets)},t.drawArrays=function(e,t,n,i,r){e.drawArrays(t,n,i),r&&(r.drawCalls++,4===t&&(r.triangles+=i))},t.drawElements=function(e,t,n,i,r,a){var s=o.getBytesPerElement(n);e.drawElements(t,r,n,i*s),a&&(a.drawCalls++,4===t&&(a.triangles+=r))},t.drawArraysFaceRange=function(e,t,n,i,r){for(var a=0,o=0,s=t;o<s.length;o++){var l=s[o],c=l[1]-l[0]+1;a+=c,e.drawArrays(i,l[0]+n,c)}r&&(r.drawCalls+=t.length,4===i&&(r.triangles=a/3))},t.drawElementsFaceRange=function(e,t,n,i,r,a){for(var s=o.getBytesPerElement(r),l=0,c=0,u=t;c<u.length;c++){var d=u[c],p=d[1]-d[0]+1;l+=p,e.drawElements(i,p,r,(d[0]+n)*s)}a&&(a.drawCalls+=t.length,4===i&&(a.triangles+=l/3))},t.acquireMaterials=function(e,t){var n=new Map;return n.set(0,t.acquire(e,"color")),n.set(3,t.acquire(e,"depthShadowMap")),n.set(2,t.acquire(e,"normal")),n.set(1,t.acquire(e,"depth")),n.set(4,t.acquire(e,"highlight")),n},t.releaseMaterials=function(e,t){t.release(e.id,"color"),t.release(e.id,"depthShadowMap"),t.release(e.id,"normal"),t.release(e.id,"depth"),t.release(e.id,"highlight")},t.calculateTransformRelToOrigin=function(e,t,i){var r=e.origin.vec3;a.setMatrixTranslation3(s,-r[0],-r[1],-r[2]),n.mat4.multiply(t,s,e.transformation),i&&(n.mat4.invert(i,t),n.mat4.transpose(i,i))};var s=i.mat4f64.create()}).apply(null,i))||(e.exports=r)},RC9r:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("2Atf"),n("qsST"),n("xoE+"),n("LxLY"),n("jBNx"),n("W9tT"),n("0LE5"),n("Rdxj"),n("aWgr"),n("2B1V"),n("rjU6"),n("+nCE"),n("tUyH"),n("FNtW"),n("CIy2"),n("ama6"),n("s6rJ"),n("ZeO9"),n("SNs2"),n("SNs2")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_,S){function P(e,t,n,i,r){for(var a=0;a<r;a++)n[i++]=e[t++];return i}var w=r.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial"),A=function(e){function t(t,n){var i=e.call(this,n)||this;return i.techniqueConfig=new S.RibbonLineTechniqueConfiguration,i.params=b.copyParameters(t,D),i.validateParams(),i.params.transparent=i.params.color[3]<1||i.params.transparent,i.layout=i.createLayout(),i}return n(t,e),t.prototype.dispose=function(){},t.prototype.setParameterValues=function(e){for(var t in e)if("cap"!==t){if("join"===t&&"round"===this.params[t]!=("round"===e[t])){w.error("join cannot be changed after creation");continue}if("stipplePattern"===t&&!!this.params[t]!=!!e[t]){w.error("stippledness cannot be changed after creation");continue}this.params[t]=e[t]}else w.error("cap cannot be changed after creation");this.validateParams(),this.notifyDirty("matChanged")},t.prototype.getParameters=function(){return this.params},t.prototype.getPassParameters=function(){return this.params},t.prototype.getTechniqueConfig=function(e){this.techniqueConfig.output=e;var t=o.isSome(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=t,this.techniqueConfig.stippleIntegerRepeatsEnabled=t&&this.params.stippleIntegerRepeats,this.techniqueConfig.stippleOffColorEnabled=t&&o.isSome(this.params.stippleOffColor),this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.roundJoins="round"===this.params.join,this.techniqueConfig.roundCaps="round"===this.params.cap,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.vvOpacity=this.params.vvOpacityEnabled,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig},t.prototype.intersect=function(e,t,n,i,r,a,o,s,l){l?b.intersectDrapedRenderLineGeometry(e,i,a,this.params.width,o):this.intersectLineGeometry(e,t,n,i,this.params.width,o)},t.prototype.intersectLineGeometry=function(e,t,n,i,r,o){if(i.options.selectionMode&&!f.isAllHidden(t.componentVisibilities,e.componentOffsets)){if(!g.isTranslationMatrix(n))return void w.error("intersection assumes a translation-only matrix");var s=e.data.getVertexAttr(),u=s[S.RibbonVertexAttributeConstants.POSITION].data,p=r;this.params.vvSizeEnabled?p*=a.clamp(this.params.vvSizeOffset[0]+s[S.RibbonVertexAttributeConstants.SIZEFEATUREATTRIBUTE].data[0]*this.params.vvSizeFactor[0],this.params.vvSizeMinSize[0],this.params.vvSizeMaxSize[0]):s[S.RibbonVertexAttributeConstants.SIZE]&&(p*=s[S.RibbonVertexAttributeConstants.SIZE].data[0]);var h=i.camera,v=V;l.vec2.copy(v,i.point);var m=p*h.pixelRatio/2+4*h.pixelRatio;c.vec3.set(Z[0],v[0]-m,v[1]+m,0),c.vec3.set(Z[1],v[0]+m,v[1]+m,0),c.vec3.set(Z[2],v[0]+m,v[1]-m,0),c.vec3.set(Z[3],v[0]-m,v[1]-m,0);for(var y=0;y<4;y++)h.unprojectPoint(Z[y],X[y]);d.plane.fromPoints(h.eye,X[0],X[1],Y),d.plane.fromPoints(h.eye,X[1],X[2],J),d.plane.fromPoints(h.eye,X[2],X[3],K),d.plane.fromPoints(h.eye,X[3],X[0],Q);var b=Number.MAX_VALUE,x=this.params.isClosed?u.length-2:u.length-5;for(y=0;y<x;y+=3){z[0]=u[y]+n[12],z[1]=u[y+1]+n[13],z[2]=u[y+2]+n[14];var _=(y+3)%u.length;if(L[0]=u[_]+n[12],L[1]=u[_+1]+n[13],L[2]=u[_+2]+n[14],!(d.plane.signedDistance(Y,z)<0&&d.plane.signedDistance(Y,L)<0||d.plane.signedDistance(J,z)<0&&d.plane.signedDistance(J,L)<0||d.plane.signedDistance(K,z)<0&&d.plane.signedDistance(K,L)<0||d.plane.signedDistance(Q,z)<0&&d.plane.signedDistance(Q,L)<0)){if(h.projectPoint(z,N),h.projectPoint(L,F),N[2]<0&&F[2]>0){c.vec3.subtract(E,z,L);var P=-d.plane.signedDistance((A=h.frustum).planes[4],z)/c.vec3.dot(E,A.planes[4]);c.vec3.scale(E,E,P),c.vec3.add(z,z,E),h.projectPoint(z,N)}else if(N[2]>0&&F[2]<0){var A;c.vec3.subtract(E,L,z),P=-d.plane.signedDistance((A=h.frustum).planes[4],L)/c.vec3.dot(E,A.planes[4]),c.vec3.scale(E,E,P),c.vec3.add(L,L,E),h.projectPoint(L,F)}else if(N[2]<0&&F[2]<0)continue;N[2]=0,F[2]=0;var C=d.lineSegment.distance2(d.lineSegment.fromPoints(N,F,H),v);C<b&&(b=C,c.vec3.copy(G,z),c.vec3.copy(B,L))}}var O=i.rayBeginPoint,M=i.rayEndPoint;if(b<m*m){var D=Number.MAX_VALUE;if(d.lineSegment.closestLineSegmentPoint(d.lineSegment.fromPoints(G,B,H),d.lineSegment.fromPoints(O,M,U),j)){c.vec3.subtract(j,j,O);var R=c.vec3.length(j);c.vec3.scale(j,j,1/R),D=R/c.vec3.distance(O,M)}o(D,j)}}},t.prototype.computeAttachmentOrigin=function(e,t){var n=e.data,i="getVertexAttr"in n?n.getVertexAttr():"vertexAttr"in n?n.vertexAttr:null;return i?h.computeAttachmentOriginLines(i[S.RibbonVertexAttributeConstants.POSITION],null,t):null},t.prototype.createLayout=function(){var e=p.newLayout().vec3f(S.RibbonVertexAttributeConstants.POSITION).f32(S.RibbonVertexAttributeConstants.SUBDIVISIONFACTOR).vec2f(S.RibbonVertexAttributeConstants.UV0).vec3f(S.RibbonVertexAttributeConstants.AUXPOS1).vec3f(S.RibbonVertexAttributeConstants.AUXPOS2);return e.f32(this.params.vvSizeEnabled?S.RibbonVertexAttributeConstants.SIZEFEATUREATTRIBUTE:S.RibbonVertexAttributeConstants.SIZE),this.params.vvColorEnabled?e.f32(S.RibbonVertexAttributeConstants.COLORFEATUREATTRIBUTE):e.vec4f(S.RibbonVertexAttributeConstants.COLOR),this.params.vvOpacityEnabled&&e.f32(S.RibbonVertexAttributeConstants.OPACITYFEATUREATTRIBUTE),e},t.prototype.createBufferWriter=function(){return new R(this.layout,this.params)},t.prototype.createRenderer=function(e,t){return new x(e,t,this,S.ribbonVertexAttributeLocations)},t.prototype.getGLMaterials=function(){return{color:O,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:M}},t.prototype.validateParams=function(){this.params.width&&this.params.width>1&&(this.params.width=Math.round(this.params.width)),"miter"!==this.params.join&&(this.params.miterLimit=0)},t}(m.Material),C=function(e){function t(t){var n=e.call(this,t)||this;return n.output=t.output,n.updateParameters(),n}return n(t,e),t.prototype.updateParameters=function(){this.technique=this.techniqueRep.acquireAndReleaseExisting(_.RibbonLineTechnique,this.material.getTechniqueConfig(this.output),this.technique)},t.prototype.beginSlot=function(e){return 0===this.output?e===(this.technique.configuration.writeDepth?6:9):4===e},t.prototype.getProgram=function(){return this.technique.program},t.prototype.getPrograms=function(){return null},t.prototype.bind=function(e,t){e.bindProgram(this.technique.program),this.technique.bindPipelineState(e),this.technique.bindPass(e,this.material.getPassParameters(),t)},t.prototype.release=function(){},t.prototype.bindView=function(e){this.technique.bindDraw(e)},t.prototype.bindInstance=function(e){this.technique.bindInstance(e)},t.prototype.getDrawMode=function(){return 5},t}(v.GLMaterial),O=function(e){function t(t){return e.call(this,i({},t,{output:0}))||this}return n(t,e),t}(C),M=function(e){function t(t){return e.call(this,i({},t,{output:4}))||this}return n(t,e),t}(C),D=i({width:0,color:[1,1,1,1],join:"miter",cap:"butt",miterLimit:5,writeDepth:!0,polygonOffset:!1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,slicePlaneEnabled:!1,vvFastUpdate:!1,transparent:!1,isClosed:!1},y.Default),R=function(){function e(e,t){if(this.params=t,this.numCapSubdivisions=0,this.numJoinSubdivisions=0,this.vertexBufferLayout=e,!t.isClosed)switch(this.params.cap){case"butt":this.numCapSubdivisions=0;break;case"square":this.numCapSubdivisions=1;break;case"round":this.numCapSubdivisions=T}switch(this.params.join){case"miter":case"bevel":this.numJoinSubdivisions=t.stipplePattern?1:0;break;case"round":this.numJoinSubdivisions=I}}return e.prototype.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},e.prototype.elementCount=function(e){var t=e.indices[S.RibbonVertexAttributeConstants.POSITION].length/2+1,n=this.params.isClosed,i=n?2:2*(2*this.numCapSubdivisions+2),r=n?t:t-1;if(e.vertexAttr[S.RibbonVertexAttributeConstants.SUBDIVISIONS])for(var a=e.vertexAttr[S.RibbonVertexAttributeConstants.SUBDIVISIONS].data,o=n?0:1;o<r;++o)i+=4+2*a[o];else i+=r*(2*this.numJoinSubdivisions+4);return i+2},e.prototype.write=function(e,t,n,i){var r=this,a=q,o=k,s=W,l=t.vertexAttr[S.RibbonVertexAttributeConstants.POSITION].data,u=t.indices&&t.indices[S.RibbonVertexAttributeConstants.POSITION];u&&u.length!==2*(l.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");var d=null;t.vertexAttr[S.RibbonVertexAttributeConstants.SUBDIVISIONS]&&(d=t.vertexAttr[S.RibbonVertexAttributeConstants.SUBDIVISIONS].data);var p=1,f=0;this.params.vvSizeEnabled?f=t.vertexAttr[S.RibbonVertexAttributeConstants.SIZEFEATUREATTRIBUTE].data[0]:t.vertexAttr[S.RibbonVertexAttributeConstants.SIZE]&&(p=t.vertexAttr[S.RibbonVertexAttributeConstants.SIZE].data[0]);var h=[1,1,1,1],v=0;this.params.vvColorEnabled?v=t.vertexAttr[S.RibbonVertexAttributeConstants.COLORFEATUREATTRIBUTE].data[0]:t.vertexAttr[S.RibbonVertexAttributeConstants.COLOR]&&(h=t.vertexAttr[S.RibbonVertexAttributeConstants.COLOR].data);var m=0;this.params.vvOpacityEnabled&&(m=t.vertexAttr[S.RibbonVertexAttributeConstants.OPACITYFEATUREATTRIBUTE].data[0]);var g=l.length/3,y=e.transformation,b=new Float32Array(n.buffer),x=this.vertexBufferLayout.stride/4,_=i*x,w=_,A=function(e,t,n,i,a,o){b[_++]=t[0],b[_++]=t[1],b[_++]=t[2],b[_++]=i,b[_++]=a,b[_++]=o,b[_++]=e[0],b[_++]=e[1],b[_++]=e[2],b[_++]=n[0],b[_++]=n[1],b[_++]=n[2],b[_++]=r.params.vvSizeEnabled?f:p,r.params.vvColorEnabled?b[_++]=v:(b[_++]=h[0],b[_++]=h[1],b[_++]=h[2],b[_++]=h[3]),r.params.vvOpacityEnabled&&(b[_++]=m)};_+=x,c.vec3.set(o,l[0],l[1],l[2]),y&&c.vec3.transformMat4(o,o,y);var C=this.params.isClosed;if(C){var O=l.length-3;c.vec3.set(a,l[O],l[O+1],l[O+2]),y&&c.vec3.transformMat4(a,a,y)}else{c.vec3.copy(a,o),c.vec3.set(s,l[3],l[4],l[5]),y&&c.vec3.transformMat4(s,s,y);for(var M=0;M<this.numCapSubdivisions;++M)A(a,o,s,z=1-M/this.numCapSubdivisions,1,-4),A(a,o,s,z,1,4);A(a,o,s,0,0,-4),A(a,o,s,0,0,4),c.vec3.copy(a,o),c.vec3.copy(o,s)}var D=C?g:g-1;for(M=C?0:1;M<D;M++){var R=(M+1)%g*3;c.vec3.set(s,l[R+0],l[R+1],l[R+2]),y&&c.vec3.transformMat4(s,s,y),A(a,o,s,0,1,-1),A(a,o,s,0,1,1);for(var T=d?d[M]:this.numJoinSubdivisions,I=0;I<T;++I)A(a,o,s,z=(I+1)/(T+1),1,-2),A(a,o,s,z,1,2);A(a,o,s,1,0,-2),A(a,o,s,1,0,2),c.vec3.copy(a,o),c.vec3.copy(o,s)}if(C)_=P(b,w+x,b,_,2*x);else for(A(a,o,s,0,1,-5),A(a,o,s,0,1,5),M=0;M<this.numCapSubdivisions;++M){var z;A(a,o,s,z=(M+1)/this.numCapSubdivisions,1,-5),A(a,o,s,z,1,5)}P(b,w+x,b,w,x),_=P(b,_-x,b,_,x)},e}(),T=3,I=1,z=u.vec3f64.create(),L=u.vec3f64.create(),E=u.vec3f64.create(),j=u.vec3f64.create(),V=u.vec3f64.create(),N=s.createRenderScreenPointArray3(),F=s.createRenderScreenPointArray3(),G=u.vec3f64.create(),B=u.vec3f64.create(),H=d.lineSegment.create(),U=d.lineSegment.create(),q=u.vec3f64.create(),k=u.vec3f64.create(),W=u.vec3f64.create(),Z=[s.createRenderScreenPointArray3(),s.createRenderScreenPointArray3(),s.createRenderScreenPointArray3(),s.createRenderScreenPointArray3()],X=[u.vec3f64.create(),u.vec3f64.create(),u.vec3f64.create(),u.vec3f64.create()],Y=d.plane.create(),J=d.plane.create(),K=d.plane.create(),Q=d.plane.create();return A}).apply(null,i))||(e.exports=r)},"RdU/":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.WaterDistortion=function(e){e.fragment.uniforms.add("texWaveNormal","sampler2D"),e.fragment.uniforms.add("texWavePerturbation","sampler2D"),e.fragment.uniforms.add("octaveTextureRepeat","vec3"),e.fragment.uniforms.add("waveParams","vec4"),e.fragment.uniforms.add("waveDirection","vec2"),e.fragment.code.add(i.glsl(r||(r=n(["\n      // uniform vec3 octaveTextureRepeat;\n\n      // // 0: waveStrength\n      // // 1: waveTextureRepeat\n      // // 2: flowStrength\n      // // 3: flowOffset\n      // uniform vec4 waveParams;\n\n      // uniform vec2 waveDirection;\n\n      const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);\n\n      vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {\n        return 2.0 * texture2D(_tex, _uv).rg - 1.0;\n      }\n\n      float sampleNoiseTexture(vec2 _uv) {\n        return texture2D(texWavePerturbation, _uv).b;\n      }\n\n      vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {\n        return 2.0 * texture2D(_tex, _uv).rgb - 1.0;\n      }\n\n      float computeProgress(vec2 uv, float time) {\n        return fract(time);\n      }\n\n      float computeWeight(vec2 uv, float time) {\n        float progress = computeProgress(uv, time);\n        return 1.0 - abs(1.0 - 2.0 * progress);\n      }\n\n      vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {\n        float flowStrength = waveParams[2];\n        float flowOffset = waveParams[3];\n\n        vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;\n\n        float progress = computeProgress(uv, time + phaseOffset);\n        float weight = computeWeight(uv, time + phaseOffset);\n\n        vec2 result = uv;\n        result -= flowVector * (progress + flowOffset);\n        result += phaseOffset;\n        result += (time - progress) * FLOW_JUMP;\n\n        return vec3(result, weight);\n      }\n\n      const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;\n      const float TIME_NOISE_STRENGTH = 7.77;\n\n      vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {\n        float waveStrength = waveParams[0];\n\n        // overall directional shift in uv's for directional wave movement for\n        // now we do a hard coded scale for wave speed such that a unit length\n        // direction is not too fast.\n        vec2 waveMovement = time * -_waveDir;\n\n        float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;\n\n        // compute two perturbed uvs and blend weights\n        // then sample the wave normals at the two positions and blend\n        vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);\n        vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);\n\n        vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;\n        vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;\n\n        // logic to flatten the wave pattern\n        // scale xy components of the normal, then adjust z (up) component\n        vec3 mixNormal = normalize(normal_A + normal_B);\n        mixNormal.xy *= waveStrength;\n        mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));\n\n        return mixNormal;\n      }\n\n      vec3 getSurfaceNormal(vec2 _uv, float _time) {\n        float waveTextureRepeat = waveParams[1];\n        return getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);\n      }\n    "],["\n      // uniform vec3 octaveTextureRepeat;\n\n      // // 0: waveStrength\n      // // 1: waveTextureRepeat\n      // // 2: flowStrength\n      // // 3: flowOffset\n      // uniform vec4 waveParams;\n\n      // uniform vec2 waveDirection;\n\n      const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);\n\n      vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {\n        return 2.0 * texture2D(_tex, _uv).rg - 1.0;\n      }\n\n      float sampleNoiseTexture(vec2 _uv) {\n        return texture2D(texWavePerturbation, _uv).b;\n      }\n\n      vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {\n        return 2.0 * texture2D(_tex, _uv).rgb - 1.0;\n      }\n\n      float computeProgress(vec2 uv, float time) {\n        return fract(time);\n      }\n\n      float computeWeight(vec2 uv, float time) {\n        float progress = computeProgress(uv, time);\n        return 1.0 - abs(1.0 - 2.0 * progress);\n      }\n\n      vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {\n        float flowStrength = waveParams[2];\n        float flowOffset = waveParams[3];\n\n        vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;\n\n        float progress = computeProgress(uv, time + phaseOffset);\n        float weight = computeWeight(uv, time + phaseOffset);\n\n        vec2 result = uv;\n        result -= flowVector * (progress + flowOffset);\n        result += phaseOffset;\n        result += (time - progress) * FLOW_JUMP;\n\n        return vec3(result, weight);\n      }\n\n      const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;\n      const float TIME_NOISE_STRENGTH = 7.77;\n\n      vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {\n        float waveStrength = waveParams[0];\n\n        // overall directional shift in uv's for directional wave movement for\n        // now we do a hard coded scale for wave speed such that a unit length\n        // direction is not too fast.\n        vec2 waveMovement = time * -_waveDir;\n\n        float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;\n\n        // compute two perturbed uvs and blend weights\n        // then sample the wave normals at the two positions and blend\n        vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);\n        vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);\n\n        vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;\n        vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;\n\n        // logic to flatten the wave pattern\n        // scale xy components of the normal, then adjust z (up) component\n        vec3 mixNormal = normalize(normal_A + normal_B);\n        mixNormal.xy *= waveStrength;\n        mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));\n\n        return mixNormal;\n      }\n\n      vec3 getSurfaceNormal(vec2 _uv, float _time) {\n        float waveTextureRepeat = waveParams[1];\n        return getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);\n      }\n    "]))))}}).apply(null,i))||(e.exports=r)},RsYQ:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xoE+"),n("jBNx"),n("FXVB"),n("1m5D"),n("0LE5"),n("Rdxj"),n("2fXB"),n("O7NG"),n("aWgr"),n("AzkI"),n("18xY"),n("CIy2")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f){function h(e,t){var n=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2],a=t[3]-e[3];return n*n+i*i+r*r+a*a}function v(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function m(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}Object.defineProperty(t,"__esModule",{value:!0});var g=function(){function e(e,t,n){void 0===e&&(e=s.vec3f64.create()),void 0===t&&(t=s.vec3f64.create()),void 0===n&&(n=s.vec3f64.fromValues(0,0,1)),this._viewUp=s.vec3f64.create(),this._viewForward=s.vec3f64.create(),this._viewRight=s.vec3f64.create(),this._ray=u.ray.createWrapper(),this._viewport=c.vec4f64.fromValues(0,0,1,1),this._padding=c.vec4f64.fromValues(0,0,0,0),this._fov=55/180*Math.PI,this._near=1,this._far=1e3,this._viewDirty=!0,this._viewMatrix=a.mat4f64.create(),this._projectionDirty=!0,this._projectionMatrix=a.mat4f64.create(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=a.mat4f64.create(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=a.mat4f64.create(),this._frustumDirty=!0,this._frustum=u.frustum.create(),this._fullViewport=null,this.pixelRatio=1,this.relativeElevation=0,this._eye=s.vec3f64.clone(e),this._center=s.vec3f64.clone(t),this._up=s.vec3f64.clone(n),this._padding=c.vec4f64.create()}return Object.defineProperty(e.prototype,"eye",{get:function(){return this._eye},set:function(e){this._compareAndSetView(e,this._eye)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"center",{get:function(){return this._center},set:function(e){this._compareAndSetView(e,this._center)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"ray",{get:function(){return this._ray.origin=this.eye,this._ray.direction||(this._ray.direction=s.vec3f64.create()),o.vec3.subtract(this._ray.direction,this.center,this.eye),this._ray},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"up",{get:function(){return this._up},set:function(e){this._compareAndSetView(e,this._up)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"viewMatrix",{get:function(){return this._ensureViewClean(),this._viewMatrix},set:function(e){r.mat4.copy(this._viewMatrix,e),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"viewForward",{get:function(){return this._ensureViewClean(),this._viewForward},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"viewUp",{get:function(){return this._ensureViewClean(),this._viewUp},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"viewRight",{get:function(){return this._ensureViewClean(),this._viewRight},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"near",{get:function(){return this._near},set:function(e){this._near!==e&&(this._near=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"far",{get:function(){return this._far},set:function(e){this._far!==e&&(this._far=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"viewport",{get:function(){return this._viewport},set:function(e){this.x=e[0],this.y=e[1],this.width=e[2],this.height=e[3]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"x",{get:function(){return this._viewport[0]},set:function(e){this._viewport[0]!==(e+=this._padding[3])&&(this._viewport[0]=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"y",{get:function(){return this._viewport[1]},set:function(e){this._viewport[1]!==(e+=this._padding[2])&&(this._viewport[1]=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"width",{get:function(){return this._viewport[2]},set:function(e){this._viewport[2]!==e&&(this._viewport[2]=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"height",{get:function(){return this._viewport[3]},set:function(e){this._viewport[3]!==e&&(this._viewport[3]=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"fullWidth",{get:function(){return this._viewport[2]+this._padding[1]+this._padding[3]},set:function(e){this.width=e-(this._padding[1]+this._padding[3])},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"fullHeight",{get:function(){return this._viewport[3]+this._padding[0]+this._padding[2]},set:function(e){this.height=e-(this._padding[0]+this._padding[2])},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"fullViewport",{get:function(){return this._fullViewport||(this._fullViewport=c.vec4f64.create()),this._fullViewport[0]=this._viewport[0]-this._padding[3],this._fullViewport[1]=this._viewport[1]-this._padding[2],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"aspect",{get:function(){return this.width/this.height},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"padding",{get:function(){return this._padding},set:function(e){this._padding[0]===e[0]&&this._padding[1]===e[1]&&this._padding[2]===e[2]&&this._padding[3]===e[3]||(this._viewport[0]+=e[3]-this._padding[3],this._viewport[1]+=e[2]-this._padding[2],this._viewport[2]-=e[1]+e[3]-(this._padding[1]+this._padding[3]),this._viewport[3]-=e[0]+e[2]-(this._padding[0]+this._padding[2]),l.vec4.copy(this._padding,e),this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"viewProjectionMatrix",{get:function(){return this._viewProjectionDirty&&(r.mat4.multiply(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"projectionMatrix",{get:function(){if(this._projectionDirty){var e=this.width,t=this.height,n=this.near*Math.tan(this.fovY/2),i=n*this.aspect;r.mat4.frustum(this._projectionMatrix,-i*(1+2*this._padding[3]/e),i*(1+2*this._padding[1]/e),-n*(1+2*this._padding[2]/t),n*(1+2*this._padding[0]/t),this.near,this.far),this._projectionDirty=!1}return this._projectionMatrix},set:function(e){r.mat4.copy(this._projectionMatrix,e),this._projectionDirty=!1,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"fov",{get:function(){return this._fov},set:function(e){this._fov=e,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"fovX",{get:function(){return f.fovd2fovx(this._fov,this.width,this.height)},set:function(e){this._fov=f.fovx2fovd(e,this.width,this.height),this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"fovY",{get:function(){return f.fovd2fovy(this._fov,this.width,this.height)},set:function(e){this._fov=f.fovy2fovd(e,this.width,this.height),this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"distance",{get:function(){return o.vec3.distance(this._center,this._eye)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"frustum",{get:function(){return this._recomputeFrustum(),this._frustum},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"viewInverseTransposeMatrix",{get:function(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(this._viewInverseTransposeMatrix||(this._viewInverseTransposeMatrix=a.mat4f64.create()),r.mat4.invert(this._viewInverseTransposeMatrix,this.viewMatrix),r.mat4.transpose(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"perRenderPixelRatio",{get:function(){return Math.tan(this.fovX/2)/(this.width/2)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"perScreenPixelRatio",{get:function(){return this.perRenderPixelRatio*this.pixelRatio},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"aboveGround",{get:function(){return this.relativeElevation>=0},enumerable:!0,configurable:!0}),e.prototype.copyFrom=function(e){var t=e;return o.vec3.copy(this._eye,t._eye),o.vec3.copy(this._center,t._center),o.vec3.copy(this._up,t._up),l.vec4.copy(this._viewport,t._viewport),l.vec4.copy(this._padding,t._padding),this._near=t._near,this._far=t._far,this._fov=t._fov,this.relativeElevation=e.relativeElevation,this._viewDirty=t._viewDirty,this._viewDirty||(r.mat4.copy(this._viewMatrix,t._viewMatrix),o.vec3.copy(this._viewRight,t._viewRight),o.vec3.copy(this._viewUp,t._viewUp),o.vec3.copy(this._viewForward,t._viewForward)),t._projectionDirty?this._projectionDirty=!0:(r.mat4.copy(this._projectionMatrix,t._projectionMatrix),this._projectionDirty=!1),this._viewProjectionDirty=!0,this._frustumDirty=t._frustumDirty,this._frustumDirty||(u.frustum.copy(t._frustum,this._frustum),this._frustumDirty=!1),t._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(this._viewInverseTransposeMatrix?r.mat4.copy(this._viewInverseTransposeMatrix,t._viewInverseTransposeMatrix):this._viewInverseTransposeMatrix=a.mat4f64.clone(t._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),t._fullViewport?this._fullViewport?l.vec4.copy(this._fullViewport,t._fullViewport):this._fullViewport=c.vec4f64.clone(t._fullViewport):this._fullViewport=null,this.pixelRatio=e.pixelRatio,this},e.prototype.copyViewFrom=function(e){this.eye=e.eye,this.center=e.center,this.up=e.up},e.prototype.clone=function(){var t=new e;return t.copyFrom(this),t},e.prototype.equals=function(e){return v(this._eye,e._eye)&&v(this._center,e._center)&&v(this._up,e._up)&&m(this._viewport,e._viewport)&&m(this._padding,e._padding)&&this._near===e._near&&this._far===e._far&&this._fov===e._fov&&this.pixelRatio===e.pixelRatio&&this.relativeElevation===e.relativeElevation},e.prototype.almostEquals=function(e,t,n){void 0===n&&(n=!1);var i,r=o.vec3.distance(this._eye,this._center)*(t||5e-4),a=r*r;return n?(d.directionFromTo(x,e._eye,e._center),d.directionFromTo(_,this._eye,this._center),i=1e-10):(o.vec3.copy(x,e._center),o.vec3.copy(_,this._center),i=a),o.vec3.squaredDistance(e._eye,this._eye)<a&&o.vec3.squaredDistance(x,_)<i&&Math.abs(e._fov-this._fov)<.001&&h(e._padding,this._padding)<.5&&h(e._viewport,this._viewport)<.5&&this.pixelRatio===e.pixelRatio},e.prototype.markViewDirty=function(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0},e.prototype.computeRenderPixelSizeAt=function(e){return this.computeRenderPixelSizeAtDist(this.viewDirectionDistance(e))},e.prototype.computeRenderPixelSizeAtDist=function(e){return e*this.perRenderPixelRatio},e.prototype.computeScreenPixelSizeAt=function(e){return this.computeScreenPixelSizeAtDist(this.viewDirectionDistance(e))},e.prototype.viewDirectionDistance=function(e){return Math.abs(p.projectPointSignedLength(this.viewForward,o.vec3.subtract(x,e,this._eye)))},e.prototype.computeScreenPixelSizeAtDist=function(e){return e*this.perScreenPixelRatio},e.prototype.computeDistanceFromRadius=function(e,t){return e/Math.tan(Math.min(this.fovX,this.fovY)/(2*(t||1)))},e.prototype.getScreenCenter=function(e){return void 0===e&&(e=i.createScreenPointArray()),e[0]=(this.padding[3]+this.width/2)/this.pixelRatio,e[1]=(this.padding[0]+this.height/2)/this.pixelRatio,e},e.prototype.getRenderCenter=function(e,t,n){return void 0===t&&(t=.5),void 0===n&&(n=.5),e||(e=i.createRenderScreenPointArray3()),e[0]=this.padding[3]+this.width*t,e[1]=this.padding[2]+this.height*n,e.length>2&&(e[2]=.5),e},e.prototype.setGLViewport=function(e){var t=this.viewport,n=this.padding;e.setViewport(t[0]-n[3],t[1]-n[2],t[2]+n[1]+n[3],t[3]+n[0]+n[2])},e.prototype.applyProjection=function(e,t,i){void 0===i&&(i=!1),e!==y&&o.vec3.copy(y,e),y[3]=1,i&&(t[2]=-y[2]),l.vec4.transformMat4(y,y,this.projectionMatrix),o.vec3.scale(y,y,1/Math.abs(y[3]));var r=this.fullViewport;return t[0]=n.lerp(0,r[0]+r[2],.5+.5*y[0]),t[1]=n.lerp(0,r[1]+r[3],.5+.5*y[1]),i||(t[2]=.5*(y[2]+1)),t},e.prototype.projectPoint=function(e,t){if(y[0]=e[0],y[1]=e[1],y[2]=e[2],y[3]=1,l.vec4.transformMat4(y,y,this.viewProjectionMatrix),0===y[3])return null;o.vec3.scale(y,y,1/Math.abs(y[3]));var i=this.fullViewport;return"x"in t?(t.x=n.lerp(0,i[0]+i[2],.5+.5*y[0]),t.y=n.lerp(0,i[1]+i[3],.5+.5*y[1])):(t[0]=n.lerp(0,i[0]+i[2],.5+.5*y[0]),t[1]=n.lerp(0,i[1]+i[3],.5+.5*y[1]),t.length>2&&(t[2]=.5*(y[2]+1))),t},e.prototype.unprojectPoint=function(e,t){if(r.mat4.multiply(b,this.projectionMatrix,this.viewMatrix),!r.mat4.invert(b,b))return null;var n=this.fullViewport;return y[0]=2*(e[0]-n[0])/n[2]-1,y[1]=2*(e[1]-n[1])/n[3]-1,y[2]=2*e[2]-1,y[3]=1,l.vec4.transformMat4(y,y,b),0===y[3]?null:(t[0]=y[0]/y[3],t[1]=y[1]/y[3],t[2]=y[2]/y[3],t)},e.prototype.computeUp=function(e){"global"===e?this.computeUpGlobal():this.computeUpLocal()},e.prototype.screenToRender=function(e,t){var n=this.fullHeight-e[1]*this.pixelRatio;return t[0]=e[0]*this.pixelRatio,t[1]=n,t},e.prototype.renderToScreen=function(e,t){var n=(this.fullHeight-e[1])/this.pixelRatio;return t[0]=e[0]/this.pixelRatio,t[1]=n,t},e.prototype.computeUpGlobal=function(){o.vec3.subtract(x,this.center,this.eye);var e=o.vec3.length(this.center);e<1?(o.vec3.set(this.up,0,0,1),this.markViewDirty()):Math.abs(o.vec3.dot(x,this.center))>.9999*o.vec3.length(x)*e||(o.vec3.cross(this.up,x,this.center),o.vec3.cross(this.up,this.up,x),o.vec3.normalize(this.up,this.up),this.markViewDirty())},e.prototype.computeUpLocal=function(){d.directionFromTo(x,this.eye,this.center),Math.abs(x[2])<=.9999&&(o.vec3.scale(x,x,x[2]),o.vec3.set(this.up,-x[0],-x[1],1-x[2]),o.vec3.normalize(this.up,this.up),this.markViewDirty())},e.prototype._compareAndSetView=function(e,t){v(e,t)||(o.vec3.copy(t,e),this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0)},e.prototype._recomputeFrustum=function(){this._frustumDirty&&(u.frustum.fromMatrix(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)},e.prototype._ensureViewClean=function(){this._viewDirty&&(r.mat4.lookAt(this._viewMatrix,this._eye,this._center,this._up),o.vec3.set(this._viewForward,-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10]),o.vec3.set(this._viewUp,this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9]),o.vec3.set(this._viewRight,this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8]),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)},e}();t.default=g;var y=c.vec4f64.create(),b=a.mat4f64.create(),x=s.vec3f64.create(),_=s.vec3f64.create()}).apply(null,i))||(e.exports=r)},SNs2:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("qKT0"),n("2Atf"),n("LxLY"),n("LxLY"),n("fese"),n("3kdR"),n("PaEL"),n("3PFg"),n("W/V4"),n("FQ4r"),n("lBa0"),n("ne9J"),n("G0ER"),n("qbr3")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m){Object.defineProperty(t,"__esModule",{value:!0}),t.RibbonVertexAttributeConstants={POSITION:"position",SUBDIVISIONFACTOR:"subdivisionFactor",UV0:"uv0",AUXPOS1:"auxpos1",AUXPOS2:"auxpos2",SUBDIVISIONS:"subdivisions",COLOR:"color",COLORFEATUREATTRIBUTE:"colorFeatureAttribute",SIZE:"size",SIZEFEATUREATTRIBUTE:"sizeFeatureAttribute",OPACITYFEATUREATTRIBUTE:"opacityFeatureAttribute"},t.ribbonVertexAttributeLocations={position:0,subdivisionFactor:1,uv0:2,auxpos1:3,auxpos2:4,size:6,sizeFeatureAttribute:6,color:5,colorFeatureAttribute:5,opacityFeatureAttribute:7};var g=function(i){function r(e,t){var n=i.call(this,e,t)||this;return n.stipplePattern=null,n.stippleTextureBind=null,n.stippleTextureRepository=e.stippleTextureRepository,n}return n(r,i),r.prototype.initializeProgram=function(e){var n=r.shader.get(),i=this.configuration,a=n.build({output:i.output,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:i.sliceHighlightDisabled,stippleEnabled:i.stippleEnabled,stippleOffColorEnabled:i.stippleOffColorEnabled,stippleUVMaxEnabled:i.stippleIntegerRepeatsEnabled,stippleIntegerRepeatsEnabled:i.stippleIntegerRepeatsEnabled,roundCaps:i.roundCaps,roundJoins:i.roundJoins,vvColor:i.vvColor,vvSize:i.vvSize,vvOpacity:i.vvOpacity});return new v(e.rctx,a.generateSource("vertex"),a.generateSource("fragment"),t.ribbonVertexAttributeLocations)},r.prototype.dispose=function(){i.prototype.dispose.call(this),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null},r.prototype.bindPass=function(e,t,n){if(4===this.configuration.output&&c.OutputHighlight.bindOutputHighlight(e,this.program,n),this.program.setUniform1f("symbolLineWidth",t.width),this.program.setUniform4fv("symbolColor",t.color),this.program.setUniform1f("miterLimit","miter"!==t.join?0:t.miterLimit),this.program.setUniform1f("nearPlane",n.nearFar[0]),this.program.setUniform1f("pixelRatio",n.pixelRatio),this.program.setUniform2fv("screenSize",[n.viewport[2],n.viewport[3]]),u.VisualVariables.bindUniformsWithOpacity(this.program,t),this.stipplePattern!==t.stipplePattern){var i=t.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,i),this.stipplePattern=i}if(this.configuration.stippleEnabled){var r=o.isSome(this.stippleTextureBind)?this.stippleTextureBind(e,0)*n.pixelRatio:1;if(this.program.setUniform1i("stipplePatternTexture",0),this.program.setUniform1f("stipplePatternPixelSizeInv",1/r),this.configuration.stippleOffColorEnabled){var s=a.expect(t.stippleOffColor);this.program.setUniform4f("stippleOffColor",s[0],s[1],s[2],s.length>3?s[3]:1)}}},r.prototype.bindDraw=function(e){l.Transform.bindUniforms(this.program,e),s.Slice.bindUniformsWithOrigin(this.program,this.configuration,e)},r.prototype.bindInstance=function(e){this.program.setUniformMatrix4fv("model",e.transformation)},r.prototype.initializePipeline=function(){var e=this.configuration;return m.makePipelineState(0===e.output?{blending:m.separateBlendingParams(770,1,771,771),polygonOffset:e.polygonOffset&&y,depthTest:{func:513},depthWrite:!e.transparent&&e.writeDepth&&m.defaultDepthWriteParams,colorWrite:m.defaultColorWriteParams}:{polygonOffset:e.polygonOffset&&y,depthTest:{func:513},depthWrite:!e.transparent&&e.writeDepth&&m.defaultDepthWriteParams,colorWrite:m.defaultColorWriteParams})},r.prototype.bindPipelineState=function(e){e.setPipelineState(this.pipeline)},r.shader=new d.ReloadableShaderModule(h,"./RibbonLine.glsl",e),r}(p.ShaderTechnique);t.RibbonLineTechnique=g;var y={factor:0,units:-4},b=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.output=0,t.slicePlaneEnabled=!1,t.sliceHighlightDisabled=!1,t.vertexColors=!1,t.transparent=!1,t.polygonOffset=!1,t.writeDepth=!1,t.stippleEnabled=!1,t.stippleOffColorEnabled=!1,t.stippleIntegerRepeatsEnabled=!1,t.roundCaps=!1,t.roundJoins=!1,t.vvSize=!1,t.vvColor=!1,t.vvOpacity=!1,t}return n(t,e),i([f.parameter({count:6})],t.prototype,"output",void 0),i([f.parameter()],t.prototype,"slicePlaneEnabled",void 0),i([f.parameter()],t.prototype,"sliceHighlightDisabled",void 0),i([f.parameter()],t.prototype,"vertexColors",void 0),i([f.parameter()],t.prototype,"transparent",void 0),i([f.parameter()],t.prototype,"polygonOffset",void 0),i([f.parameter()],t.prototype,"writeDepth",void 0),i([f.parameter()],t.prototype,"stippleEnabled",void 0),i([f.parameter()],t.prototype,"stippleOffColorEnabled",void 0),i([f.parameter()],t.prototype,"stippleIntegerRepeatsEnabled",void 0),i([f.parameter()],t.prototype,"roundCaps",void 0),i([f.parameter()],t.prototype,"roundJoins",void 0),i([f.parameter()],t.prototype,"vvSize",void 0),i([f.parameter()],t.prototype,"vvColor",void 0),i([f.parameter()],t.prototype,"vvOpacity",void 0),t}(f.ShaderTechniqueConfiguration);t.RibbonLineTechniqueConfiguration=b}).apply(null,i))||(e.exports=r)},TCLX:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("xhoE"),n("LxLY"),n("W9tT"),n("DIqE"),n("0LE5"),n("Rdxj"),n("2fXB"),n("O7NG"),n("ZPQp"),n("nrlZ")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p){function f(){return new h}Object.defineProperty(t,"__esModule",{value:!0});var h=function(){function e(){this.vertices=[],this.edges=[]}return e.prototype.makeVertex=function(e,t,n){void 0===t&&(t=null),void 0===n&&(n=null);var i={pos:e,unnormalizedPos:e,left:t,right:n,type:"vertex",component:this};return this.vertices.push(i),i},e.prototype.makeEdge=function(e,t){var n={v0:e,v1:t,type:"edge",component:this};return e.right=n,t.left=n,this.edges.push(n),n},e.prototype.removeVertex=function(e){this.vertices.splice(this.vertices.indexOf(e),1),e.left&&this.removeEdge(e.left),e.right&&this.removeEdge(e.right)},e.prototype.removeEdge=function(e){this.edges.splice(this.edges.indexOf(e),1),e.v0.right=null,e.v1.left=null},e}();t.Component=h;var v=function(){function e(){}return e.prototype.createNew=function(){return o.vec2f64.create()},e.prototype.fromArray=function(e){return o.vec2f64.fromValues(e[0],e[1])},e.prototype.toArray=function(e){return[e[0],e[1]]},e.prototype.toPoint=function(e,t){return t.x=e[0],t.y=e[1],t.hasZ=!1,t.hasM=!1,t},e.prototype.lerp=function(e,t,n,i){return a.vec2.lerp(i,e,t,n)},e.prototype.addDelta=function(e,t,n){e[0]+=t,e[1]+=n},e}();t.CoordinateHelper2D=v;var m=function(){function e(e){this.ztype=e}return e.prototype.createNew=function(){return l.vec3f64.create()},e.prototype.fromArray=function(e){return l.vec3f64.fromValues(e[0],e[1],e[2]||0)},e.prototype.toArray=function(e){return[e[0],e[1],e[2]]},e.prototype.toPoint=function(e,t){return t.x=e[0],t.y=e[1],0===this.ztype?(t.z=e[2],t.hasZ=!0,t.hasM=!1):(t.m=e[2],t.hasZ=!1,t.hasM=!0),t},e.prototype.lerp=function(e,t,n,i){return s.vec3.lerp(i,e,t,n)},e.prototype.addDelta=function(e,t,n,i){e[0]+=t,e[1]+=n,0===this.ztype&&(e[2]+=i)},e}();t.CoordinateHelper3D=m;var g=function(){function e(){}return e.prototype.createNew=function(){return u.vec4f64.create()},e.prototype.fromArray=function(e){return u.vec4f64.fromValues(e[0],e[1],e[2]||0,e[3]||0)},e.prototype.toArray=function(e){return[e[0],e[1],e[2],e[3]]},e.prototype.toPoint=function(e,t){return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.hasZ=!0,t.hasM=!0,t},e.prototype.lerp=function(e,t,n,i){return c.vec4.lerp(i,e,t,n)},e.prototype.addDelta=function(e,t,n,i){e[0]+=t,e[1]+=n,e[2]+=i},e}();t.CoordinateHelper4D=g;var y=function(){function e(e,t,n){this.geometry=e,this.doUnnormalization=t,this.coordinateHelper=n,this.components=[];var i=p.getInfo(this.geometry.spatialReference);this._tmpMapPoint=n.createNew(),i?(this._spanMin=i.valid[0],this._spanMax=i.valid[1],this._span=this._spanMax-this._spanMin):this.doUnnormalization=!1}return e.prototype.addDelta=function(e,t,n,i){this.coordinateHelper.addDelta(e.pos,t,n,i)},e.prototype.getVertexPositionAsPoint=function(e,t){return this.coordinateHelper.toPoint(e.pos,t),t.spatialReference=this.geometry.spatialReference,t},e.prototype.getEdgePosition=function(e,t,n){return void 0===n&&(n=this.coordinateHelper.createNew()),this.coordinateHelper.lerp(e.v0.unnormalizedPos,e.v1.unnormalizedPos,t,n)},e.prototype.getEdgePositionAsPoint=function(e,t,n){var i=this.getEdgePosition(e,t,this._tmpMapPoint);return this.coordinateHelper.toPoint(i,n),n.spatialReference=this.geometry.spatialReference,n},e.prototype.canRemoveVertex=function(e){return!0},e.prototype.removeVertex=function(e){var t=e.component,n=e.left,i=e.right;return t.removeVertex(e),n&&i?t.makeEdge(n.v0,i.v1):null},e.prototype.splitEdge=function(e,t){var n=e.component,i=n.makeVertex(this.getEdgePosition(e,t)),r=e.v0,a=e.v1;return n.removeEdge(e),n.makeEdge(r,i),n.makeEdge(i,a),i},e}();t.ReshapeHelper=y;var b=function(e){function t(t,n,i){var r=e.call(this,t,n,i)||this;r.geometry=t;for(var a=r.geometry.rings,o=0;o<a.length;++o){for(var s=a[o],l=f(),c=s.length-1,u=0;u<c;++u){var p=i.fromArray(s[u]);l.makeVertex(p)}for(var h=l.vertices.length-1,v=0;v<h;++v)l.makeEdge(l.vertices[v],l.vertices[v+1]);l.makeEdge(l.vertices[l.vertices.length-1],l.vertices[0]),r.doUnnormalization&&d.computeUnnormalizedVertexPositionsOnDateLineCrossing(l.vertices,r._spanMin,r._spanMax,r._span),r.components.push(l)}return r}return i(t,e),t.prototype.canRemoveVertex=function(e){return e.component.vertices.length>3},t.prototype.commit=function(){var e=this,t=[],n=this.coordinateHelper.toArray;return this.components.forEach((function(i){var r=[];e.doUnnormalization&&d.computeUnnormalizedVertexPositionsOnDateLineCrossing(i.vertices,e._spanMin,e._spanMax,e._span);var a=i.vertices[0],o=a;do{r.push(n(a.unnormalizedPos)),a=a.right.v1}while(a&&a!==o);r.push(n(i.vertices[0].unnormalizedPos)),t.push(r)})),this.geometry.rings=t,this.geometry},t}(y),x=function(e){function t(t,n,i){var r=e.call(this,t,n,i)||this;r.geometry=t;for(var a=r.geometry.paths,o=0;o<a.length;++o){for(var s=a[o],l=f(),c=s.length,u=0;u<c;++u){var p=i.fromArray(s[u]);l.makeVertex(p)}for(var h=l.vertices.length-1,v=0;v<h;++v)l.makeEdge(l.vertices[v],l.vertices[v+1]);r.doUnnormalization&&d.computeUnnormalizedVertexPositionsOnDateLineCrossing(l.vertices,r._spanMin,r._spanMax,r._span),r.components.push(l)}return r}return i(t,e),t.prototype.canRemoveVertex=function(e){return e.component.vertices.length>2},t.prototype.commit=function(){var e=this,t=[],n=this.coordinateHelper.toArray;return this.components.forEach((function(i){var r=[];e.doUnnormalization&&d.computeUnnormalizedVertexPositionsOnDateLineCrossing(i.vertices,e._spanMin,e._spanMax,e._span);var a=i.vertices[0],o=a;do{r.push(n(a.unnormalizedPos)),a=a.right?a.right.v1:null}while(a&&a!==o);t.push(r)})),this.geometry.paths=t,this.geometry},t}(y);t.isReshapeGeometry=function(e){return r.isSome(e)&&("polygon"===e.type||"polyline"===e.type)},t.createReshapeHelper=function(e,t){if(r.isNone(e))return null;var n=function(e){return e.hasZ&&e.hasM?new g:e.hasM?new m(1):e.hasZ?new m(0):new v}(e);return"polygon"===e.type?new b(e,t,n):new x(e,t,n)}}).apply(null,i))||(e.exports=r)},TP2F:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("2Atf"),n("LxLY"),n("51bw"),n("0LE5"),n("Rdxj"),n("2B1V"),n("bMXq"),n("9FJH"),n("FNtW"),n("CIy2"),n("ILj8"),n("s6rJ"),n("uNX8"),n("ZeO9"),n("CsnI"),n("qbr3"),n("qbr3")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b){function x(e,t){return e?t?6:9:4}var _=p.assert,S=function(e){function t(n,i){var r=e.call(this,i)||this;return r.supportsEdges=!0,r.techniqueConfig=new g.DefaultMaterialTechniqueConfiguration,r.params=h.copyParameters(n,M),r.vertexBufferLayout=t.getVertexBufferLayout(r.params),r.instanceBufferLayout=n.instanced?t.getInstanceBufferLayout(r.params):null,r}return n(t,e),t.prototype.isVisibleInPass=function(e){return 3!==e||this.params.castShadows},t.prototype.isVisible=function(){var t=this.params;if(!e.prototype.isVisible.call(this)||0===t.layerOpacity)return!1;var n=t.instanced,i=t.vertexColors,r=t.symbolColors,a=!!n&&n.indexOf("color")>-1,o=t.vvColorEnabled,s="replace"===t.colorMixMode,l=t.opacity>0,c=t.externalColor&&t.externalColor[3]>0;return i&&(a||o||r)?!!s||l:i?s?c:l:a||o||r?!!s||l:s?c:l},t.prototype.setParameterValues=function(e){var t=this.params;for(var n in e)"instanced"===n&&_(e.instanced===t.instanced,"Can not change instanced attributes"),"textureId"===n&&_(t.textureId,"Can only change texture of material that already has a texture"),"vertexColors"===n&&!0===e[n]&&e[n]!==t[n]&&_(t.vertexColors,"Can not enable vertex colors after DefaultMaterial creation"),t[n]=e[n];this.notifyDirty("matChanged")},t.prototype.getParameters=function(){return this.params},t.prototype.getTechniqueConfig=function(e){return this.techniqueConfig.output=e,this.techniqueConfig.hasNormalTexture=!!this.params.normalTextureId,this.techniqueConfig.hasColorTexture=!!this.params.textureId,this.techniqueConfig.vertexTangents=this.params.vertexTangents,this.techniqueConfig.instanced=!!this.params.instanced,this.techniqueConfig.instancedDoublePrecision=this.params.instancedDoublePrecision,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.verticalOffset=null!==this.params.verticalOffset,this.techniqueConfig.screenSizePerspective=null!==this.params.screenSizePerspective,this.techniqueConfig.slice=this.params.slicePlaneEnabled,this.techniqueConfig.sliceHighlightDisabled=this.params.sliceHighlightDisabled,this.techniqueConfig.alphaDiscardMode="opaque"===this.params.textureAlphaMode?1:"mask"===this.params.textureAlphaMode?2:"maskBlend"===this.params.textureAlphaMode?3:0,this.techniqueConfig.normalsTypeDerivate="screenDerivative"===this.params.normals,0===e&&(this.techniqueConfig.treeRendering=!!this.params.treeRendering,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.symbolColors=this.params.symbolColors,this.techniqueConfig.doubleSidedMode=this.params.doubleSided&&"normal"===this.params.doubleSidedType?1:this.params.doubleSided&&"winding-order"===this.params.doubleSidedType?2:0,this.techniqueConfig.instancedColor=!!this.params.instanced&&this.params.instanced.indexOf("color")>-1,this.techniqueConfig.receiveShadows=this.params.receiveShadows,this.techniqueConfig.receiveAmbientOcclusion=this.params.receiveSSAO,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.textureAlphaPremultiplied=!!this.params.textureAlphaPremultiplied,this.techniqueConfig.usePBR=this.params.usePBR,this.techniqueConfig.hasMetalnessAndRoughnessTexture=!!this.params.metallicRoughnessTextureId,this.techniqueConfig.hasEmissionTexture=!!this.params.emissiveTextureId,this.techniqueConfig.hasOcclusionTexture=!!this.params.occlusionTextureId,this.techniqueConfig.offsetBackfaces=!(!this.params.transparent||!this.params.offsetTransparentBackfaces)),this.techniqueConfig},t.prototype.intersect=function(e,t,n,i,a,s,l){if(null!==this.params.verticalOffset){var c=i.camera;o.vec3.set(V,n[12],n[13],n[14]);var u=null;switch(i.viewingMode){case"global":u=o.vec3.normalize(E,V);break;case"local":u=o.vec3.copy(E,L)}var d=0;if(null!==this.params.verticalOffset){var p=o.vec3.subtract(N,V,c.eye),f=o.vec3.length(p),v=o.vec3.scale(p,p,1/f),m=null;this.params.screenSizePerspective&&(m=o.vec3.dot(u,v)),d+=h.verticalOffsetAtDistance(c,f,this.params.verticalOffset,m,this.params.screenSizePerspective)}o.vec3.scale(u,u,d),o.vec3.transformMat3(j,u,i.transform.inverseRotation),a=o.vec3.subtract(I,a,j),s=o.vec3.subtract(z,s,j)}h.intersectTriangleGeometry(e,t,i,a,s,r.isSome(i.options.verticalOffset)?i.options.verticalOffset.object3D:void 0,l)},t.prototype.getGLMaterials=function(){return{color:P,depthShadowMap:A,normal:C,depth:w,highlight:O}},t.prototype.createRenderer=function(e,t){return this.params.softwareInstanced?new v(e,t,this):new m(e,t,this)},t.prototype.createBufferWriter=function(){return new D(this.vertexBufferLayout,this.instanceBufferLayout)},t.getVertexBufferLayout=function(e){var t=e.textureId||e.normalTextureId||e.metallicRoughnessTextureId||e.emissiveTextureId||e.occlusionTextureId,n=l.newLayout().vec3f("position").vec3f("normal");return e.vertexTangents&&n.vec4f("tangent"),t&&n.vec2f("uv0"),e.vertexColors&&n.vec4u8("color"),e.symbolColors&&n.vec4u8("symbolColor"),n},t.getInstanceBufferLayout=function(e){var t=l.newLayout();return t=e.instancedDoublePrecision?t.vec3f("modelOriginHi").vec3f("modelOriginLo").mat3f("model").mat3f("modelNormal"):t.mat4f("model").mat4f("modelNormal"),e.instanced&&e.instanced.indexOf("color")>-1&&(t=t.vec4f("instanceColor")),e.instanced&&e.instanced.indexOf("featureAttribute")>-1&&(t=t.vec4f("instanceFeatureAttribute")),t},t}(d.Material),P=function(e){function t(t){var n=this,i=t.material.getParameters();(n=e.call(this,u.makeCtorParameters(t,i))||this).params=h.copyParameters(i);var r=n.params;return n.slot=x(r.transparent,r.writeDepth),n.technique=n.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,n.material.getTechniqueConfig(0),n.technique),n.selectPipeline(0),n}return n(t,e),t.prototype.selectPipeline=function(e){var t=this.params,n=0===e?R(t):null;this.pipelineState=b.makePipelineState({blending:n,culling:T(t),depthTest:{func:513},depthWrite:t.writeDepth&&b.defaultDepthWriteParams,colorWrite:b.defaultColorWriteParams})},t.prototype.beginSlot=function(e){return e===this.slot},t.prototype.getProgram=function(){return this.technique.program},t.prototype.getPrograms=function(){return null},t.prototype.updateParameters=function(){this.params=h.copyParameters(this.material.getParameters()),this.slot=x(this.params.transparent,this.params.writeDepth),this.updateTexture(this.params.textureId),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(0),this.technique),this.selectPipeline(0)},t.prototype._updateShadowState=function(e){e.shadowMappingEnabled!==this.params.receiveShadows&&(this.material.setParameterValues({receiveShadows:e.shadowMappingEnabled}),this.updateParameters())},t.prototype.bind=function(e,t){var n=this.params;this._updateShadowState(t);var i=this.technique.program;e.bindProgram(i),e.setPipelineState(this.pipelineState),this.technique.bindPass(e,n,t),h.bindVerticalOffset(n.verticalOffset,t,i),h.bindScreenSizePerspective(n.screenSizePerspective,i),this.bindTexture(e,i)},t.prototype.release=function(){},t.prototype.bindView=function(e){var t=this.technique.program,n=this.params,i=n.instancedDoublePrecision?s.vec3f64.fromValues(e.viewInvTransp[3],e.viewInvTransp[7],e.viewInvTransp[11]):e.origin;h.bindView(i,e.view,t),h.bindCamPos(i,e.viewInvTransp,t),n.instancedDoublePrecision&&h.bindViewOriginDouble(i,t),n.slicePlaneEnabled&&h.bindSlicePlane(i,e.slicePlane,t),e.shadowMappingEnabled&&e.shadowMap.bindView(t,i)},t.prototype.bindInstance=function(e){var t=this.technique.program;t.setUniformMatrix4fv("model",e.transformation),t.setUniformMatrix4fv("modelNormal",e.transformationNormal)},t.prototype.getDrawMode=function(){return 4},t}(u),w=function(e){function t(t){var n=this;return(n=e.call(this,u.makeCtorParameters(t,t.material.getParameters()))||this).updateParameters(),n}return n(t,e),t.prototype.beginSlot=function(e){return e===this.slot},t.prototype.getProgram=function(){return this.technique.program},t.prototype.getPrograms=function(){return null},t.prototype.selectPipeline=function(){var e=this.params;this.pipelineState=b.makePipelineState({culling:T(e),depthTest:{func:513},depthWrite:e.writeDepth&&b.defaultDepthWriteParams,colorWrite:b.defaultColorWriteParams})},t.prototype.selectSlot=function(){this.slot=x(this.params.transparent,this.params.writeDepth)},t.prototype.updateParameters=function(){this.params=h.copyParameters(this.material.getParameters()),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(1),this.technique),this.selectPipeline(),this.selectSlot(),this.updateTexture(this.params.textureId)},t.prototype.bind=function(e,t){var n=this.technique.program,i=this.params;e.bindProgram(n),e.setPipelineState(this.pipelineState),this.technique.bindPass(e,i,t),h.bindVerticalOffset(i.verticalOffset,t,n),h.bindScreenSizePerspective(i.screenSizePerspective,n),this.bindTexture(e,n)},t.prototype.release=function(){},t.prototype.bindView=function(e){var t=this.technique.program,n=this.params,i=n.instancedDoublePrecision?s.vec3f64.fromValues(e.viewInvTransp[3],e.viewInvTransp[7],e.viewInvTransp[11]):e.origin;h.bindView(i,e.view,t),n.slicePlaneEnabled&&h.bindSlicePlane(i,e.slicePlane,t),n.screenSizePerspective&&h.bindCamPos(i,e.viewInvTransp,t),n.instancedDoublePrecision&&h.bindViewOriginDouble(i,t)},t.prototype.bindInstance=function(e){this.technique.program.setUniformMatrix4fv("model",e.transformation)},t.prototype.getDrawMode=function(){return 4},t}(u),A=function(e){function t(t){return e.call(this,t)||this}return n(t,e),t.prototype.updateParameters=function(){this.params=h.copyParameters(this.material.getParameters()),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(3),this.technique),this.selectPipeline(),this.selectSlot(),this.updateTexture(this.params.textureId)},t}(w),C=function(e){function t(t){var n=this,i=t.material.getParameters();return(n=e.call(this,u.makeCtorParameters(t,i))||this).params=h.copyParameters(i),n.technique=n.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,n.material.getTechniqueConfig(2),n.technique),n.selectPipeline(),n.selectSlot(),n}return n(t,e),t.prototype.beginSlot=function(e){return e===this.slot},t.prototype.getProgram=function(){return this.technique.program},t.prototype.getPrograms=function(){return null},t.prototype.selectPipeline=function(){var e=this.params;this.pipelineState=b.makePipelineState({culling:T(e),depthTest:{func:513},depthWrite:e.writeDepth&&b.defaultDepthWriteParams,colorWrite:b.defaultColorWriteParams})},t.prototype.selectSlot=function(){this.slot=x(this.params.transparent,this.params.writeDepth)},t.prototype.updateParameters=function(){this.params=h.copyParameters(this.material.getParameters()),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(2),this.technique),this.selectPipeline(),this.selectSlot(),this.updateTexture(this.params.textureId)},t.prototype.bind=function(e,t){var n=this.technique.program,i=this.params;e.bindProgram(n),e.setPipelineState(this.pipelineState),this.technique.bindPass(e,i,t),h.bindVerticalOffset(i.verticalOffset,t,n),h.bindScreenSizePerspective(i.screenSizePerspective,n),this.bindTexture(e,n)},t.prototype.release=function(){},t.prototype.bindView=function(e){var t=this.technique.program,n=this.params,i=n.instancedDoublePrecision?s.vec3f64.fromValues(e.viewInvTransp[3],e.viewInvTransp[7],e.viewInvTransp[11]):e.origin;h.bindView(i,e.view,t),t.setUniformMatrix4fv("viewNormal",e.viewInvTransp),n.slicePlaneEnabled&&h.bindSlicePlane(i,e.slicePlane,t),n.screenSizePerspective&&h.bindCamPos(i,e.viewInvTransp,t),n.instancedDoublePrecision&&h.bindViewOriginDouble(i,t)},t.prototype.bindInstance=function(e){var t=this.technique.program;t.setUniformMatrix4fv("model",e.transformation),t.setUniformMatrix4fv("modelNormal",e.transformationNormal)},t.prototype.getDrawMode=function(){return 4},t}(u),O=function(e){function t(t){var n=this;return(n=e.call(this,u.makeCtorParameters(t,t.material.getParameters()))||this).updateParameters(),n}return n(t,e),t.prototype.beginSlot=function(e){return e===this.slot},t.prototype.getProgram=function(){return this.technique.program},t.prototype.getPrograms=function(){return null},t.prototype.selectPipeline=function(){var e=this.params;this.pipelineState=b.makePipelineState({culling:T(e),depthTest:{func:513},depthWrite:e.writeDepth&&b.defaultDepthWriteParams,colorWrite:b.defaultColorWriteParams})},t.prototype.selectSlot=function(){this.slot=x(this.params.transparent,this.params.writeDepth)},t.prototype.updateParameters=function(){this.params=h.copyParameters(this.material.getParameters()),this.technique=this.techniqueRep.acquireAndReleaseExisting(g.DefaultMaterialTechnique,this.material.getTechniqueConfig(4),this.technique),this.selectPipeline(),this.selectSlot(),this.updateTexture(this.params.textureId)},t.prototype.bind=function(e,t){var n=this.technique.program,i=this.params;e.bindProgram(n),e.setPipelineState(this.pipelineState),this.technique.bindPass(e,i,t),h.bindVerticalOffset(i.verticalOffset,t,n),h.bindScreenSizePerspective(i.screenSizePerspective,n),this.bindTexture(e,n)},t.prototype.release=function(){},t.prototype.bindView=function(e){var t=this.technique.program,n=this.params,i=n.instancedDoublePrecision?s.vec3f64.fromValues(e.viewInvTransp[3],e.viewInvTransp[7],e.viewInvTransp[11]):e.origin;h.bindView(i,e.view,t),n.slicePlaneEnabled&&h.bindSlicePlane(i,e.slicePlane,t),n.screenSizePerspective&&h.bindCamPos(i,e.viewInvTransp,t),n.instancedDoublePrecision&&h.bindViewOriginDouble(i,t)},t.prototype.bindInstance=function(e){var t=this.technique.program;t.setUniformMatrix4fv("model",e.transformation),t.setUniformMatrix4fv("modelNormal",e.transformationNormal)},t.prototype.getDrawMode=function(){return 4},t}(u);!function(e){e.COLOR_GAMMA=2.1}(S||(S={}));var M={textureId:void 0,initTextureTransparent:!1,usePBR:!1,normalTextureId:void 0,vertexTangents:!1,occlusionTextureId:void 0,emissiveTextureId:void 0,metallicRoughnessTextureId:void 0,emissiveFactor:[0,0,0],metallicFactor:0,roughnessFactor:1,reflectanceFactor:.5,ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],externalColor:[1,1,1,1],colorMixMode:"multiply",opacity:1,layerOpacity:1,vertexColors:!1,symbolColors:!1,doubleSided:!1,doubleSidedType:"normal",cullFace:void 0,softwareInstanced:!1,instanced:void 0,instancedDoublePrecision:!1,normals:"default",receiveSSAO:!0,receiveShadows:!1,castShadows:!0,verticalOffset:null,screenSizePerspective:null,slicePlaneEnabled:!1,sliceHighlightDisabled:!1,offsetTransparentBackfaces:!1,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvSizeValue:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],vvSymbolAnchor:[0,0,0],vvSymbolRotationMatrix:a.mat3f64.create(),transparent:!1,writeDepth:!0,textureAlphaMode:"blend",textureAlphaCutoff:c.TEXTURE_ALPHA_CUTOFF_DEFAULT,textureAlphaPremultiplied:!1},D=function(){function e(e,t){this.vertexBufferLayout=e,this.instanceBufferLayout=t}return e.prototype.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},e.prototype.elementCount=function(e){return e.indices.position.length},e.prototype.write=function(e,t,n,i){f.writeDefaultAttributes(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,n,i)},e}(),R=function(e){return e.transparent&&y.separateBlendingParams(770,1,771,771)},T=function(e){return function(e){return e.cullFace?0!==e.cullFace:!e.slicePlaneEnabled&&!e.transparent&&!e.doubleSided}(e)&&{face:1===e.cullFace?1028:1029,mode:2305}},I=s.vec3f64.create(),z=s.vec3f64.create(),L=s.vec3f64.fromValues(0,0,1),E=s.vec3f64.create(),j=s.vec3f64.create(),V=s.vec3f64.create(),N=s.vec3f64.create();return S}).apply(null,i))||(e.exports=r)},UdQa:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("Q2wQ"),n("HZ3d"),n("2Atf"),n("eIBl"),n("xoE+"),n("LxLY"),n("afW+"),n("jBNx"),n("8MXS"),n("FXVB"),n("1m5D"),n("0LE5"),n("Rdxj"),n("qysZ"),n("woUR"),n("5T2R"),n("5T2R"),n("wrIU"),n("Z0CD"),n("aWgr"),n("AzkI"),n("JjCO"),n("ys4y"),n("4ziW"),n("o5p5")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_,S,P,w,A,C,O,M){function D(e,t){var n=v.vec3.subtract(A.sv3d.get(),t.start,e.origin),i=v.vec3.subtract(A.sv3d.get(),t.end,e.origin),r=v.vec3.length(n),a=v.vec3.length(i);return 0===r?0:a/r}function R(e,t,n,i){e.symbolLayers.forEach((function(e,r){var a=t.symbolLayers[r],o=a.heading,s=a.size;"object"===e.type&&(e.heading=(c.isSome(o)?o:0)-g.toDegree(n),c.isSome(s)&&"width"in s&&(e.width=s.width*i,e.depth=s.depth*i,e.height=s.height*i))}))}function T(e,t,n,i){var r=e.start,a=e.end,o=I(r,i,A.sv3d.get()),s=I(a,i,A.sv3d.get());if(v.vec3.squaredDistance(o,s)<S.DRAG_THRESHOLD_PX*S.DRAG_THRESHOLD_PX)return null;var l=v.vec3.subtract(A.sv3d.get(),r,n),c=v.vec3.cross(A.sv3d.get(),l,t),u=r,d=v.vec3.add(A.sv3d.get(),u,c),p=I(n,i,A.sv3d.get()),f=o,h=I(d,i,A.sv3d.get()),m=v.vec3.subtract(A.sv3d.get(),h,f),g=v.vec3.subtract(A.sv3d.get(),o,p),y=P.ray.wrap(f,m),b=P.ray.wrap(p,g);return P.ray.distance2(y,s)<P.ray.distance2(b,s)?"rotate":"scale"}function I(e,t,n){var i=t.projectPoint(e,d.castRenderScreenPointArray(E)),r=t.renderToScreen(i,j);return v.vec3.set(n,r[0],r[1],0)}var z;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.ScaleIn=32,e.ScaleOut=64,e.RotateLeft=128,e.RotateRight=256,e.Highlighted=512,e.Unlocked=1024,e.TouchInput=32768}(z||(z={}));var L=function(){function e(e){var t=this;this.mode=null,this._handles=new s,this._scaleRotateDragData=null,this._activeAnimation=null,this.getFocused=function(){return t.ringManipulator.focused},this.getScale=function(){return c.isSome(t._scaleRotateDragData)&&"scale"===t._scaleRotateDragData.mode?t._scaleRotateDragData.scale:1},this.tool=e.tool,this.mode=e.mode}return e.prototype.destroy=function(){this._clear()},e.prototype._clear=function(){c.isSome(this._activeAnimation)&&(this._activeAnimation.frameTask.remove(),this._activeAnimation=null),this._handles.removeAll(),this.tool.manipulators.remove(this.ringManipulator),this.ringManipulator=null},Object.defineProperty(e.prototype,"dragging",{get:function(){return this.ringManipulator.dragging},enumerable:!0,configurable:!0}),e.prototype.startAnimation=function(e){var t=this;this.cancelActiveAnimation(),e.start();var n=u.addFrameTask({update:function(n){e.update(n.deltaTime)&&t.cancelActiveAnimation()}});this._activeAnimation=o({},e,{frameTask:n})},e.prototype.cancelActiveAnimation=function(){c.isSome(this._activeAnimation)&&(this._activeAnimation.frameTask.remove(),this._activeAnimation.destroy(),this._activeAnimation=null)},e.prototype.recreateManipulators=function(){var e=this;this._clear(),this.ringManipulator=this.createRingManipulator(),this.tool.manipulators.add(this.ringManipulator),_.createDragHandler(this.ringManipulator,(function(t){e._scaleRotateDragData=null;var n=m.vec3f64.fromValues(e.ringManipulator.modelTransform[8],e.ringManipulator.modelTransform[9],e.ringManipulator.modelTransform[10]),i=m.vec3f64.clone(e.ringManipulator.renderLocation),r=P.plane.fromPositionAndNormal(i,n),a=_.createCartesianPlaneDrag(t,e.tool.view,r);if(c.isNone(a))return null;var s=function(e,t){var n=e.allLayerViews.find((function(e){return e.layer===t.layer}));if(c.isNone(t.symbol))return null;var i=t.symbol;return{symbolLayers:i.symbolLayers.map((function(e){var t=null;return"object"===e.type&&(t=e.heading),{heading:t,size:n.getSymbolLayerSize(i,e)}})).toArray()}}(e.tool.view,e.tool.graphic);if(c.isNone(s))return null;var u={mode:"none",origin:i,angle:0,startAngle:e.tool.symbolRotationAngle,angleDir:0,scale:1,scaleDir:0,startSymbolData:s};return e._scaleRotateDragData=u,function(t){var n=a(t),i=b.calculateInputRotationTransform(n.start,n.end,u.origin,r),s=w.cyclicalPI.shortestSignedDiff(u.angle,i);u.angleDir=l.clamp(u.angleDir+s,-S.ROTATE_INDICATOR_DIRECTION_BUFFER,S.ROTATE_INDICATOR_DIRECTION_BUFFER),u.angle=i;var d=D(u,n);if(u.scaleDir=l.clamp(u.scaleDir+(d-u.scale),-S.SCALE_INDICATOR_DIRECTION_BUFFER,S.SCALE_INDICATOR_DIRECTION_BUFFER),u.scale=d,"none"===u.mode){var p=e.mode||T(n,r,u.origin,e.tool.view.state.camera);if(c.isSome(p)){switch(p){case"rotate":e.tool.emit("graphic-rotate-start",{graphic:e.tool.graphic});break;case"scale":e.tool.emit("graphic-scale-start",{graphic:e.tool.graphic})}u.mode=p}}else{if(c.isSome(e.tool.graphic.symbol)){var f=e.tool.graphic.symbol.clone(),h=0,v=1;switch(u.mode){case"scale":v=u.scale;break;case"rotate":h=u.angle}R(f,u.startSymbolData,h,v),e.tool.graphic.symbol=f}if("update"===t.action)switch(u.mode){case"rotate":e.tool.emit("graphic-rotate",{graphic:e.tool.graphic,angle:u.angle,type:"rotate"});break;case"scale":e.tool.emit("graphic-scale",{graphic:e.tool.graphic,scale:u.scale,type:"scale"})}}if("end"===t.action){switch(u.mode){case"rotate":e.tool.emit("graphic-rotate-stop",{graphic:e.tool.graphic});break;case"scale":e.tool.emit("graphic-scale-stop",{graphic:e.tool.graphic});break;default:case"none":}e.startAnimation(function(e){var t=null,n=1,i=function(){return n};return{start:function(){n=e.getScale(),t=e.getScale,e.getScale=i},update:function(t){return n+=((n+1)/2-n)*Math.min(t*S.RING_RESET_ANIMATION_SPEED_FACTOR,1),e.tool.updateManipulators(),Math.abs(n-1)<.01?1:0},destroy:function(){e.getScale=t,e.tool.updateManipulators()}}}(e)),e._scaleRotateDragData=null}return e.tool.updateManipulators(),o({},n,u)}}),(function(e){})),this._handles.add([p.init(this.tool.graphic,"geometry",(function(){x.placeManipulatorAtGraphic(e.ringManipulator,e.tool.graphic)})),this.ringManipulator.events.on("focus",(function(t){"focus"===t.action?e.startAnimation(function(e){var t=0,n=null,i=function(){return!1};return{start:function(){n=e.getFocused,e.getFocused=i,t=0},update:function(n){return t+=n,!e.ringManipulator.focused||t>S.RING_INDICATOR_DELAY_MS?1:0},destroy:function(){e.getFocused=n,e.tool.updateManipulators()}}}(e)):e.tool.updateManipulators()})),this.ringManipulator.events.on("immediate-click",(function(e){e.stopPropagation()})),p.init(this.tool.graphic,["visible","layer.visible"],(function(){e.ringManipulator.visible=e.tool.graphic.visible&&e.tool.graphic.layer.visible}))])},e.prototype.updateManipulators=function(e,t){var n=f.mat4.identity(A.sm4d.get()),i=this.tool.symbolRotationAngle;0!==i&&f.mat4.rotate(n,n,i,m.vec3f64.fromValues(0,0,1));var r=this.getScale(),a=f.mat4.fromScaling(A.sm4d.get(),v.vec3.set(A.sv3d.get(),r,r,r)),o=f.mat4.identity(A.sm4d.get());if(f.mat4.multiply(o,e,a),f.mat4.multiply(o,o,n),this.ringManipulator.modelTransform=o,this.ringManipulator.state=0,this.ringManipulator.state|=!0===t?z.Highlighted:0,this.ringManipulator.state|=c.isSome(this._scaleRotateDragData)&&"none"!==this._scaleRotateDragData.mode?0:z.Unlocked,c.isSome(this._scaleRotateDragData))switch(this._scaleRotateDragData.mode){case"rotate":this.ringManipulator.state|=this._scaleRotateDragData.angleDir<0?z.RotateLeft:z.RotateRight;break;case"scale":this.ringManipulator.state|=this._scaleRotateDragData.scaleDir<0?z.ScaleIn:z.ScaleOut}},e.prototype.createRingManipulator=function(){for(var e=function(e,t,n){for(var i=[],r=Math.ceil(S.GEOMETRY_SEGMENTS*(t-e)/(2*Math.PI)),a=0;a<r+1;a++){var o=e+a*(t-e)/r;i.push(m.vec3f64.fromValues(n*Math.cos(o),n*Math.sin(o),0))}return i},t=function(t){return e(0,2*Math.PI,t)},n=function(e,t){return new C(O.createPathExtrusionGeometry(function(e){return[[-e/2,0],[e/2,0],[e/2,S.RING_HEIGHT/2],[-e/2,S.RING_HEIGHT/2]]}(t),e,[],[],!1),"graphic-transform-ring")},i=t(S.RING_RADIUS),r=n(i,S.RING_THICKNESS),a={left:[],right:[]},o=[],s=0;s<2;s++){var l=(P=s*Math.PI-Math.PI/4)+(w=Math.PI/2-S.ROTATE_INDICATOR_ARC_LENGTH),c=P+Math.PI/2-w,u=n(A=e(l,c,S.INNER_INDICATOR_RADIUS),S.INDICATOR_THICKNESS);o.push(A),a.left.push(u),a.right.push(u);for(var d=0;d<2;d++){var p=0===d,v=h.mat4f64.create();if(p){f.mat4.scale(v,v,[1,-1,1]),f.mat4.rotate(v,v,-l,[0,0,1]);var g=Math.round(S.ROTATE_INDICATOR_ARROW_PLACEMENT_PERCENTAGE*(A.length-1));v[12]=A[g][0],v[13]=A[g][1],v[14]=A[g][2]}else f.mat4.rotate(v,v,c,[0,0,1]),g=Math.round((1-S.ROTATE_INDICATOR_ARROW_PLACEMENT_PERCENTAGE)*(A.length-1)),v[12]=A[g][0],v[13]=A[g][1],v[14]=A[g][2];var b=O.createExtrudedTriangle(S.ROTATE_INDICATOR_ARROW_TIP_LENGTH,0,S.ROTATE_INDICATOR_ARROW_TIP_RADIUS,S.RING_HEIGHT);O.transformInPlace(b,v);var x=new C(b,"graphic-transform-ring-rotate");(p?a.left:a.right).push(x)}}var _=[];for(s=0;s<2;s++){l=(P=s*Math.PI-Math.PI/4)+(w=Math.PI/2-S.SCALE_INDICATOR_ARC_LENGTH),c=P+Math.PI/2-w;var P,w,A=e(l,c,S.OUTER_INDICATOR_RADIUS);_.push(n(A,S.INDICATOR_THICKNESS))}var M=t(S.RING_RADIUS+S.SCALE_INDICATOR_OFFSET1),D=t(S.RING_RADIUS+S.SCALE_INDICATOR_OFFSET2),R=n(M,S.INDICATOR_THICKNESS),T=n(D,S.INDICATOR_THICKNESS),I=t(S.RING_RADIUS-S.SCALE_INDICATOR_OFFSET1),L=t(S.RING_RADIUS-S.SCALE_INDICATOR_OFFSET2),E=n(I,S.INDICATOR_THICKNESS),j=n(L,S.INDICATOR_THICKNESS),V=this.createMaterial(),N=this.createMaterial(.66),F=this.createMaterial(.5),G=this.createMaterial(.33),B=[{geometry:r,material:V,stateMask:z.Highlighted},{geometry:r,material:F}];this.mode&&"scale"!==this.mode||(B=B.concat([{geometry:_,material:V,stateMask:z.Highlighted|z.Unlocked},{geometry:R,material:N,stateMask:z.Highlighted|z.ScaleIn},{geometry:T,material:G,stateMask:z.Highlighted|z.ScaleIn},{geometry:E,material:N,stateMask:z.Highlighted|z.ScaleOut},{geometry:j,material:G,stateMask:z.Highlighted|z.ScaleOut}])),this.mode&&"rotate"!==this.mode||(B=B.concat([{geometry:a.right,material:V,stateMask:z.Highlighted|z.Unlocked},{geometry:a.left,material:V,stateMask:z.Highlighted|z.RotateLeft},{geometry:a.right,material:V,stateMask:z.Highlighted|z.RotateRight}]));var H=[i].concat(o);return new y.Manipulator3D({view:this.tool.view,renderObjects:B,autoScaleRenderObjects:!1,radius:S.RING_THICKNESS,focusMultiplier:1,touchMultiplier:1.5,elevationInfo:{mode:"on-the-ground",offset:0},collisionType:{type:"ribbon",paths:H,direction:m.vec3f64.fromValues(0,0,1)}})},e.prototype.createMaterial=function(e){void 0===e&&(e=1);var t=S.HANDLE_COLOR.concat([e]),n=new M({color:t,transparent:1!==e,cullFace:2},"graphic-transform");return n.renderOccluded=2,n},e}();t.GraphicScaleRotateTransform=L;var E=m.vec3f64.create(),j=d.createScreenPointArray()}).apply(null,i))||(e.exports=r)},VVgn:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){return{environment:{"realisticAtmosphere.frag":"#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/color.glsl>\nuniform vec3 lightingMainDirection;\nuniform vec3 invWavelength;\nuniform vec3 invWavelengthScaled;\nconst float krESun = 0.075;\nconst float kmESun = 0.015;\nuniform vec2 radii;\n#define innerRadius radii[0]\n#define outerRadius radii[1]\nuniform vec4 atmosParams1;\nuniform vec4 atmosParams2;\n#define shellScale atmosParams1.x\n#define shellDepth vec2(atmosParams1.y, atmosParams2.y)\n#define scaleOverScaleDepth vec2(atmosParams1.z, atmosParams2.z)\n#define oneOverScaleDepth vec2(atmosParams1.w, atmosParams2.w)\n#ifndef HAZE\nuniform vec3 atmosParams3;\nuniform float innerFadeDistance;\nuniform float altitudeFade;\n#define g atmosParams2.x\n#define gSq atmosParams3.x\n#define miePhaseCoefficients atmosParams3.y\n#define lowerAlphaBlendBound atmosParams3.z\n#endif\nuniform vec3 cameraPosition;\nuniform vec2 nearFar;\nuniform vec4 sphereComp;\n#define cameraHeight sphereComp[0]\n#define cameraHeightSq sphereComp[1]\n#define C sphereComp[2]\n#define CSur sphereComp[3]\n#ifdef HAZE\nconst float exposure = 1.5;\n#else\nconst float exposure = 2.0;\n#endif\n#ifdef HAZE\nuniform sampler2D depthTex;\n#endif\nvarying vec3 eyeDir;\nvarying vec3 worldRay;\nvarying vec2 vtc;\nconst float samples = 5.0;\nconst int maxSamples = 5;\n#ifdef HAZE\n  const vec3 oneOverGamma = vec3(1.0);\n#else\n  const vec3 oneOverGamma = vec3(0.454545);\n#endif\nvec3 expTM(vec3 inputColor,float _exposure) {\n    return pow(1.0 - exp(inputColor * -_exposure), oneOverGamma);\n}\n#ifndef HAZE\nvec3 reinhardTM(vec3 inputColor, float _exposure) {\n  vec3 intermediate = inputColor * _exposure;\n  intermediate /= ( 1.0 + intermediate );\n  return pow(intermediate, oneOverGamma);\n}\n#endif\nfloat scale(float _cos) {\n  float x = 1.0 - _cos;\n  return exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * (-6.80 + x * 5.25 ))));\n}\nvoid main() {\n  vec3 worldSpaceRay = normalize(worldRay);\n  float B = 2.0 * dot(cameraPosition, worldSpaceRay);\n  float det = B * B - 4.0 * C;\n  float detSur = B * B - 4.0 * CSur;\n  float minRayStart = 0.0;\n#ifndef HAZE\n  float surfaceBlend = 0.0;\n  vec4 surfaceColor = vec4(0.0);\n  if (detSur >= 0.0) {\n    float nearSurface = max(0.0, 0.5 *(-B - sqrt(detSur)));\n    float farSurface = max(0.0, 0.5 *(-B + sqrt(detSur)));\n    if (nearSurface == 0.0) {\n      minRayStart = farSurface;\n    }\n    vec3 vPos = cameraPosition + worldSpaceRay * nearSurface;\n    float lightAngle = dot(-lightingMainDirection, normalize(vPos));\n    float brightness = max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)));\n    surfaceColor = vec4(brightness, brightness, brightness, 1.0 - altitudeFade);\n    float relDist = (farSurface - nearSurface) / innerFadeDistance;\n    if (relDist > 1.0) {\n      gl_FragColor = surfaceColor;\n      return;\n    }\n    surfaceBlend = smoothstep(0.0, 1.0, relDist * relDist);\n  }\n#endif\n  if (det >= 0.0) {\n#ifdef HAZE\n    float depthSample = texture2D(depthTex, vtc).r;\n    float zNear = nearFar[0];\n    float zFar = nearFar[1];\n    float zNorm = 2.0 * depthSample - 1.0;\n    float linDepth = 2.0 * zNear * zFar /\n      (zFar + zNear - zNorm * (zFar - zNear));\n    float rayEnd;\n    float altitudeAlpha = 1.0;\n    if (depthSample < 1.0 && depthSample > 0.0) {\n      vec3 cameraSpaceRay = normalize(eyeDir);\n      cameraSpaceRay /= cameraSpaceRay.z;\n      cameraSpaceRay *= linDepth;\n      float cameraSpaceRayLength = length(cameraSpaceRay);\n      vec3 world = cameraPosition + worldSpaceRay * cameraSpaceRayLength;\n      float worldRadiusSq = dot(world, world);\n      float transitionStart = innerRadius + 20000.0;\n      float transitionHeight = 25000.0;\n      float transitionEnd = transitionStart + transitionHeight;\n      float edge0 = transitionStart * transitionStart;\n      float edge1 = transitionEnd * transitionEnd;\n      altitudeAlpha = 1.0 - clamp((worldRadiusSq - edge0) / (edge1 - edge0), 0.0, 1.0);\n      rayEnd = cameraSpaceRayLength;\n      if (altitudeAlpha > 0.0 && detSur > 0.0) {\n        float nearSurface = 0.5 * ( -B - sqrt(detSur) );\n        float interp = clamp(((cameraHeight - innerRadius) - 2000000.0) / 6000000.0, 0.0, 1.0);\n        rayEnd = mix(cameraSpaceRayLength, nearSurface, interp);\n      }\n    }\n#endif\n    float rayStart = 0.5 *(-B - sqrt(det));\n#ifdef HAZE\n    float near = abs(rayStart);\n    float far = abs(rayEnd);\n#else\n    float rayEnd = 0.5 *(-B + sqrt(det));\n#endif\n    float scatterDistance;\n    if (rayStart < minRayStart)\n    {\n      rayStart = minRayStart;\n#ifndef HAZE\n      scatterDistance = shellScale * min(0.0, innerRadius - cameraHeight);\n#endif\n    }\n#ifndef HAZE\n    else\n    {\n      scatterDistance = -1.0;\n    }\n#endif\n    vec3 start = cameraPosition + worldSpaceRay * rayStart;\n#ifdef HAZE\n    vec3 end = cameraPosition + worldSpaceRay * rayEnd;\n    float endLength = length(end);\n    float altitudeEnd = endLength - innerRadius;\n    float altitudeStart = length(start) - innerRadius;\n    if (altitudeStart < 0.0) {\n      altitudeStart = -altitudeStart;\n      altitudeEnd = -altitudeEnd;\n    }\n    float lightAngle = dot(-lightingMainDirection, end) / endLength;\n    if (near > far)\n    {\n      if (altitudeStart < altitudeEnd)\n      {\n        end = cameraPosition + worldSpaceRay * rayStart;\n        start = cameraPosition + worldSpaceRay * rayEnd;\n        worldSpaceRay *= -1.0;\n        float tmp = altitudeStart;\n        altitudeStart = altitudeEnd;\n        altitudeEnd = tmp;\n      }\n      else if (altitudeStart == altitudeEnd)\n      {\n        altitudeStart += 1.0;\n      }\n    }\n    if (altitudeStart > outerRadius - innerRadius)\n    {\n      scatterDistance = innerRadius - outerRadius;\n    } else\n    {\n      scatterDistance = altitudeEnd - altitudeStart;\n    }\n#endif\n    vec2 opticalStartDepth = exp(scatterDistance * oneOverScaleDepth);\n    float rayLength = rayEnd - rayStart;\n    float sampleLength = rayLength / samples;\n    float scaledLength = sampleLength * shellScale;\n    vec3 sampleRay = worldSpaceRay * sampleLength;\n    vec3 samplePoint = start + sampleRay * 0.5;\n#ifdef HAZE\n    float cameraAngle = dot(-worldSpaceRay, end) / length(end);\n    float scaleCameraAngle = scale(cameraAngle);\n    vec2 cameraOffset = scaleCameraAngle * opticalStartDepth;\n    float scaledValues = scale(lightAngle) + scaleCameraAngle;\n    vec2 scaledValuesDepth = scaledValues * shellDepth;\n#else\n    float cameraAngle = dot(worldSpaceRay, start / length(start));\n    float angleMultiplier = cameraAngle > 0.0 ? cameraAngle : 0.0;\n    float scaleCameraAngle = scale(cameraAngle);\n    vec2 cameraOffset = scaleCameraAngle * opticalStartDepth * shellDepth;\n#endif\n    vec3 frontColor = vec3(0.0);\n    vec3 frontColorBlue = vec3(0.0);\n    vec3 attenuate = vec3(0.0);\n    vec3 attenuateBlue = vec3(0.0);\n    for(int i=0; i<maxSamples; i++) {\n      float height = length(samplePoint);\n      float altitude = abs(height - innerRadius);\n      vec2 depth = exp(-altitude * scaleOverScaleDepth);\n#ifdef HAZE\n      vec2 scatter = depth * scaledValuesDepth - cameraOffset;\n#else\n      float lightAngle = dot(-lightingMainDirection, samplePoint) / height;\n      float cameraAngle = dot(worldSpaceRay, samplePoint) / height;\n      float tmpScaledValues = scale(lightAngle) - scale(cameraAngle);\n      vec2 scatter = cameraOffset + tmpScaledValues * depth * shellDepth;\n#endif\n      attenuate = exp(-scatter.x * invWavelengthScaled);\n      attenuateBlue = exp(-scatter.y * invWavelengthScaled);\n      frontColor += attenuate * depth.x;\n      frontColorBlue += attenuateBlue * depth.y;\n      samplePoint += sampleRay;\n    }\n    float LdotR = clamp(dot(-lightingMainDirection, -worldSpaceRay ),-0.9999999,1.0);\n    float LdotRSq = LdotR * LdotR + 1.0;\n#ifdef HAZE\n    vec3 colorCoefficients = (scaledLength * 0.75 * LdotRSq) * (krESun * invWavelength + kmESun );\n    vec3 color = colorCoefficients * frontColor;\n    vec3 colorBlue = colorCoefficients * frontColorBlue;\n#else\n    vec3 rayleighCoefficients = (scaledLength * 0.75 * LdotRSq * krESun) * invWavelength;\n    float mieCoefficients = scaledLength * kmESun * miePhaseCoefficients * LdotRSq / pow(1.0 + gSq - 2.0 * g * LdotR, 1.5);\n    vec3 color = rayleighCoefficients * frontColor + mieCoefficients * frontColor;\n    vec3 colorBlue = rayleighCoefficients * frontColorBlue + mieCoefficients * frontColorBlue;\n#endif\n    vec3 ldrBlue = expTM(colorBlue, 2.0 * exposure);\n    vec3 ldrRed = expTM(color, exposure);\n    vec3 LDR = mix(ldrBlue, ldrRed, 0.2);\n#ifdef HAZE\n    LDR *= (1.0 - cameraAngle);\n    vec3 hsv = rgb2hsv(LDR);\n    hsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\n    LDR = hsv2rgb(hsv);\n    vec3 finalColor = LDR;\n#else\n    vec3 ldrReinhard = reinhardTM(color, exposure);\n    LDR += angleMultiplier * ldrReinhard;\n    float side = (rayEnd + rayStart) * 0.5;\n    float atmoHeight = sqrt(cameraHeightSq - side * side);\n    float h2 = clamp(1.0 - ( atmoHeight - lowerAlphaBlendBound ) / ( outerRadius - lowerAlphaBlendBound ), 0.0, 1.0);\n    vec3 finalColor = LDR * h2;\n    vec3 hsv = rgb2hsv(finalColor);\n    hsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\n    finalColor = hsv2rgb(hsv);\n#endif\n#ifndef HAZE\n    float atmosStrength = clamp((length(ldrRed) - 0.05) * 1.05, 0.0, 1.0);\n    gl_FragColor = vec4(finalColor, atmosStrength * clamp(1.0 - ( atmoHeight - innerRadius ) / (outerRadius - innerRadius), 0.0, 1.0));\n    if (surfaceBlend > 0.0) {\n      gl_FragColor = mix(gl_FragColor, surfaceColor, surfaceBlend);\n    }\n#else\n    gl_FragColor = vec4(finalColor, 1.0) * altitudeAlpha;\n#endif\n  } else {\n    gl_FragColor = vec4(0.0);\n  }\n}","realisticAtmosphere.vert":"#include <util/vsPrecision.glsl>\nuniform vec2 halfSizeNearPlane;\nuniform vec3 cameraUp;\nuniform vec3 cameraRight;\nuniform vec3 cameraDir;\nuniform vec2 cameraCenterOffset;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 worldRay;\nvarying vec2 vtc;\n#ifdef HAZE\nvarying vec3 eyeDir;\n#endif\nvoid main(void) {\n  vec3 v3Pos = position;\n  vtc = uv0;\n  vec2 rayvtc = uv0 - cameraCenterOffset;\n#ifdef HAZE\n  eyeDir = vec3((2.0 * halfSizeNearPlane * rayvtc) - halfSizeNearPlane, -1.0);\n#else\n  vec3 eyeDir = vec3((2.0 * halfSizeNearPlane * rayvtc) - halfSizeNearPlane, -1.0);\n#endif\n  worldRay = eyeDir.z * cameraDir + eyeDir.y * cameraUp + eyeDir.x * cameraRight;\n  gl_Position = vec4(v3Pos, 1.0);\n}","simpleAtmosphere.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvarying float falloff;\n#ifndef PANORAMIC\nuniform float altitudeFade;\nvarying float innerFactor;\n#endif\nvoid main() {\n  vec4 texColor = texture2D(tex, vtc);\n#ifdef PANORAMIC\n  gl_FragColor = texColor * falloff;\n#else\n  vec4 atmosphereColor = texColor * falloff;\n  vec4 innerColor = vec4(texColor.rgb * falloff, 1.0 - altitudeFade);\n  gl_FragColor = mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));\n#endif\n}","simpleAtmosphere.vert":"#include <util/vsPrecision.glsl>\n#include <util/transform.glsl>\nuniform mat4 proj;\nuniform mat4 view;\n#ifndef PANORAMIC\nconst float TWICEPI = 2.0*3.14159265;\nconst float ATMOSPHERE_RIM_SEGMENTS = 128.0;\nuniform vec3 silCircleCenter;\nuniform vec3 silCircleV1;\nuniform vec3 silCircleV2;\nuniform vec2 texV;\nuniform float innerScale;\nvarying float innerFactor;\n#endif\nuniform vec3 lightingMainDirection;\nattribute vec3 position;\nvarying vec2 vtc;\nvarying float falloff;\nvoid main(void) {\n  vec3 lightDirection = -lightingMainDirection;\n#ifdef PANORAMIC\n  vec3 pos = position;\n  float ndotl = lightDirection.z;\n  vtc = vec2(0.0, position.z+0.05);\n#else\n  innerFactor = clamp(-position.z, 0.0, 1.0);\n  float scale = position.y * (1.0 + innerFactor * innerScale);\n  float phi = position.x * (TWICEPI / ATMOSPHERE_RIM_SEGMENTS) + 1.0;\n  vec3 pos =  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;\n  float ndotl = dot(normalize(position.y > 0.0 ? pos: silCircleCenter), lightDirection);\n  vtc.x = position.x / ATMOSPHERE_RIM_SEGMENTS;\n  vtc.y = texV.x * (1.0 - position.z) + texV.y * position.z;\n#endif\n  falloff = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  gl_Position = transformPosition(proj, view, pos);\n  gl_Position.z = gl_Position.w;\n}","simpleAtmosphereFade.frag":"#include <util/fsPrecision.glsl>\nvarying vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}","simpleAtmosphereFade.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nuniform vec3 lightingMainDirection;\nuniform vec3 cameraPosition;\nuniform float undergroundFadeAlpha;\nvarying vec4 color;\nvoid main(void) {\n  float ndotl = dot(normalize(cameraPosition), -lightingMainDirection);\n  float lighting = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  color = vec4(vec3(lighting), undergroundFadeAlpha);\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}","stars.frag":"#include <util/fsPrecision.glsl>\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main() {\n  float cap = 0.7;\n  float scale = 1.0/cap;\n  float helper = clamp(length(abs(gl_PointCoord-vec2(0.5))),0.0,cap);\n  float alpha = clamp((cap-helper)*scale,0.0,1.0);\n  float intensity = alpha*alpha*alpha;\n  if (vsize < 3.0)\n    intensity *= 0.5;\n  gl_FragColor = vec4(1.0,1.0,1.0,intensity);\n  gl_FragColor.xyz *= vcolor.xyz;\n}","stars.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec4 viewport;\nuniform float pixelRatio;\nattribute vec3 position;\nattribute vec4 color;\nattribute float size;\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main(void) {\n  vec4 posProj = proj * view * model*vec4(position*1.0e25,1.0);\n  gl_Position = alignToPixelCenter(posProj, viewport.zw);\n  gl_Position.z = gl_Position.w;\n  vcolor = color / 1.2;\n  vsize = size * 5.0 * pixelRatio;\n  gl_PointSize = vsize;\n}"},materials:{hud:{"colorPass.frag":"#include <materials/hud/hudHeader.glsl>\nvoid main() {\n#include <materials/hud/hudMain.glsl>\n}","highlightPass.frag":"#include <materials/hud/hudHeader.glsl>\n#include <util/highlight.glsl>\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvoid main() {\n#include <materials/hud/hudMain.glsl>\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\n  if (voccluded == 1.0) {\n    gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n  } else {\n    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n  }\n#else\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n#endif\n}","hud.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/visualVariables.glsl>\n#include <util/slice.glsl>\nuniform vec2 screenOffset;\nuniform vec2 anchorPos;\nuniform vec2 textureCoordinateScaleFactor;\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspective;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif\nattribute vec2 uv0;\nattribute vec4 color;\nattribute vec2 size;\nattribute vec4 auxpos2;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 posProj = projectPositionHUD(projectAux);\n  if (rejectBySlice(projectAux.posModel)) {\n    gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    return;\n  }\n  vec2 inputSize;\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n  vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n#else\n  inputSize = size;\n  vec2 screenOffsetScaled = screenOffset;\n#endif\n#ifdef VV_SIZE\n  inputSize *= vvGetScale(auxpos2).xx;\n#endif\n  vec2 combinedSize = inputSize * pixelRatio;\n  vec4 quadOffset = vec4(0.0);\n#if defined(OCCL_TEST) || defined(BINARY_HIGHLIGHT_OCCLUSION)\n  bool visible = testVisibilityHUD(posProj);\n#endif\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvoccluded = visible ? 0.0 : 1.0;\n#endif\n#ifdef OCCL_TEST\n  if (visible) {\n#endif\n    vec2 uv01 = floor(uv0);\n    vec2 uv = uv0 - uv01;\n    quadOffset.xy = ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\n#ifdef SIGNED_DISTANCE_FIELD\n    posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\n#else\n    posProj += quadOffset;\n    if (inputSize.x == size.x) {\n      posProj = alignToPixelOrigin(posProj, viewport.zw);\n    }\n#endif\n    gl_Position = posProj;\n    vtc = uv * textureCoordinateScaleFactor;\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords = vec4(uv01, 1.5 / combinedSize);\n#endif\n    vsize = inputSize;\n#ifdef OCCL_TEST\n  } else {\n    vtc = vec2(.0);\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);\n#endif\n  }\n#endif\n  gl_Position = posProj;\n#ifdef VV_COLOR\n  vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors);\n#else\n  vcolor = color / 255.0;\n#endif\n}","hudHeader.glsl":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/color.glsl>\nuniform sampler2D tex;\nuniform vec4 overrideColor;\nuniform vec4 outlineColor;\nuniform float outlineSize;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif","hudMain.glsl":"#ifdef SIGNED_DISTANCE_FIELD\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 fillPixelColor = overrideColor * vcolor;\n  const float txSize = 128.0;\n  const float texelSize = 1.0 / txSize;\n  vec2 scaleFactor = (vsize - txSize) * texelSize;\n  vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\n  float d = rgba2float(texture2D(tex, samplePos)) - 0.5;\n  float dist = d * vsize.x;\n  fillPixelColor.a *= clamp(0.5 - dist, 0.0, 1.0);\n  if (outlineSize > 0.25) {\n    vec4 outlinePixelColor = outlineColor;\n    float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n    outlinePixelColor.a *= clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n    float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n      vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    gl_FragColor = vec4(compositeColor, compositeAlpha);\n  }\n  else {\n    gl_FragColor = premultiplyAlpha(fillPixelColor);\n  }\n#else\n  gl_FragColor = texture2D(tex, vtc, -0.5) * premultiplyAlpha(overrideColor * vcolor);\n#endif\n#ifdef DEBUG_DRAW_BORDER\n   float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));\n   gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);\n#endif\n  if (gl_FragColor.a < 0.1) {\n    discard;\n  }","occlusionTest.frag":"#include <util/fsPrecision.glsl>\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}","occlusionTest.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/slice.glsl>\nvoid main(void) {\n  vec4 posProjCenter;\n  if (dot(position, position) > 0.0) {\n    ProjectHUDAux projectAux;\n    vec4 posProj = projectPositionHUD(projectAux);\n    posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n    vec3 vpos = projectAux.posModel;\n    if (rejectBySlice(vpos)) {\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n  }\n  else {\n    posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n  }\n  gl_Position = posProjCenter;\n  gl_PointSize = 1.0;\n}"},lineCallout:{"lineCallout.frag":"#include <util/fsPrecision.glsl>\nuniform vec4 color;\nuniform vec4 borderColor;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main() {\n  vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n  float borderAlpha = color.a * borderColor.a * coverage.y;\n  float colorAlpha = color.a * coverage.x;\n  float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n#ifdef DEPTH_HUD\n  if (finalAlpha < 0.01) {\n    discard;\n  }\n#else\n  vec3 finalRgb = mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);\n  gl_FragColor = vec4(finalRgb, finalAlpha);\n#endif\n}","lineCallout.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/slice.glsl>\nattribute vec2 uv0;\nuniform float lineSize;\nuniform vec2 pixelToNDC;\nuniform float borderSize;\nuniform vec2 screenOffset;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 endPoint = projectPositionHUD(projectAux);\n  vec3 vpos = projectAux.posModel;\n  if (rejectBySlice(vpos)) {\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#ifdef OCCL_TEST\n  if (!testVisibilityHUD(endPoint)) {\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n  vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n#else\n  vec2 screenOffsetScaled = screenOffset;\n#endif\n  vec3 posView = (view * (model * vec4(position, 1.0))).xyz;\n  applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n  vec4 startPoint = proj * vec4(posView, 1.0);\n  vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n  startPoint.xy += screenOffsetNorm * startPoint.w;\n  endPoint.xy += screenOffsetNorm * endPoint.w;\n  vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n  vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n#ifdef DEPTH_HUD\n#ifdef DEPTH_HUD_ALIGN_START\n  endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\n#else\n  startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\n#endif\n#endif\n  vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n  vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n  vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n  float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n#else\n  float lineSizeScaled = lineSize;\n  float borderSizeScaled = borderSize;\n#endif\n  float halfPixelSize = lineSizeScaled * 0.5;\n  float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n  float halfPixelSizeInt = floor(halfWholePixelSize);\n  float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n  float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n  float padding = 1.0 + borderSizeScaled;\n  vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n  projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n  float edgeDirection = (uv0.x * 2.0 - 1.0);\n  float halfBorderSize = 0.5 * borderSizeScaled;\n  float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n  float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n  float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n  coverageSampling = vec4(\n    outerEdgeCoverageSampler,\n    outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n    halfPixelSize - 0.5,\n    halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n  );\n  lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n  gl_Position = projectedPosition;\n}"},measurementArrow:{"measurementArrow.frag":"#include <util/fsPrecision.glsl>\nuniform float outlineSize;\nuniform vec4 outlineColor;\nuniform float stripeLength;\nuniform vec4 stripeEvenColor;\nuniform vec4 stripeOddColor;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\n#define INV_SQRT2 (1.0 / sqrt(2.0))\nvec4 arrowColor(vec2 tc, float len) {\n  float d = INV_SQRT2 * (tc.x - abs(tc.y));\n  d = min(d, INV_SQRT2 * (len - tc.x - abs(tc.y)));\n  d = min(d, 1.0 - abs(tc.y));\n  if (d < 0.0) {\n    return vec4(0.0);\n  } else if (d < outlineSize) {\n    return outlineColor;\n  } else {\n    return fract(0.5 / stripeLength * tc.x * vradius) >= 0.5 ? stripeOddColor : stripeEvenColor;\n  }\n}\nvoid main(void) {\n  vec2 ntc = vec2(vtc.x / vradius, vtc.y);\n  vec4 color = arrowColor(ntc, vlength / vradius);\n  if (color.a == 0.0) {\n    discard;\n  }\n  gl_FragColor = color;\n}","measurementArrow.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform float width;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv0;\nattribute float auxpos1;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\nvoid main(void) {\n  vec3 bitangent = normal;\n  vtc = uv0;\n  vlength = auxpos1;\n  vradius = 0.5 * width;\n  vec4 pos = view * vec4((model * vec4(position + vradius * bitangent * uv0.y, 1.0)).xyz, 1.0);\n  gl_Position = proj * pos;\n}"},slicePlane:{"slicePlane.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\nuniform vec4 backgroundColor;\nuniform vec4 gridColor;\nuniform float ratio;\nuniform float gridWidth;\nvarying vec2 vUV;\nvoid main() {\n  const float LINE_WIDTH = 1.0;\n  vec2 uvScaled = vUV * gridWidth;\n  vec2 gridUV = (fract(uvScaled + 0.5) - 0.5) / (LINE_WIDTH * fwidth(uvScaled));\n  vec2 grid = (1.0 - step(0.5, gridUV)) * step(-0.5, gridUV);\n  grid.x *= step(0.5, uvScaled.x) * step(uvScaled.x, gridWidth - 0.5);\n  grid.y *= step(0.5, uvScaled.y) * step(uvScaled.y, gridWidth - 0.5);\n  float gridFade = max(grid.x, grid.y);\n  float gridAlpha = gridColor.a * gridFade;\n  gl_FragColor =\n    vec4(backgroundColor.rgb * backgroundColor.a, backgroundColor.a) * (1.0 - gridAlpha) +\n    vec4(gridColor.rgb, 1.0) * gridAlpha;\n}","slicePlane.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec2 vUV;\nvoid main(void) {\n  vUV = uv0;\n  gl_Position = proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\n}"}},pointRenderer:{"pointRenderer.frag":"#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#ifdef HIGHLIGHT_PASS\n#include <util/highlight.glsl>\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\n#endif\n#ifdef DEPTH_PASS\nvarying float depth;\n#elif defined(HIGHLIGHT_PASS)\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);\n  float r2 = dot(vOffset, vOffset);\n  if (r2 > 0.25) {\n    discard;\n  }\n#ifdef DEPTH_PASS\n  gl_FragColor = float2rgba(depth);\n#elif defined(HIGHLIGHT_PASS)\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n#else\n  gl_FragColor = vec4(vColor, 1.0);\n#endif\n}","pointRenderer.vert":"#include <util/slice.glsl>\n#include <util/vsPrecision.glsl>\nattribute vec3 aPosition;\nattribute vec3 aColor;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform vec2 uScreenMinMaxSize;\nuniform vec2 uPointScale;\nuniform vec3 uClipMin;\nuniform vec3 uClipMax;\n#ifdef DEPTH_PASS\nuniform vec2 nearFar;\nvarying float depth;\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  if (aPosition.x < uClipMin.x || aPosition.y < uClipMin.y || aPosition.z < uClipMin.z ||\n      aPosition.x > uClipMax.x || aPosition.y > uClipMax.y || aPosition.z > uClipMax.z) {\n    gl_Position = vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize = 0.0;\n    return;\n  }\n  if (rejectBySlice(aPosition)) {\n    gl_Position = vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize = 0.0;\n    return;\n  }\n  vec4 camera = uModelViewMatrix * vec4(aPosition, 1.0);\n  float pointSize = uPointScale.x;\n  vec4 position = uProjectionMatrix * camera;\n#ifdef DRAW_SCREEN_SIZE\n    float clampedScreenSize = pointSize;\n#else\n    float pointRadius = 0.5 * pointSize;\n    vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);\n    vec4 positionOffset = uProjectionMatrix * cameraOffset;\n    float radius = abs(positionOffset.y - position.y);\n    float viewHeight = uPointScale.y;\n    float screenPointSize = (radius / position.w) * viewHeight;\n    float clampedScreenSize = clamp(screenPointSize, uScreenMinMaxSize.x, uScreenMinMaxSize.y);\n    camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;\n    position = uProjectionMatrix * camera;\n#endif\n  gl_PointSize = clampedScreenSize;\n  gl_Position = position;\n#ifdef DEPTH_PASS\n  depth = (-camera.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n#else\n  vColor = aColor;\n#endif\n}"},renderer:{highlight:{"apply.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nuniform sampler2D origin;\nuniform vec4 color;\nuniform vec4 haloColor;\nuniform float outlineSize;\nuniform float blurSize;\nuniform vec4 opacities;\nvarying vec2 uv;\nvoid main() {\n  #if defined(GRID_OPTIMIZATION) && defined(GRID_DEBUG)\n    gl_FragColor = vec4(uv, 0.0, 1.0);\n  #else\n    vec4 blurredHighlightValue = texture2D(tex, uv);\n    float highlightIntensity = blurredHighlightValue.a;\n    if (highlightIntensity == 0.0) {\n      discard;\n    }\n    vec4 origin_color = texture2D(origin, uv);\n    float outlineIntensity;\n    float fillIntensity;\n    if (blurredHighlightValue.g > blurredHighlightValue.b) {\n      outlineIntensity = haloColor.w * opacities[1];\n      fillIntensity = color.w * opacities[3];\n    }\n    else {\n      outlineIntensity = haloColor.w * opacities[0];\n      fillIntensity = color.w * opacities[2];\n    }\n    float inner = 1.0 - outlineSize / 9.0;\n    float outer = 1.0 - (outlineSize + blurSize) / 9.0;\n    float outlineFactor = smoothstep(outer, inner, highlightIntensity);\n    float fillFactor = any(notEqual(origin_color, vec4(0.0, 0.0, 0.0, 0.0))) ? 1.0 : 0.0;\n    float intensity = outlineIntensity * outlineFactor * (1.0 - fillFactor) + fillIntensity * fillFactor;\n    gl_FragColor = vec4(mix(haloColor.rgb, color.rgb, fillFactor), intensity);\n  #endif\n}","apply.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 uv;\n#ifdef GRID_OPTIMIZATION\n  attribute vec2 uv0;\n  uniform sampler2D coverageTex;\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    #ifdef GRID_DEBUG\n      vec4 cov = texture2D(coverageTex, uv0);\n      if (cov.r == 0.0 || cov.g == 1.0 || cov.b == 1.0) {\n        gl_Position = vec4(0.0);\n        return;\n      }\n      gl_Position = vec4(position, .0, 1.0);\n      uv = uv0;\n      return;\n    #else\n      vec4 cov = texture2D(coverageTex, uv0);\n      if (cov.r == 0.0) {\n        gl_Position = vec4(0.0);\n        return;\n      }\n    #endif\n  #endif\n  gl_Position = vec4(position, .0, 1.0);\n  uv = position.xy * .5 + vec2(.5);\n}","blur.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\n#ifdef GRID_OPTIMIZATION\n  uniform vec2 blurSize;\n  varying vec3 blurCoordinate;\n#else\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    vec2 uv = blurCoordinate.xy;\n    vec4 center = texture2D(tex, uv);\n    if (blurCoordinate.z == 1.0) {\n      gl_FragColor = center;\n    }\n    else {\n      vec4 sum = vec4(0.0);\n      #if GAUSSIAN_SAMPLES == 3\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n      #elif GAUSSIAN_SAMPLES == 5\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n      #elif GAUSSIAN_SAMPLES == 7\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv + blurSize * 5.1) * 0.03;\n        sum += texture2D(tex, uv - blurSize * 5.1) * 0.03;\n      #elif GAUSSIAN_SAMPLES == 9\n        sum += center * 0.154164;\n        sum += texture2D(tex, uv + blurSize * 1.5) * 0.204005;\n        sum += texture2D(tex, uv - blurSize * 1.5) * 0.204005;\n        sum += texture2D(tex, uv + blurSize * 3.5) * 0.123913;\n        sum += texture2D(tex, uv - blurSize * 3.5) * 0.123913;\n        sum += texture2D(tex, uv + blurSize * 5.5) * 0.123913;\n        sum += texture2D(tex, uv - blurSize * 5.5) * 0.123913;\n        sum += texture2D(tex, uv + blurSize * 7.5) * 0.05;\n        sum += texture2D(tex, uv - blurSize * 7.5) * 0.05;\n      #endif\n      gl_FragColor = sum;\n    }\n  #else\n    vec4 sum = vec4(0.0);\n    #if GAUSSIAN_SAMPLES == 3\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n    #elif GAUSSIAN_SAMPLES == 5\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n    #elif GAUSSIAN_SAMPLES == 7\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[5]) * 0.03;\n      sum += texture2D(tex, blurCoordinates[6]) * 0.03;\n    #elif GAUSSIAN_SAMPLES == 9\n      sum += texture2D(tex, blurCoordinates[0]) * 0.154164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.204005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.204005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.123913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.123913;\n      sum += texture2D(tex, blurCoordinates[5]) * 0.09;\n      sum += texture2D(tex, blurCoordinates[6]) * 0.09;\n      sum += texture2D(tex, blurCoordinates[7]) * 0.05;\n      sum += texture2D(tex, blurCoordinates[8]) * 0.05;\n    #endif\n    gl_FragColor = sum;\n  #endif\n}","blur.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nattribute vec2 uv0;\n#ifdef GRID_OPTIMIZATION\n  uniform sampler2D coverageTex;\n  varying vec3 blurCoordinate;\n#else\n  uniform vec2 blurSize;\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n  #ifdef GRID_OPTIMIZATION\n    vec4 cov = texture2D(coverageTex, uv0);\n    if (cov.r == 0.0) {\n      gl_Position = vec4(0.0);\n    }\n    blurCoordinate = vec3(gl_Position.xy * .5 + vec2(.5), max(cov.g, cov.b));\n  #else\n    vec2 uv = position.xy * .5 + vec2(.5);\n    #if GAUSSIAN_SAMPLES == 3\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n    #elif GAUSSIAN_SAMPLES == 5\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n    #elif GAUSSIAN_SAMPLES == 7\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n      blurCoordinates[5] = uv + blurSize * 5.1;\n      blurCoordinates[6] = uv - blurSize * 5.1;\n    #elif GAUSSIAN_SAMPLES == 9\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n      blurCoordinates[5] = uv + blurSize * 5.1;\n      blurCoordinates[6] = uv - blurSize * 5.1;\n      blurCoordinates[7] = uv + blurSize * 7.1;\n      blurCoordinates[8] = uv - blurSize * 7.1;\n    #endif\n  #endif\n}","downsample.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nuniform vec2 invFramebufferDim;\nvoid main() {\n  vec2 coord = gl_FragCoord.xy * invFramebufferDim;\n  vec4 value = texture2D(tex, coord);\n  float mx = floor(max(value.g, value.b));\n  gl_FragColor = vec4(ceil(value.r), mx, mx, 1.0);\n}","downsample.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvoid main() {\n  gl_Position = vec4(vec2(1.0) - position * 2.0, .0, 1.0);\n}"},laserLine:{"laserLine.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/depth.glsl>\nuniform sampler2D depthMap;\nuniform vec2 nearFar;\nuniform vec4 projInfo;\nuniform vec2 zScale;\nuniform float maxPixelDistance;\nuniform vec4 focusPlane;\nuniform vec4 focusSphere;\nuniform vec4 segmentPlane;\nuniform vec3 segmentStart;\nuniform vec3 segmentEnd;\nuniform vec3 glowColor;\nuniform float glowWidth;\nuniform vec3 innerColor;\nuniform float innerWidth;\nuniform float globalAlpha;\nvarying vec2 uv;\n#define INFINITY 100000.0\nvec3 reconstructPosition(vec2 fragCoord, float depth) {\n  return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);\n}\nfloat planeDistancePixels(vec4 plane, vec3 pos) {\n  float dist = dot(plane.xyz, pos) + plane.w;\n  float width = fwidth(dist);\n  dist /= min(width, maxPixelDistance);\n  return abs(dist);\n}\nfloat sphereDistancePixels(vec4 sphere, vec3 pos) {\n  float dist = distance(sphere.xyz, pos) - sphere.w;\n  float width = fwidth(dist);\n  dist /= min(width, maxPixelDistance);\n  return abs(dist);\n}\nvec4 blendPremultiplied(vec4 source, vec4 dest) {\n  float oneMinusSourceAlpha = 1.0 - source.a;\n  return vec4(\n    source.rgb + dest.rgb * oneMinusSourceAlpha,\n    source.a + dest.a * oneMinusSourceAlpha\n  );\n}\nvec4 premultipliedColor(vec3 rgb, float alpha) {\n  return vec4(rgb * alpha, alpha);\n}\nvec4 laserLineProfile(float dist) {\n  if (dist > glowWidth) {\n    return vec4(0.0);\n  }\n  float innerAlpha = (1.0 - smoothstep(0.0, innerWidth, dist));\n  float glowAlpha = pow(max(0.0, 1.0 - dist / glowWidth), 8.0);\n  return blendPremultiplied(\n    premultipliedColor(innerColor, innerAlpha),\n    premultipliedColor(glowColor, glowAlpha)\n  );\n}\nvoid main() {\n  float depth = linearDepth(depthMap, uv, nearFar);\n  if (-depth == nearFar[0]) {\n    discard;\n  }\n  vec3 pos = reconstructPosition(gl_FragCoord.xy, depth);\n  float ddepth = fwidth(depth);\n  float depthDiscontinuityAlpha = 1.0 - smoothstep(0.0, 0.01, -ddepth / depth);\n  vec3 normal = normalize(cross(dFdx(pos), dFdy(pos)));\n  float focusPlaneDistance = planeDistancePixels(focusPlane, pos);\n  float focusSphereDistance = sphereDistancePixels(focusSphere, pos);\n  float segmentDistance = INFINITY;\n  float segmentLength = length(segmentEnd - segmentStart);\n  vec3 segmentDir = (segmentEnd - segmentStart) / segmentLength;\n  float t = dot(segmentDir, pos - segmentStart);\n  if (segmentLength > 0.0 && t >= 0.0 && t <= segmentLength) {\n    segmentDistance = planeDistancePixels(segmentPlane, pos);\n  }\n  vec4 focusPlaneColor = laserLineProfile(focusPlaneDistance);\n  vec4 focusSphereColor = laserLineProfile(focusSphereDistance);\n  vec4 segmentColor = laserLineProfile(segmentDistance);\n  float focusPlaneAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, focusPlane.xyz)));\n  float focusSphereAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, normalize(pos - focusSphere.xyz))));\n  float segmentAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, segmentPlane.xyz)));\n  vec4 color = max(\n    focusPlaneColor * focusPlaneAlpha,\n    max(\n      focusSphereColor * focusSphereAlpha,\n      segmentColor * segmentAlpha\n    )\n  );\n  gl_FragColor = color * globalAlpha * depthDiscontinuityAlpha;\n}"},offscreen:{"composite.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor = texture2D(tex, vtc);\n}","compositeOccluded.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D occludedColorMap;\nuniform float opacity;\nvarying vec2 vtc;\nvoid main() {\n  vec4 occludedColor = texture2D(occludedColorMap, vtc);\n  gl_FragColor = occludedColor * opacity;\n}","compositeTransparentToHUDVisibility.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor = vec4(1.0 - texture2D(tex, vtc).a);\n}","offscreen.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 vtc;\nvoid main(void) {\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n  vtc = position.xy * 0.5 + 0.5;\n}"}},util:{"alignPixel.glsl":"vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy = vec2(.500123) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz = vec2(1.0) / widthHeight;\n  vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;\n  vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}\nvec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy = vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz = vec2(1.0) / widthHeight;\n  vec2 ij = floor((xy + .5 * pixelSz) * widthHeight) * pixelSz;\n  vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}","color.glsl":"vec4 premultiplyAlpha(vec4 v) {\n  return vec4(v.rgb * v.a, v.a);\n}\nvec3 rgb2hsv(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat rgb2v(vec3 c) {\n  return max(c.x, max(c.y, c.z));\n}","depth.glsl":"#include <util/encoding.glsl>\nfloat linearDepth(sampler2D depthTex, vec2 uv, vec2 nearFar) {\n  return -(rgba2float(texture2D(depthTex, uv)) * (nearFar[1] - nearFar[0]) + nearFar[0]);\n}\nfloat calcFragDepth(const in float depth) {\n  const float SLOPE_SCALE = 2.0;\n  const float BIAS = 2.0 * .000015259;\n  float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n  float result = depth + SLOPE_SCALE * m + BIAS;\n  return clamp(result, .0, .999999);\n}","doublePrecision.glsl":"#ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\nvec3 dpPlusFrc(vec3 a, vec3 b) {\n  return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n}\nvec3 dpMinusFrc(vec3 a, vec3 b) {\n  return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n}\nvec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n  vec3 t1 = dpPlusFrc(hiA, hiB);\n  vec3 e = dpMinusFrc(t1, hiA);\n  vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n  return t1 + t2;\n}\n#else\nvec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n  vec3 t1 = hiA + hiB;\n  vec3 e = t1 - hiA;\n  vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n  return t1 + t2;\n}\n#endif","enableExtensions.glsl":"#define EXTENSIONS_ENABLED\n#extension GL_OES_standard_derivatives : enable\n#extension GL_EXT_shader_texture_lod : enable","encoding.glsl":"const float MAX_RGBA_FLOAT =\n  255.0 / 256.0 +\n  255.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 / 256.0;\nconst vec4 fixedPointFactors = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\nvec4 float2rgba(const float value) {\n  float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n  vec4 fixedPointU8 = floor(fract(valueInValidDomain * fixedPointFactors) * 256.0);\n  const float toU8AsFloat = 1.0 / 255.0;\n  return fixedPointU8 * toU8AsFloat;\n}\nconst vec4 rgba2float_factors = vec4(\n  255.0 / (256.0),\n  255.0 / (256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\n  return dot(rgba, rgba2float_factors);\n}","fsPrecision.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp sampler2D;\n#else\nprecision mediump float;\nprecision mediump sampler2D;\n#endif","highlight.glsl":"vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\n  float sceneDepth = texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\n  if (fragCoord.z > sceneDepth + 5e-7) {\n    return vec4(1.0, 1.0, 0.0, 1.0);\n  }\n  else {\n    return vec4(1.0, 0.0, 1.0, 1.0);\n  }\n}","hud.glsl":"#include <util/screenSizePerspective.glsl>\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 auxpos1;\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 viewNormal;\nuniform mat4 model;\nuniform mat4 modelNormal;\nuniform vec4 viewport;\nuniform vec3 camPos;\nuniform float polygonOffset;\nuniform float cameraGroundRelative;\nuniform float pixelRatio;\nuniform float perDistancePixelRatio;\n#ifdef VERTICAL_OFFSET\nuniform vec4 verticalOffset;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspectiveAlignment;\n#endif\nuniform sampler2D hudVisibilityTexture;\nconst float SMALL_OFFSET_ANGLE = 0.984807753012208;\nstruct ProjectHUDAux {\n  vec3 posModel;\n  vec3 posView;\n  vec3 vnormal;\n  float distanceToCamera;\n  float absCosAngle;\n};\nfloat applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n  float pointGroundSign = sign(pointGroundDistance);\n  if (pointGroundSign == 0.0) {\n    pointGroundSign = cameraGroundRelative;\n  }\n  float groundRelative = cameraGroundRelative * pointGroundSign;\n  if (polygonOffset > .0) {\n    float cosAlpha = clamp(absCosAngle, 0.01, 1.0);\n    float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n    float factor = (1.0 - tanAlpha / viewport[2]);\n    if (groundRelative > 0.0) {\n      posView *= factor;\n    }\n    else {\n      posView /= factor;\n    }\n  }\n  return groundRelative;\n}\nvoid applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n  float distanceToCamera = length(posView);\n  float pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;\n  vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\n  vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  posModel += modelOffset;\n  posView += viewOffset;\n}\nvec4 projectPositionHUD(out ProjectHUDAux aux) {\n  vec3 centerOffset = auxpos1.xyz;\n  float pointGroundDistance = auxpos1.w;\n  aux.posModel = (model * vec4(position, 1.0)).xyz;\n  aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n  aux.vnormal = (modelNormal * vec4(normal, 1.0)).xyz;\n  applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\n  aux.distanceToCamera = length(aux.posView);\n  vec3 viewDirObjSpace = normalize(camPos - aux.posModel);\n  float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n  aux.absCosAngle = abs(cosAngle);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n#if defined(VERTICAL_OFFSET) || defined(CENTER_OFFSET_UNITS_SCREEN)\n  vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\n#endif\n#endif\n#ifdef VERTICAL_OFFSET\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\n#else\n  float verticalOffsetScreenHeight = verticalOffset.x;\n#endif\n  float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n  vec3 modelOffset = aux.vnormal * worldOffset;\n  aux.posModel += modelOffset;\n  vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  aux.posView += viewOffset;\n  pointGroundDistance += worldOffset;\n#endif\n  float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n#ifndef CENTER_OFFSET_UNITS_SCREEN\n  aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n  if (centerOffset.z != 0.0) {\n    aux.posView -= normalize(aux.posView) * centerOffset.z;\n  }\n#endif\n  vec4 posProj = proj * vec4(aux.posView, 1.0);\n#ifdef CENTER_OFFSET_UNITS_SCREEN\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\n#else\n  float centerOffsetY = centerOffset.y;\n#endif\n  posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\n#endif\n  posProj.z -= groundRelative * polygonOffset * posProj.w;\n  return posProj;\n}\nuniform float uRenderTransparentlyOccludedHUD;\nbool testVisibilityHUD(vec4 posProj) {\n  vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n  vec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\n  if (uRenderTransparentlyOccludedHUD > 0.5) {\n    return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * uRenderTransparentlyOccludedHUD < 1.0;\n  }\n  return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}","quad.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 uv;\nvoid main(void) {\n  gl_Position = vec4(position.x, position.y, .0, 1.0);\n  uv = position * .5 + vec2(.5);\n}","screenSizePerspective.glsl":"float screenSizePerspectiveMinSize(float size, vec4 factor) {\n  float nonZeroSize = 1.0 - step(size, 0.0);\n  return (\n    factor.z * (\n      1.0 +\n      nonZeroSize *\n      2.0 * factor.w / (\n        size + (1.0 - nonZeroSize)\n      )\n    )\n  );\n}\nfloat screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n  return absCosAngle * absCosAngle * absCosAngle;\n}\nvec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n  return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\n}\nfloat applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n  return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n}\nfloat screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}\nvec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n  return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n}\nvec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}","slice.glsl":"#ifdef SLICE\nuniform vec3 slicePlaneOrigin;\nuniform vec3 slicePlaneBasis1;\nuniform vec3 slicePlaneBasis2;\nstruct SliceFactors {\n  float front;\n  float side0;\n  float side1;\n  float side2;\n  float side3;\n};\nSliceFactors calculateSliceFactors(vec3 pos) {\n  vec3 rel = pos - slicePlaneOrigin;\n  vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);\n  float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);\n  float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);\n  float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);\n  float basis1Dot = dot(slicePlaneBasis1, rel);\n  float basis2Dot = dot(slicePlaneBasis2, rel);\n  return SliceFactors(\n    dot(slicePlaneNormal, pos) + slicePlaneW,\n    -basis1Dot - basis1Len2,\n    basis1Dot - basis1Len2,\n    -basis2Dot - basis2Len2,\n    basis2Dot - basis2Len2\n  );\n}\nbool sliceByFactors(SliceFactors factors) {\n  return factors.front < 0.0\n    && factors.side0 < 0.0\n    && factors.side1 < 0.0\n    && factors.side2 < 0.0\n    && factors.side3 < 0.0;\n}\nbool sliceByPlane(vec3 pos) {\n  return sliceByFactors(calculateSliceFactors(pos));\n}\n#ifdef EXTENSIONS_ENABLED\nvec4 applySliceHighlight(vec4 color, vec3 pos) {\n  SliceFactors factors = calculateSliceFactors(pos);\n  if (sliceByFactors(factors)) {\n    return color;\n  }\n  const float HIGHLIGHT_WIDTH = 1.0;\n  const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);\n  factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n  factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n  factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n  factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n  factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n  float highlightFactor = (1.0 - step(0.5, factors.front))\n    * (1.0 - step(0.5, factors.side0))\n    * (1.0 - step(0.5, factors.side1))\n    * (1.0 - step(0.5, factors.side2))\n    * (1.0 - step(0.5, factors.side3));\n  return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n}\n#else\n#endif\n#define rejectBySlice(_pos_) sliceByPlane(_pos_)\n#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n#ifdef SLICE_HIGHLIGHT_DISABLED\n#define highlightSlice(_color_, _pos_) (_color_)\n#else\n#define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\n#endif\n#else\n#define rejectBySlice(_pos_) false\n#define discardBySlice(_pos_) {}\n#define highlightSlice(_color_, _pos_) (_color_)\n#endif","transform.glsl":"vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {\n  return proj * (view * vec4(pos, 1.0));\n}\nvec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {\n  vec4 eye = view * vec4(pos, 1.0);\n  depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n  return proj * eye;\n}","visualVariables.glsl":"#ifdef VV_COLOR\n  #define VV_COLOR_N 8\n  uniform float vvColorValues[VV_COLOR_N];\n  uniform vec4 vvColorColors[VV_COLOR_N];\n#endif\n#ifdef VV_SIZE\n  uniform vec3 vvSizeMinSize;\n  uniform vec3 vvSizeMaxSize;\n  uniform vec3 vvSizeOffset;\n  uniform vec3 vvSizeFactor;\n  uniform mat3 vvSymbolRotationMatrix;\n  uniform vec3 vvSymbolAnchor;\n  vec3 vvGetScale(vec4 featureAttribute) {\n    return clamp(vvSizeOffset + featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\n  }\n  vec4 vvTransformPosition(vec3 position, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * (vvGetScale(featureAttribute) * (position + vvSymbolAnchor)), 1.0);\n  }\n  vec4 vvTransformNormal(vec3 normal, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * normal / vvGetScale(featureAttribute), 1.0);\n  }\n#endif\n#ifdef VV_COLOR\n  vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\n    float value = featureAttribute.y;\n    if (value <= values[0]) {\n      return colors[0];\n    }\n    for (int i = 1; i < VV_COLOR_N; ++i) {\n      if (values[i] >= value) {\n        float f = (value - values[i-1]) / (values[i] - values[i-1]);\n        return mix(colors[i-1], colors[i], f);\n      }\n    }\n    return colors[VV_COLOR_N - 1];\n  }\n#endif","vsPrecision.glsl":"precision highp float;\nprecision highp sampler2D;"}}}).apply(null,i))||(e.exports=r)},"W/V4":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qMld")],void 0===(r=(function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t,n){this._relativePath=t,this._moduleRequire=n,this._module=e}return e.prototype.get=function(){return this._module},e.prototype.reload=function(){var e=this,t=this._moduleRequire.toUrl(this._relativePath);return t=t.slice(t.indexOf("esri/")),this._recursivelyInvalidateModuleCache(t),n.create((function(t){e._moduleRequire([e._relativePath],(function(n){e._module=n,t()}))}))},e.prototype._recursivelyInvalidateModuleCache=function(e){if(-1!==e.search("shader")||-1!==e.search("shading")){var t=this._moduleRequire.modules,n=t[e];if(n){var i=n.deps;delete t[e];for(var r=0,a=i;r<a.length;r++){var o=a[r];"esri"===o.pid&&this._recursivelyInvalidateModuleCache(o.mid)}}}},e}();t.ReloadableShaderModule=i}).apply(null,i))||(e.exports=r)},W0kZ:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(){this._count=0}return e.prototype.gen=function(e){return null==e&&(e="a"),e+"_"+this._count++},e}();t.IdGen=n}).apply(null,i))||(e.exports=r)},WMxK:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.DecodeSymbolColor=function(e){e.vertex.code.add(i.glsl(r||(r=n(["\n    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n      float symbolAlpha = 0.0;\n\n      const float maxTint = 85.0;\n      const float maxReplace = 170.0;\n      const float scaleAlpha = 3.0;\n\n      if (symbolColor.a > maxReplace) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);\n      } else if (symbolColor.a > maxTint) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);\n      } else if (symbolColor.a > 0.0) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * symbolColor.a;\n      } else {\n        colorMixMode = ",";\n        symbolAlpha = 0.0;\n      }\n\n      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);\n    }\n  "],["\n    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n      float symbolAlpha = 0.0;\n\n      const float maxTint = 85.0;\n      const float maxReplace = 170.0;\n      const float scaleAlpha = 3.0;\n\n      if (symbolColor.a > maxReplace) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);\n      } else if (symbolColor.a > maxTint) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);\n      } else if (symbolColor.a > 0.0) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * symbolColor.a;\n      } else {\n        colorMixMode = ",";\n        symbolAlpha = 0.0;\n      }\n\n      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);\n    }\n  "])),i.glsl.int(1),i.glsl.int(3),i.glsl.int(4),i.glsl.int(1)))}}).apply(null,i))||(e.exports=r)},WRgd:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("N7S/"),n("lRq4")],void 0===(r=(function(e,t,n,i){function r(e){return void 0===e&&(e=t.ZERO),[e[0],e[1],e[2],e[3],e[4],e[5]]}function a(e,t,n,i,a,o,s){return void 0===s&&(s=r()),s[0]=e,s[1]=t,s[2]=n,s[3]=i,s[4]=a,s[5]=o,s}function o(e){return e[0]>=e[3]?0:e[3]-e[0]}function s(e){return e[1]>=e[4]?0:e[4]-e[1]}function l(e){return e[2]>=e[5]?0:e[5]-e[2]}function c(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function u(e){return 6===e.length}Object.defineProperty(t,"__esModule",{value:!0}),t.create=r,t.fromValues=a,t.fromExtent=function(e,t){return void 0===t&&(t=r()),t[0]=e.xmin,t[1]=e.ymin,t[2]=e.zmin,t[3]=e.xmax,t[4]=e.ymax,t[5]=e.zmax,t},t.toExtent=function(e,t){var i=isFinite(e[2])||isFinite(e[5]);return new n(i?{xmin:e[0],xmax:e[3],ymin:e[1],ymax:e[4],zmin:e[2],zmax:e[5],spatialReference:t}:{xmin:e[0],xmax:e[3],ymin:e[1],ymax:e[4],spatialReference:t})},t.fromMinMax=function(e,t,n){return void 0===n&&(n=r()),n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=t[0],n[4]=t[1],n[5]=t[2],n},t.expandPointInPlace=function(e,t){t[0]<e[0]&&(e[0]=t[0]),t[0]>e[3]&&(e[3]=t[0]),t[1]<e[1]&&(e[1]=t[1]),t[1]>e[4]&&(e[4]=t[1]),t[2]<e[2]&&(e[2]=t[2]),t[2]>e[5]&&(e[5]=t[2])},t.expand=function(e,t,n){return void 0===n&&(n=e),u(t)?(n[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[2]=Math.min(e[2],t[2]),n[3]=Math.max(e[3],t[3]),n[4]=Math.max(e[4],t[4]),n[5]=Math.max(e[5],t[5])):i.is(t)?(n[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[3]=Math.max(e[3],t[2]),n[4]=Math.max(e[4],t[3])):2===t.length?(n[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[3]=Math.max(e[3],t[0]),n[4]=Math.max(e[4],t[1])):3===t.length&&(n[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[2]=Math.min(e[2],t[2]),n[3]=Math.max(e[3],t[0]),n[4]=Math.max(e[4],t[1]),n[5]=Math.max(e[5],t[2])),n},t.expandWithBuffer=function(e,t,n,i,r){void 0===r&&(r=e);for(var a=e[0],o=e[1],s=e[2],l=e[3],c=e[4],u=e[5],d=0;d<i;d++)a=Math.min(a,t[n+3*d]),o=Math.min(o,t[n+3*d+1]),s=Math.min(s,t[n+3*d+2]),l=Math.max(l,t[n+3*d]),c=Math.max(c,t[n+3*d+1]),u=Math.max(u,t[n+3*d+2]);return r[0]=a,r[1]=o,r[2]=s,r[3]=l,r[4]=c,r[5]=u,r},t.expandWithOffset=function(e,t,n,i,r){return void 0===r&&(r=e),r[0]=Math.min(e[0],e[0]+t),r[3]=Math.max(e[3],e[3]+t),r[1]=Math.min(e[1],e[1]+n),r[4]=Math.max(e[4],e[4]+n),r[2]=Math.min(e[2],e[2]+i),r[5]=Math.max(e[5],e[5]+i),r},t.expandWithNestedArray=function(e,t,n,i){void 0===i&&(i=e);var r=t.length,a=e[0],o=e[1],s=e[2],l=e[3],c=e[4],u=e[5];if(n)for(var d=0;d<r;d++){var p=t[d];a=Math.min(a,p[0]),o=Math.min(o,p[1]),s=Math.min(s,p[2]),l=Math.max(l,p[0]),c=Math.max(c,p[1]),u=Math.max(u,p[2])}else for(d=0;d<r;d++)p=t[d],a=Math.min(a,p[0]),o=Math.min(o,p[1]),l=Math.max(l,p[0]),c=Math.max(c,p[1]);return i[0]=a,i[1]=o,i[2]=s,i[3]=l,i[4]=c,i[5]=u,i},t.allFinite=function(e){for(var t=0;t<6;t++)if(!isFinite(e[t]))return!1;return!0},t.width=o,t.depth=s,t.height=l,t.diameter=function(e){var t=o(e),n=l(e),i=s(e);return Math.sqrt(t*t+n*n+i*i)},t.center=function(e,t){return void 0===t&&(t=[0,0,0]),t[0]=e[0]+o(e)/2,t[1]=e[1]+s(e)/2,t[2]=e[2]+l(e)/2,t},t.size=function(e,t){return void 0===t&&(t=[0,0,0]),t[0]=o(e),t[1]=s(e),t[2]=l(e),t},t.maximumDimension=function(e){return Math.max(o(e),l(e),s(e))},t.containsPoint=function(e,t){return t[0]>=e[0]&&t[1]>=e[1]&&t[2]>=e[2]&&t[0]<=e[3]&&t[1]<=e[4]&&t[2]<=e[5]},t.containsPointWithMargin=function(e,t,n){return t[0]>=e[0]-n&&t[1]>=e[1]-n&&t[2]>=e[2]-n&&t[0]<=e[3]+n&&t[1]<=e[4]+n&&t[2]<=e[5]+n},t.contains=function(e,t){return t[0]>=e[0]&&t[1]>=e[1]&&t[2]>=e[2]&&t[3]<=e[3]&&t[4]<=e[4]&&t[5]<=e[5]},t.intersects=function(e,t){return Math.max(t[0],e[0])<=Math.min(t[3],e[3])&&Math.max(t[1],e[1])<=Math.min(t[4],e[4])&&Math.max(t[2],e[2])<=Math.min(t[5],e[5])},t.offset=function(e,t,n,i,r){return void 0===r&&(r=e),r[0]=e[0]+t,r[1]=e[1]+n,r[2]=e[2]+i,r[3]=e[3]+t,r[4]=e[4]+n,r[5]=e[5]+i,r},t.setMin=function(e,t,n){return void 0===n&&(n=e),n[0]=t[0],n[1]=t[1],n[2]=t[2],n!==e&&(n[3]=e[3],n[4]=e[4],n[5]=e[5]),n},t.setMax=function(e,t,n){return void 0===n&&(n=e),n[3]=t[0],n[4]=t[1],n[5]=t[2],n!==e&&(n[0]=e[0],n[1]=e[1],n[2]=e[2]),e},t.set=c,t.empty=function(e){return e?c(e,t.NEGATIVE_INFINITY):r(t.NEGATIVE_INFINITY)},t.toRect=function(e,t){return t||(t=i.create()),t[0]=e[0],t[1]=e[1],t[2]=e[3],t[3]=e[4],t},t.fromRect=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=Number.NEGATIVE_INFINITY,e[3]=t[2],e[4]=t[3],e[5]=Number.POSITIVE_INFINITY,e},t.is=u,t.isPoint=function(e){return 0===o(e)&&0===s(e)&&0===l(e)},t.equals=function(e,t,n){if(null==e||null==t)return e===t;if(!u(e)||!u(t))return!1;if(n){for(var i=0;i<e.length;i++)if(!n(e[i],t[i]))return!1}else for(i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0},t.wrap=function(e,t,n,i,r,o){return a(e,t,n,i,r,o,d)},t.POSITIVE_INFINITY=[-1/0,-1/0,-1/0,1/0,1/0,1/0],t.NEGATIVE_INFINITY=[1/0,1/0,1/0,-1/0,-1/0,-1/0],t.ZERO=[0,0,0,0,0,0];var d=r()}).apply(null,i))||(e.exports=r)},X0Jx:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("y4WC"),n("LxLY")],void 0===(r=(function(e,t,n,i,r){Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(){this._isToolEditable=!0,this._manipulators=new i,this._nextManipulatorId=0,this._resourceContexts={manipulator3D:{}},this._attached=!1}return Object.defineProperty(e.prototype,"isToolEditable",{set:function(e){this._isToolEditable=e},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"length",{get:function(){return this._manipulators.length},enumerable:!0,configurable:!0}),e.prototype.add=function(e,t){return void 0===t&&(t=0),this.addMany([e],t)[0]},e.prototype.addMany=function(e,t){var n=this;return void 0===t&&(t=0),e.map((function(e){var i=n._nextManipulatorId++,r={id:i,manipulator:e,visibilityPredicate:t,attached:!1};return n._manipulators.add(r),n._attached&&n._updateManipulatorAttachment(r),i}))},e.prototype.remove=function(e){if("number"==typeof e){for(var t=e,n=0;n<this._manipulators.length;n++)if(this._manipulators.getItemAt(n).id===t){var i=this._manipulators.splice(n,1)[0];return this._detachManipulator(i),i.id}return null}var r=e;for(n=0;n<this._manipulators.length;n++)if(this._manipulators.getItemAt(n).manipulator===r)return i=this._manipulators.splice(n,1)[0],this._detachManipulator(i),i.id;return null},e.prototype.removeAll=function(){var e=this;this._manipulators.forEach((function(t){e._detachManipulator(t)})),this._manipulators.removeAll()},e.prototype.attach=function(){var e=this;this._manipulators.forEach((function(t){e._updateManipulatorAttachment(t)})),this._attached=!0},e.prototype.detach=function(){var e=this;this._manipulators.forEach((function(t){e._detachManipulator(t)})),this._attached=!1},e.prototype.destroy=function(){this._manipulators.forEach((function(e){var t=e.manipulator;t.destroy&&t.destroy()})),this._manipulators.destroy(),this._resourceContexts=null},e.prototype.on=function(e,t){return this._manipulators.on(e,(function(e){t(e)}))},e.prototype.forEach=function(e){for(var t=0,n=this._manipulators.items;t<n.length;t++)e(n[t])},e.prototype.intersect=function(e,t){var n=null,i=Number.MAX_VALUE;return this._manipulators.forEach((function(a){var o=a.id,s=a.manipulator;if(a.attached&&s.interactive){var l=s.intersectionDistance(e,t);r.isSome(l)&&l<i&&(i=l,n=o)}})),n},e.prototype.findById=function(e){if(r.isNone(e))return null;for(var t=0,n=this._manipulators.items;t<n.length;t++){var i=n[t];if(e===i.id)return i.manipulator}return null},e.prototype._updateManipulatorAttachment=function(e){this._isManipulatorItemVisible(e)?this._attachManipulator(e):this._detachManipulator(e)},e.prototype._attachManipulator=function(e){e.attached||(e.manipulator.attach(this._resourceContexts),e.attached=!0)},e.prototype._detachManipulator=function(e){if(e.attached){var t=e.manipulator;t.grabbing=!1,t.dragging=!1,t.hovering=!1,t.selected=!1,t.detach(this._resourceContexts),e.attached=!1}},e.prototype._isManipulatorItemVisible=function(e){return 2===e.visibilityPredicate||(this._isToolEditable?0===e.visibilityPredicate:1===e.visibilityPredicate)},e}();t.ManipulatorCollection=a}).apply(null,i))||(e.exports=r)},X7Ps:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("9opi"),n("qKT0"),n("Gtr7"),n("eIBl"),n("H1tY"),n("qMld"),n("afW+"),n("Vx27"),n("KdBr"),n("X0Jx")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d){Object.defineProperty(t,"__esModule",{value:!0});var p=function(e){function t(t){var n=e.call(this,t)||this;return n.attached=!1,n.created=!1,n.completed=!1,n.manipulators=new d.ManipulatorCollection,n.deferCreation=!1,n._editableFlags=new Array,n._manipulatorHandles=new a,n._creationResolver=s.createResolver(),n}return n(t,e),Object.defineProperty(t.prototype,"active",{get:function(){return null!=this.view&&this.view.activeTool===this},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isSupported",{get:function(){return!0},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"visible",{set:function(e){this._set("visible",e),e||u.setActive(this,!1),this.attached&&(e?this._show():this._hide())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"editable",{get:function(){return this.hasEditableFlag(0)},set:function(e){this.setEditableFlag(0,e)},enumerable:!0,configurable:!0}),t.prototype.attach=function(){!this.attached&&this.isSupported&&(this.manipulators.attach(),this.onAttach(),this.visible&&this.onShow(),this._set("attached",!0))},t.prototype.detach=function(){this.attached&&(this.onHide(),this.onDetach(),this.manipulators.detach(),this._manipulatorHandles.removeAll(),this._set("attached",!1))},t.prototype.handleInputEvent=function(e){this.attached&&this.onInputEvent(e)},t.prototype.destroy=function(){this.manipulators.destroy(),this._manipulatorHandles&&(this._manipulatorHandles.destroy(),this._manipulatorHandles=null),this._set("view",null)},t.prototype.setEditableFlag=function(e,t){this._editableFlags[e]=t,this.manipulators.isToolEditable=this._editableFlags.every((function(e){return null==e||e})),this._updateManipulatorAttachment(),0===e&&this.notifyChange("editable"),this.onEditableChange()},t.prototype.hasEditableFlag=function(e){var t=this._editableFlags[e];return null==t||t},t.prototype.when=function(){return this._creationResolver.promise},t.prototype.rejectCreation=function(e){this._creationResolver.reject(e)},t.prototype.initialize=function(){this.deferCreation||this.complete()},t.prototype.onAttach=function(){},t.prototype.onDetach=function(){},t.prototype.onShow=function(){},t.prototype.onHide=function(){},t.prototype.onEditableChange=function(){},t.prototype.onInputEvent=function(e){},Object.defineProperty(t.prototype,"internallyEditable",{get:function(){return this.hasEditableFlag(0)&&this.hasEditableFlag(1)},enumerable:!0,configurable:!0}),t.prototype.create=function(){var e=this;this.created||(this._set("created",!0),o("esri-native-promise")?this._creationResolver(this):l.schedule((function(){return e._creationResolver(e)})))},t.prototype.complete=function(){this.create(),this._set("completed",!0)},t.prototype._show=function(){this._updateManipulatorAttachment(),this.onShow()},t.prototype._hide=function(){this._updateManipulatorAttachment(),this.onHide()},t.prototype._updateManipulatorAttachment=function(){this.attached&&this.visible?this.manipulators.attach():this.manipulators.detach()},i([c.property({constructOnly:!0})],t.prototype,"view",void 0),i([c.property({dependsOn:["view.activeTool"],readOnly:!0})],t.prototype,"active",null),i([c.property({value:!0})],t.prototype,"visible",null),i([c.property({value:!0})],t.prototype,"editable",null),i([c.property({readOnly:!0})],t.prototype,"attached",void 0),i([c.property({readOnly:!0})],t.prototype,"created",void 0),i([c.property({readOnly:!0})],t.prototype,"completed",void 0),i([c.property({readOnly:!0})],t.prototype,"manipulators",void 0),i([c.property({constructOnly:!0})],t.prototype,"deferCreation",void 0),i([c.subclass("esri.views.interactive.InteractiveToolBase")],t)}(c.declared(r));t.InteractiveToolBase=p}).apply(null,i))||(e.exports=r)},XsoR:function(e,t,n){var i;void 0===(i=(function(){return function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):(e.raw=t,e)}}).apply(null,[]))||(e.exports=i)},YseA:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xoE+")],void 0===(r=(function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e){null==e?e=16:e<65536&&(e=n.nextHighestPowerOfTwo(e)),this._array=new Float32Array(e),this._size=0}return e.prototype.resize=function(e,t){if(this._size=e,this._size>this._array.length){for(var n=this._array.length||1;n<this._size;)n*=2;var i=new Float32Array(n);return t&&i.set(this._array),this._array=i,!0}var r=2*this._size;if(r<=this._array.length){for(n=this._array.length;n>=r;)n=Math.floor(n/2);return i=new Float32Array(n),t&&i.set(this._array.subarray(0,n)),this._array=i,!0}return!1},e.prototype.append=function(e){var t=this._size;this.resize(this._size+e.length,!0),this._array.set(e,t)},e.prototype.erase=function(e,t){for(var n=e;n<t;++n)this._array[n]=0},Object.defineProperty(e.prototype,"array",{get:function(){return this._array},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),e}();t.ResizableFloat32Array=i}).apply(null,i))||(e.exports=r)},Z0CD:function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.HANDLE_COLOR=[1,.5,0],t.GEOMETRY_SEGMENTS=128,t.DISC_RADIUS=70,t.DISC_COLLISION_RADIUS=80,t.DISC_HEIGHT=.02,t.DISC_TRANSLATE_ARROW_SIZE=54,t.DISC_TRANSLATE_ARROW_OFFSET=100,t.RING_RADIUS=160,t.RING_HEIGHT=.5,t.RING_THICKNESS=24,t.INDICATOR_THICKNESS=9,t.INNER_INDICATOR_RADIUS=t.RING_RADIUS+30,t.OUTER_INDICATOR_RADIUS=t.RING_RADIUS+53,t.ROTATE_INDICATOR_ARROW_TIP_LENGTH=60,t.ROTATE_INDICATOR_ARROW_TIP_RADIUS=23,t.ROTATE_INDICATOR_ARC_LENGTH=5*Math.PI/12,t.SCALE_INDICATOR_ARC_LENGTH=1*Math.PI/3,t.DRAG_THRESHOLD_PX=10,t.ROTATE_INDICATOR_ARROW_PLACEMENT_PERCENTAGE=.2,t.SCALE_INDICATOR_OFFSET1=30,t.SCALE_INDICATOR_OFFSET2=53,t.SCALE_INDICATOR_DIRECTION_BUFFER=.2,t.ROTATE_INDICATOR_DIRECTION_BUFFER=.3,t.RING_INDICATOR_DELAY_MS=200,t.RING_RESET_ANIMATION_SPEED_FACTOR=3,t.ALIGN_ARROWS_SCALE_THRESHOLD=1e6}).apply(null,i))||(e.exports=r)},ZJC8:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("FXVB"),n("1m5D"),n("0LE5"),n("Rdxj"),n("AzkI"),n("rjU6"),n("Cvn+"),n("xsp2"),n("W0kZ"),n("CIy2")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p){var f=p.assert,h=function(){function e(t){void 0===t&&(t={}),this._objectTransformation=r.mat4f64.create(),this._bvObjectSpace=new m,this._bvWorldSpace=new m,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._allComponentsHiddenDirty=!0,this._allComponentsVisibleDirty=!0,this.id=e._idGen.gen(t.idHint),this.castShadow=null==t.castShadow||t.castShadow,this.metadata=t.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new v),this.objectTransformation=r.mat4f64.create(),this._initializeGeometryRecords(t.geometries,t.materials,t.transformations,t.origins)}return Object.defineProperty(e.prototype,"geometryRecords",{get:function(){return this._geometryRecords},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"geometries",{get:function(){return this._geometries},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"objectTransformation",{get:function(){return this._objectTransformation},set:function(e){i.mat4.copy(this._objectTransformation,e),this._invalidateBoundingVolume(),this._notifyDirty("objTransformation")},enumerable:!0,configurable:!0}),e.prototype.dispose=function(){for(var e=0,t=this._geometryRecords;e<t.length;e++)c.pool.release(t[e]);this._geometryRecords=null,this._geometries=null},e.prototype._initializeGeometryRecords=function(e,t,n,i){if(!Array.isArray(e))return this._geometryRecords=[],void(this._geometries=[]);f(t.length===e.length,"Object3D: materials don't match geometries"),f(n.length===e.length,"Object3D: transformations don't match geometries"),this._geometryRecords=new Array(e.length),this._geometries=e.slice();for(var a=0;a<e.length;a++)this._geometryRecords[a]=c.pool.acquire(e[a],t[a],r.mat4f64.clone(n[a]),{},i&&i[a]);this._hasVolatileTransformation=!1},Object.defineProperty(e.prototype,"parentLayer",{get:function(){return this._parentLayer},set:function(e){f(null==this._parentLayer||null==e,"Object3D can only be added to a single Layer"),this._parentLayer=e},enumerable:!0,configurable:!0}),e.prototype.getNumGeometryRecords=function(){return this._geometryRecords.length},e.prototype.findGeometryRecords=function(e){for(var t=[],n=0;n<this._geometries.length;n++)this._geometries[n]===e&&t.push(this._geometryRecords[n]);return t},e.prototype.getGeometryRecord=function(e){return f(e>=0&&e<this._geometryRecords.length,"Object3d.getGeometryDataByIndex: index out of range"),this._geometryRecords[e]},e.prototype.addGeometry=function(e,t,n,i,a,o){n=n?r.mat4f64.clone(n):r.mat4f64.IDENTITY,this._geometries.push(e);var s=c.pool.acquire(e,t,n,i||{},a,o);return this._geometryRecords.push(s),this._hasVolatileTransformation=this._geometryRecords.some((function(e){return!!e.shaderTransformation})),this._notifyDirty("objGeometryAdded",s),this._invalidateBoundingVolume(),this._allComponentsHiddenDirty=!0,this._allComponentsVisibleDirty=!0,s},e.prototype.removeGeometry=function(e){var t=this._geometryRecords.splice(e,1)[0];return c.pool.release(t),this._hasVolatileTransformation=this._geometryRecords.some((function(e){return!!e.shaderTransformation})),this._geometries.splice(e,1),this._notifyDirty("objGeometryRemoved",t),this._invalidateBoundingVolume(),this._allComponentsHiddenDirty=!0,this._allComponentsVisibleDirty=!0,t},e.prototype.removeAllGeometries=function(){for(;this.getNumGeometryRecords()>0;)this.removeGeometry(0)},e.prototype.geometryVertexAttrsUpdated=function(e){this._notifyDirty("vertexAttrsUpdated",this._geometryRecords[e]),this._invalidateBoundingVolume()},e.prototype.areAllComponentsHidden=function(){if(this._allComponentsHiddenDirty){this._allComponentsHiddenDirty=!1,this._allComponentsHidden=!0;for(var e=0,t=this._geometryRecords;e<t.length;e++){var n=t[e];if(!l.isAllHidden(n.instanceParameters.componentVisibilities,n.geometry.data.componentOffsets)){this._allComponentsHidden=!1;break}}}return this._allComponentsHidden},e.prototype.areAllComponentsVisible=function(){if(this._allComponentsVisibleDirty){this._allComponentsVisibleDirty=!1,this._allComponentsVisible=!0;for(var e=0,t=this._geometryRecords;e<t.length;e++){var n=t[e];if(!l.isAllVisible(n.instanceParameters.componentVisibilities,n.geometry.data.componentOffsets)){this._allComponentsVisible=!1;break}}}return this._allComponentsVisible},e.prototype.hasComponents=function(){for(var e=!1,t=0;t<this._geometries.length&&!(e=l.hasComponents(this._geometries[t].data.componentOffsets));t++);return e},e.prototype.setComponentVisibility=function(e,t,n){var i=l.updateVisibility(e.instanceParameters.componentVisibilities,e.geometry.data.componentOffsets,t,n);e.instanceParameters.componentVisibilities=i,this._notifyDirty("visibilityChanged",e),this._allComponentsHiddenDirty=!0,this._allComponentsVisibleDirty=!0},e.prototype.setHidden=function(e,t){e.instanceParameters.hidden=!!t,this._notifyDirty("visibilityChanged",e)},e.prototype.isHidden=function(e){return!!e.instanceParameters.hidden},e.prototype.getComponentVisibility=function(e,t){return l.getVisibility(e.instanceParameters.componentVisibilities,t)},e.prototype.hideAllComponents=function(){if(this._allComponentsHiddenDirty||!this._allComponentsHidden){for(var e=0,t=this._geometryRecords;e<t.length;e++){var n=t[e],i=l.hideAllComponents(n.instanceParameters.componentVisibilities);n.instanceParameters.componentVisibilities=i}this._notifyDirty("visibilityChanged"),this._allComponentsHiddenDirty=!1,this._allComponentsVisibleDirty=!1,this._allComponentsHidden=!0,this._allComponentsVisible=!1}},e.prototype.unhideAllComponents=function(){if(this._allComponentsVisibleDirty||!this._allComponentsVisible){for(var e=0,t=this._geometryRecords;e<t.length;e++){var n=t[e],i=l.unhideAllComponents(n.instanceParameters.componentVisibilities);n.instanceParameters.componentVisibilities=i}this._notifyDirty("visibilityChanged"),this._allComponentsHiddenDirty=!1,this._allComponentsVisibleDirty=!1,this._allComponentsHidden=!1,this._allComponentsVisible=!0}},e.prototype._setComponentHighlight=function(e,t,n,i){var r=l.addHighlight(e.instanceParameters.componentHighlights,t,n,i);e.instanceParameters.componentHighlights=r},e.prototype.setComponentHighlight=function(e,t,n){var i=u.generateHighlightId();return this._setComponentHighlight(e,t,n,i),this._notifyDirty("componentHighlightChanged"),i},e.prototype.highlightAllComponents=function(e){for(var t=u.generateHighlightId(),n=0,i=this._geometryRecords;n<i.length;n++)this._setComponentHighlight(i[n],null,e,t);return this._notifyDirty("componentHighlightChanged"),t},e.prototype.removeHighlights=function(e){for(var t=0,n=this._geometryRecords;t<n.length;t++){var i=n[t].instanceParameters,r=l.removeHighlight(i.componentHighlights,e);i.componentHighlights=r}this._notifyDirty("componentHighlightChanged")},e.prototype.getComponentFromTriangleNr=function(e,t){return f(e>=0&&e<this._geometryRecords.length,"Object3d.getComponentFromTriangleNr: index out of range"),l.componentFind(this._geometryRecords[e].geometry.data.componentOffsets,3*t)},e.prototype.setGeometryTransformation=function(e,t){f(e>=0&&e<this._geometryRecords.length,"Object3d.setGeometryTransformation: index out of range");var n=this._geometryRecords[e];c.pool.release(n);var i=c.pool.acquire(n.geometry,n.material,r.mat4f64.clone(t),n.instanceParameters);this._geometryRecords[e]=i,this._notifyDirty("objGeometryReplaced",[n,i]),this._invalidateBoundingVolume()},e.prototype.getCombinedStaticTransformation=function(e,t){return t=t||r.mat4f64.create(),i.mat4.multiply(t,this.objectTransformation,e.getStaticTransformation()),t},e.prototype.getCombinedShaderTransformation=function(e,t){return t=t||r.mat4f64.create(),i.mat4.multiply(t,this.objectTransformation,e.getShaderTransformation()),t},e.prototype.hasVolativeTransformation=function(){return this._hasVolatileTransformation},e.prototype.getMetadata=function(){return this.metadata},e.prototype.getBBMin=function(e){return this._validateBoundingVolume(),e?this._bvObjectSpace.bbMin:this._bvWorldSpace.bbMin},e.prototype.getBBMax=function(e){return this._validateBoundingVolume(),e?this._bvObjectSpace.bbMax:this._bvWorldSpace.bbMax},e.prototype.getCenter=function(e){return this._validateBoundingVolume(),e?this._bvObjectSpace.center:this._bvWorldSpace.center},e.prototype.getBSRadius=function(e){return this._validateBoundingVolume(),e?this._bvObjectSpace.bsRadius:this._bvWorldSpace.bsRadius},e.prototype._validateBoundingVolume=function(){if(this._bvDirty||this._hasVolatileTransformation){this._bvObjectSpace.init(),this._bvWorldSpace.init();for(var e=0;e<this._geometryRecords.length;++e){var t=this._geometryRecords[e];this._calculateTransformedBoundingVolume(l=(c=this._geometries[e]).boundingInfo,this._bvObjectSpace,t.getShaderTransformation()),this._calculateTransformedBoundingVolume(l,this._bvWorldSpace,this.getCombinedShaderTransformation(t))}a.vec3.lerp(this._bvObjectSpace.center,this._bvObjectSpace.bbMin,this._bvObjectSpace.bbMax,.5),a.vec3.lerp(this._bvWorldSpace.center,this._bvWorldSpace.bbMin,this._bvWorldSpace.bbMax,.5);var n=o.vec3f64.create(),i=o.vec3f64.create(),r=s.maxScale(this.objectTransformation);for(e=0;e<this._geometryRecords.length;++e){var l,c=this._geometries[e],u=this._geometryRecords[e].getShaderTransformation(),d=s.maxScale(u);a.vec3.transformMat4(n,(l=c.boundingInfo).getCenter(),u);var p=a.vec3.distance(n,this._bvObjectSpace.center),f=l.getBSRadius()*d;this._bvObjectSpace.bsRadius=Math.max(this._bvObjectSpace.bsRadius,p+f),a.vec3.transformMat4(i,n,this.objectTransformation);var h=a.vec3.distance(i,this._bvWorldSpace.center);this._bvWorldSpace.bsRadius=Math.max(this._bvWorldSpace.bsRadius,h+f*r)}this._bvDirty=!1}},e.prototype._calculateTransformedBoundingVolume=function(e,t,n){var i=e.getBBMin(),r=e.getBBMax(),s=o.vec3f64.clone(i),l=o.vec3f64.clone(r);a.vec3.transformMat4(s,s,n),a.vec3.transformMat4(l,l,n);for(var c=0;c<3;++c)t.bbMin[c]=Math.min(t.bbMin[c],s[c],l[c]),t.bbMax[c]=Math.max(t.bbMax[c],s[c],l[c]);for(c=0;c<3;++c){a.vec3.copy(s,i),a.vec3.copy(l,r),s[c]=r[c],l[c]=i[c],a.vec3.transformMat4(s,s,n),a.vec3.transformMat4(l,l,n);for(var u=0;u<3;++u)t.bbMin[u]=Math.min(t.bbMin[u],s[u],l[u]),t.bbMax[u]=Math.max(t.bbMax[u],s[u],l[u])}},e.prototype._invalidateBoundingVolume=function(){this._bvDirty=!0,this._parentLayer&&this._parentLayer.notifyObjectBBChanged(this,{center:this._bvWorldSpace.center,radius:this._bvWorldSpace.bsRadius})},e.prototype._notifyDirty=function(e,t,n,i){this._parentLayer&&this._parentLayer.notifyDirty(e,t,n=n||1,i||this)},Object.defineProperty(e.prototype,"test",{get:function(){var e=this;return{hasGeometry:function(t){return e._geometries.indexOf(t)>-1},getGeometryIndex:function(t){return e._geometries.indexOf(t)}}},enumerable:!0,configurable:!0}),e._idGen=new d.IdGen,e}(),v=function(){function e(){this.bbMin=o.vec3f64.fromValues(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.bbMax=o.vec3f64.fromValues(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}return e.prototype.isEmpty=function(){return this.bbMax[0]<this.bbMin[0]&&this.bbMax[1]<this.bbMin[1]&&this.bbMax[2]<this.bbMin[2]},e}(),m=function(e){function t(){var t=e.call(this)||this;return t.center=o.vec3f64.create(),t.bsRadius=0,t}return n(t,e),t.prototype.init=function(){a.vec3.set(this.bbMin,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),a.vec3.set(this.bbMax,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),a.vec3.set(this.center,0,0,0),this.bsRadius=0},t.prototype.getCenter=function(){return this.center},t.prototype.getBSRadius=function(){return this.bsRadius},t}(v);return h}).apply(null,i))||(e.exports=r)},ZO6V:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("KY0m"),n("BcWh"),n("0LE5"),n("Rdxj"),n("W0kZ"),n("mYMs")],void 0===(r=(function(e,t,n,i,r,a,o,s,l){return function(e){function t(n,i,r){var a=e.call(this)||this;return a._parentStages=new Map,a._children=new Set,a.id=t._idGen.gen(n),a.apiLayerUid=r,a.name=n,a.group=(i=i||{}).group||"",a.isVisible=null==i.isVisible||i.isVisible,a.isPickable=null==i.isPickable||i.isPickable,a.isSliceable=!1,a.translation=i.translation?o.vec3f64.clone(i.translation):o.vec3f64.create(),a._extent=[o.vec3f64.fromValues(0,0,0),o.vec3f64.fromValues(1e3,1e3,1e3)],a._extentDirty=!0,a}return n(t,e),t.prototype.addParentStage=function(e){if(!this._parentStages.has(e)){var t=this.on("dirty",(function(t){e.notifyDirty(t.origin,t.dirtyType,t.subObject)}));this._parentStages.set(e,t)}},t.prototype.removeParentStage=function(e){var t=this._parentStages.get(e);t&&(t.remove(),this._parentStages.delete(e)),this.invalidateSpatialQueryAccelerator()},t.prototype.getName=function(){return this.name},t.prototype.getGroup=function(){return this.group},t.prototype.getTranslation=function(){return this.translation},t.prototype.getObjectIds=function(){return i.keysOfSet(this._children,(function(e){return e.id}))},t.prototype.getObjects=function(){return i.keysOfSet(this._children)},t.prototype.getExtent=function(){return this._updateExtent(),this._extent},t.prototype.addObject=function(e){this._children.add(e),e.parentLayer=this,this.notifyDirty("layerObjectAdded",e),this._invalidateExtent(),this._octree&&this._octree.add(e)},t.prototype.hasObject=function(e){return this._children.has(e)},t.prototype.removeObject=function(e){return!!this._children.delete(e)&&(e.parentLayer=null,this.notifyDirty("layerObjectRemoved",e),this._invalidateExtent(),this._octree&&this._octree.remove(e),!0)},t.prototype.notifyObjectBBChanged=function(e,t){this._octree&&this._octree.update(e,t)},t.prototype.getCenter=function(){this._updateExtent();var e=o.vec3f64.create();return a.vec3.lerp(e,this._extent[0],this._extent[1],.5)},t.prototype.getBSRadius=function(){return this._updateExtent(),.5*a.vec3.distance(this._extent[0],this._extent[1])},t.prototype.getSpatialQueryAccelerator=function(){return!this._octree&&this._children.size>50&&this._createOctree(),this._octree},t.prototype.shaderTransformationChanged=function(){this.notifyDirty("shaderTransformationChanged",null)},t.prototype.invalidateSpatialQueryAccelerator=function(){this._octree&&(this._octree.destroy(),this._octree=null)},t.prototype.notifyDirty=function(e,t,n,i){n=n||0,this.emit("dirty",{origin:i||this,dirtyType:e,subObject:t})},t.prototype._createOctree=function(){for(var e=this.getExtent(),t=0,n=0;n<3;n++)t=Math.max(t,e[1][n]-e[0][n]);var r=o.vec3f64.create();a.vec3.lerp(r,e[0],e[1],.5),this._octree=new l(r,1.2*t,{getRadius:function(e){return e.getBSRadius()},getCenter:function(e){return e.getCenter()}}),this._octree.add(i.keysOfSet(this._children))},t.prototype._invalidateExtent=function(){this._extentDirty=!0},t.prototype._updateExtent=function(){var e=this;if(this._extentDirty){if(this._extentDirty=!1,0===this._children.size)return void(this._extent=[[0,0,0],[0,0,0]]);var t=null;this._children.forEach((function(n){var i=n.getBBMin(),r=n.getBBMax();if(t)for(var a=0;a<3;++a)e._extent[0][a]=Math.min(e._extent[0][a],i[a]),e._extent[1][a]=Math.max(e._extent[1][a],r[a]);else t=[o.vec3f64.clone(i),o.vec3f64.clone(r)]})),this._extent=t}},t._idGen=new s.IdGen,t}(r)}).apply(null,i))||(e.exports=r)},ZcgO:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("TMur"),n("jZlN"),n("pcDC"),n("H1tY"),n("rg9i"),n("LxLY"),n("rusB"),n("Z4y+"),n("WRgd"),n("lRq4"),n("Lzvl"),n("u90+"),n("KQcO"),n("/Vvo")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v){function m(e,t,n,r){return{uid:i.generateUID(),objectId:r&&e.attributes?e.attributes[r]:null,attributes:e.attributes,geometry:g(e.geometry,t,n),visible:!0}}function g(e,t,n){if(!e)return null;switch(t){case"point":return{x:e.x,y:e.y,z:e.z,m:e.m,hasZ:null!=e.z,hasM:null!=e.m,type:"point",spatialReference:n};case"polyline":return{paths:e.paths,hasZ:!!e.hasZ,hasM:!!e.hasM,type:"polyline",spatialReference:n};case"polygon":return{rings:e.rings,hasZ:!!e.hasZ,hasM:!!e.hasM,type:"polygon",spatialReference:n};case"multipoint":return{points:e.points,hasZ:!!e.hasZ,hasM:!!e.hasM,type:"multipoint",spatialReference:n}}}function y(e,t,n,i){return{x:e,y:t,z:n,hasZ:null!=n,hasM:!1,spatialReference:i,type:"point"}}function b(e){return"declaredClass"in e}function x(e){return"declaredClass"in e}function _(e){return"declaredClass"in e}function S(e){return s.isNone(e)?null:b(e)?e:p.fromJSON(function(e){var t=e.spatialReference.toJSON();switch(e.type){case"point":return{x:e.x,y:e.y,z:e.z,m:e.m,spatialReference:t};case"polygon":var n=e.hasZ,i=e.hasM;return{rings:A(e.rings),hasZ:n,hasM:i,spatialReference:t};case"polyline":return n=e.hasZ,i=e.hasM,{paths:A(e.paths),hasZ:n,hasM:i,spatialReference:t};case"extent":return{xmin:e.xmin,xmax:e.xmax,ymin:e.ymin,ymax:e.ymax,zmin:e.zmin,zmax:e.zmax,mmin:e.mmin,mmax:e.mmax,hasZ:n=e.hasZ,hasM:i=e.hasM,spatialReference:t};case"multipoint":var a=e.points;return n=e.hasZ,i=e.hasM,{points:O(a)?C(a):a,hasZ:n,hasM:i,spatialReference:t};default:return void r.neverReached(e)}}(e))}function P(e){if(!e)return 0;var t=32;for(var n in e)if(e.hasOwnProperty(n)){var i=e[n];switch(typeof i){case"string":t+=R(i);break;default:case"number":t+=16}}return t}function w(e){if(s.isNone(e))return 0;var t=32;switch(e.type){case"point":t+=42;break;case"polyline":case"polygon":for(var n=0,i=2+(e.hasZ?1:0)+(e.hasM?1:0),a="polyline"===e.type?e.paths:e.rings,o=0,c=a;o<c.length;o++)n+=c[o].length;t+=8*n*i+64,t+=128*n,t+=34,t+=32*(a.length+1);break;case"multipoint":var u=e.points.length;t+=8*u*(2+(e.hasZ?1:0)+(e.hasM?1:0))+64,t+=128*u,t+=34,t+=32;break;case"extent":t+=98,e.hasM&&(t+=32),e.hasZ&&(t+=32);break;case"mesh":t+=l.estimateSize(e.vertexAttributes.position),t+=l.estimateSize(e.vertexAttributes.normal),t+=l.estimateSize(e.vertexAttributes.uv),t+=l.estimateSize(e.vertexAttributes.tangent);break;default:r.neverReached(e)}return t}function A(e){return function(e){for(var t=0,n=e;t<n.length;t++){var i=n[t];if(0!==i.length)return O(i)}return!1}(e)?e.map((function(e){return C(e)})):e}function C(e){return e.map((function(e){return l.toArray(e)}))}function O(e){return e.length&&(l.isFloat32Array(e[0])||l.isFloat64Array(e[0]))}function M(e,t){switch(u.empty(t),"mesh"===e.type&&(e=e.extent),e.type){case"point":t[0]=t[3]=e.x,t[1]=t[4]=e.y,e.hasZ&&(t[2]=t[5]=e.z);break;case"polyline":for(var n=0;n<e.paths.length;n++)u.expandWithNestedArray(t,e.paths[n],e.hasZ);break;case"polygon":for(n=0;n<e.rings.length;n++)u.expandWithNestedArray(t,e.rings[n],e.hasZ);break;case"multipoint":u.expandWithNestedArray(t,e.points,e.hasZ);break;case"extent":t[0]=e.xmin,t[1]=e.ymin,t[3]=e.xmax,t[4]=e.ymax,null!=e.zmin&&(t[2]=e.zmin),null!=e.zmax&&(t[5]=e.zmax);break;default:r.neverReached(e)}}function D(e,t){switch(d.empty(t),"mesh"===e.type&&(e=e.extent),e.type){case"point":t[0]=t[2]=e.x,t[1]=t[3]=e.y;break;case"polyline":for(var n=0;n<e.paths.length;n++)d.expandWithNestedArray(t,e.paths[n]);break;case"polygon":for(n=0;n<e.rings.length;n++)d.expandWithNestedArray(t,e.rings[n]);break;case"multipoint":d.expandWithNestedArray(t,e.points);break;case"extent":t[0]=e.xmin,t[1]=e.ymin,t[2]=e.xmax,t[3]=e.ymax;break;default:r.neverReached(e)}}Object.defineProperty(t,"__esModule",{value:!0}),t.equals=v.equals,t.DehydratedFeatureClass=function(e,t,n){this.uid=e,this.geometry=t,this.attributes=n,this.visible=!0,this.objectId=null,this.centroid=null},t.hasGeometry=function(e){return s.isSome(e.geometry)},t.isFeatureGeometry=function(e){return n.isFeatureGeometryType(e.type)},t.DehydratedFeatureSetClass=function(){this.exceededTransferLimit=!1,this.features=[],this.fields=[],this.hasM=!1,this.hasZ=!1,this.geometryType=null,this.objectIdFieldName=null,this.globalIdFieldName=null,this.geometryProperties=null,this.geohashFieldName=null,this.spatialReference=null,this.transform=null},t.isPoint=function(e){return"point"===e.type},t.fromFeatureSetJSON=function(e){var t=n.featureGeometryTypeKebabDictionary.fromJSON(e.geometryType),i=c.fromJSON(e.spatialReference),a=e.transform,o=e.features.map((function(n){var o=m(n,t,i,e.objectIdFieldName),s=o.geometry;if(s&&a)switch(s.type){case"point":o.geometry=f.hydratePoint(a,s,s,s.hasZ,s.hasM);break;case"multipoint":o.geometry=f.hydrateMultipoint(a,s,s,s.hasZ,s.hasM);break;case"polygon":o.geometry=f.hydratePolygon(a,s,s,s.hasZ,s.hasM);break;case"polyline":o.geometry=f.hydratePolyline(a,s,s,s.hasZ,s.hasM);break;default:r.neverReached(s)}return o}));return{geometryType:t,features:o,spatialReference:i,fields:e.fields?e.fields.map((function(e){return h.fromJSON(e)})):null,objectIdFieldName:e.objectIdFieldName,globalIdFieldName:e.globalIdFieldName,geohashFieldName:e.geohashFieldName,geometryProperties:e.geometryProperties,hasZ:e.hasZ,hasM:e.hasM,exceededTransferLimit:e.exceededTransferLimit,transform:null}},t.fromJSONGeometry=g,t.makeDehydratedPoint=y,t.isHydratedGeometry=b,t.isHydratedPoint=x,t.isHydratedGraphic=_,t.hydrateGraphic=function(e,t){if(!e||_(e))return e;var n=new i({layer:t,sourceLayer:t});return n.visible=e.visible,n.symbol=o.clone(e.symbol),n.attributes=o.clone(e.attributes),n.geometry=S(e.geometry),n},t.hydrateGeometry=S,t.clonePoint=function(e,t){if(!e)return null;var n;if(x(e)){if(null==t)return e.clone();if(x(t))return t.copy(e)}return null!=t?((n=t).x=e.x,n.y=e.y,n.spatialReference=e.spatialReference,e.hasZ?(n.z=e.z,n.hasZ=e.hasZ):(n.z=null,n.hasZ=!1),e.hasM?(n.m=e.m,n.hasM=!0):(n.m=null,n.hasM=!1)):(n=y(e.x,e.y,e.z,e.spatialReference),e.hasM&&(n.m=e.m,n.hasM=!0)),n};var R=a("esri-text-decoder")?function(e){return 32+e.length}:function(e){return 32*e.length};t.estimateAttributesObjectSize=P,t.estimateGeometryObjectSize=w,t.estimateSize=function(e){var t=32;return t+=P(e.attributes),(t+=3)+(8+w(e.geometry))},t.numVertices=function(e){if(s.isNone(e))return 0;switch(e.type){case"point":return 1;case"polyline":for(var t=0,n=0,i=e.paths;n<i.length;n++)t+=i[n].length;return t;case"polygon":t=0;for(var a=0,o=e.rings;a<o.length;a++)t+=o[a].length;return t;case"multipoint":return e.points.length;case"extent":return 2;case"mesh":var l=e.vertexAttributes&&e.vertexAttributes.position;return l?l.length/3:0;default:return void r.neverReached(e)}},t.hasVertices=function(e){if(!e)return!1;switch(e.type){case"extent":case"point":return!0;case"polyline":for(var t=0,n=e.paths;t<n.length;t++)if(n[t].length>0)return!0;return!1;case"polygon":for(var i=0,a=e.rings;i<a.length;i++)if(a[i].length>0)return!0;return!1;case"multipoint":return e.points.length>0;case"mesh":return e.vertexAttributes&&e.vertexAttributes.position&&e.vertexAttributes.position.length>0;default:return void r.neverReached(e)}},t.computeAABB=M,t.expandAABB=function(e,t){M(e,T),u.expand(t,T)},t.computeAABR=D,t.expandAABR=function(e,t){D(e,I),d.expand(t,I)},t.getObjectId=function(e,t){return null!=e.objectId?e.objectId:e.attributes&&t?e.attributes[t]:null};var T=u.create(),I=d.create()}).apply(null,i))||(e.exports=r)},ZeO9:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("FXVB"),n("1m5D"),n("MzcX"),n("ff/U"),n("AASg"),n("YseA"),n("CIy2"),n("CP88"),n("pbva"),n("PwS/"),n("QFi0"),n("Kfys"),n("z2+Q")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h){var v=function(){function e(e,t,n,i){void 0===i&&(i=a.Default3D),this.type="MergedRenderer",this._dataByOrigin=new Map,this._highlightCount=0,this._rctx=e,this._vertexAttributeLocations=i,this._material=n,this._materialRep=t,this._glMaterials=d.acquireMaterials(this._material,this._materialRep),this._bufferWriter=n.createBufferWriter()}return e.prototype.dispose=function(){d.releaseMaterials(this._material,this._materialRep)},Object.defineProperty(e.prototype,"isEmpty",{get:function(){return 0===this._dataByOrigin.size},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"hasHighlights",{get:function(){return this._highlightCount>0},enumerable:!0,configurable:!0}),e.prototype.hasWater=function(){var e=!1;return this._glMaterials.forEach((function(t){e=e||t instanceof c.WaterGLMaterial})),e},e.prototype.renderPriority=function(){return this._material.renderPriority},e.prototype.modify=function(e){var t=this,n=x;n.clear(),this.updateGeometries(e.toUpdate,n),this.addAndRemoveGeometries(e.toAdd,e.toRemove,n),this.updateHighlightCount(),n.forEach((function(e){return t.updateDisplayedIndexRanges(e)}))},e.prototype.addAndRemoveGeometries=function(e,t,n){var i=this,r=this._bufferWriter,a=r.vertexBufferLayout,o=a.stride/4,s=this._dataByOrigin,c=function(e,t,n,i){for(var r=new Map,a=t.vertexBufferLayout.stride/4,o=function(n,i){var o=n.origin,s=e.get(o.id),l=r.get(o.id);null==l&&r.set(o.id,l={optimalCount:null==s?0:s.optimalCount,sparseCount:null==s?0:s.buffer.size,toAdd:[],toRemove:[],origin:o.vec3});var c=t.elementCount(n.data)*a;i?(l.optimalCount+=c,l.sparseCount+=c,l.toAdd.push(n)):(l.optimalCount-=c,l.toRemove.push(n))},s=0,l=n;s<l.length;s++)o(l[s],!0);for(var c=0,u=i;c<u.length;c++)o(u[c],!1);return r}(s,r,e,t);c.forEach((function(e,t){c.delete(t);var r=e.optimalCount,u=e.sparseCount,d=s.get(t);if(null==d&&(l.assert(r>0),d=i.createData(a,r,e.origin),s.set(t,d)),0===r)return d.vao.dispose(!0),d.vao=null,void s.delete(t);var p=r<e.sparseCount/2,f=m,h=d.buffer.size,v=d.buffer.array,y=d.buffer.resize(p?r:u,!1);p||y?i.removeAndRebuild(d,e.toRemove,o,v,f):e.toRemove.length>0?(i.removeByErasing(d,e.toRemove,o,f),e.toAdd.length>0&&(f.end=h)):(f.begin=h,f.end=h);var b=g;l.setMatrixTranslation3(b,-e.origin[0],-e.origin[1],-e.origin[2]),i.append(d,e.toAdd,o,b,f);var x=d.vao.vertexBuffers.geometry;if(x.byteSize!==d.buffer.array.buffer.byteLength)x.setData(d.buffer.array);else{var _=f.begin,S=f.end;if(_<S){var P=4*_;x.setSubData(d.buffer.array,P,P,4*S)}}(f.updatedDisplayedIndexRange||d.displayedIndexRanges)&&n.add(d)}))},e.prototype.updateGeometries=function(e,t){for(var n=this._bufferWriter,i=n.vertexBufferLayout.stride/4,r=0,a=e;r<a.length;r++){var o=a[r],s=o.updateType,c=o.renderGeometry,u=this._dataByOrigin.get(c.origin.id),p=u&&u.instances.get(c.uniqueName);if(!p)return;if(1&s&&(p.displayedIndexRange=d.generateRenderGeometryVisibleIndexRanges(c),t.add(u)),17&s&&(p.highlightedIndexRanges=d.generateRenderGeometryHighlightRanges(c),u.highlightCount=null),6&s){var f=u.buffer.array,h=u.vao;d.calculateTransformRelToOrigin(c,y,b),n.write({transformation:y,invTranspTransformation:b},c.data,n.vertexBufferLayout.createView(f.buffer),p.from),l.assert(p.from+n.elementCount(c.data)===p.to,"material VBO layout has changed"),h.vertexBuffers.geometry.setSubData(f,p.from*i*4,p.from*i*4,p.to*i*4)}}},e.prototype.updateDisplayedIndexRanges=function(e){e.displayedIndexRanges=[];var t=!0;e.instances.forEach((function(n){n.displayedIndexRange?(e.displayedIndexRanges.push.apply(e.displayedIndexRanges,o.offsetIntervals(n.displayedIndexRange,n.from)),t=!1):e.displayedIndexRanges.push([n.from,n.to-1])})),e.displayedIndexRanges=t?null:o.mergeIntervals(e.displayedIndexRanges)},e.prototype.updateHighlightCount=function(){var e=this;this._highlightCount=0,this._dataByOrigin.forEach((function(t){if(null==t.highlightCount){var n=0;t.instances.forEach((function(e){e.highlightedIndexRanges&&++n})),t.highlightCount=n}e._highlightCount+=t.highlightCount}))},e.prototype.updateLogic=function(e){return this._material.update(e)},e.prototype.render=function(e,t,n,r){var a=this,o=this._rctx,s=this._glMaterials.get(t.pass),l=4===t.pass,c=e;if(2===t.pass&&null===c&&(c=19),!s||1===s.ensureResources(o)||null!=c&&!s.beginSlot(c)||l&&0===this._highlightCount)return!1;s.bind(o,n);var u=s.getProgram();u.setUniformMatrix4fv("model",i.mat4f64.IDENTITY),u.hasUniform("modelNormal")&&u.setUniformMatrix4fv("modelNormal",i.mat4f64.IDENTITY);var d=!1;return this._dataByOrigin.forEach((function(e){l&&0===e.highlightCount||(n.origin=e.origin,s.bindView(n),d=l?a.renderHighlightPass(s,e,r)||d:a.renderDefaultPass(s,e,r)||d)})),s.release(),d},e.prototype.renderDefaultPass=function(e,t,n){var i=this._rctx,r=e.getDrawMode(),a=t.displayedIndexRanges;if(a&&0===a.length)return!1;if(e.ensureAttributeLocations(t.vao),i.bindVAO(t.vao),a)d.drawArraysFaceRange(i,a,0,r,n);else{var o=4*t.buffer.size/f.getStride(t.vao.layout.geometry);d.drawArrays(i,r,0,o,n)}return!0},e.prototype.renderHighlightPass=function(e,t,n){var i=this._rctx,r=e.getDrawMode(),a=t.vao;e.ensureAttributeLocations(a),i.bindVAO(a);var o=!1;return t.instances.forEach((function(e){var t=e.highlightedIndexRanges;if(t&&0!==t.length)for(var a=0;a<t.length;a++){var s=t[a];d.drawArrays(i,r,s.range?s.range[0]+e.from:e.from,s.range?s.range[1]-s.range[0]+1:e.to-e.from,n),o=!0}})),o},e.prototype.createData=function(e,t,n){return{instances:new Map,vao:new h(this._rctx,this._vertexAttributeLocations,{geometry:r.glLayout(e)},{geometry:p.createVertex(this._rctx,35044)}),buffer:new s.ResizableFloat32Array(t),optimalCount:0,origin:n,highlightCount:0}},e.prototype.removeAndRebuild=function(e,t,n,i,r){for(var a=0,o=t;a<o.length;a++){var s=o[a].uniqueName,l=e.instances.get(s);e.optimalCount-=(l.to-l.from)*n,e.instances.delete(s)}var c=0,u=e.buffer.array;r.begin=0,r.end=0;var d=-1,p=-1,f=0;e.instances.forEach((function(e){var t=e.from*n,r=e.to*n,a=r-t;d!==p&&p!==t?(u.set(i.subarray(d,p),f),f+=p-d,d=t):-1===d&&(d=t),p=r,e.from=c/n,e.to=(c+=a)/n})),d!==p&&u.set(i.subarray(d,p),f),r.end=c},e.prototype.removeByErasing=function(e,t,n,i){i.begin=1/0,i.end=-1/0;for(var r=-1,a=-1,o=0,s=t;o<s.length;o++){var l=s[o].uniqueName,c=e.instances.get(l),u=c.from*n,d=c.to*n;r!==a&&a!==u?(e.buffer.erase(r,a),r=u):-1===r&&(r=u),a=d,e.instances.delete(l),e.optimalCount-=d-u,u<i.begin&&(i.begin=u),d>i.end&&(i.end=d)}r!==a&&e.buffer.erase(r,a)},e.prototype.append=function(e,t,i,r,a){a.updatedDisplayedIndexRange=!1;for(var o=this._bufferWriter,s=0,c=t;s<c.length;s++){var p=c[s],f=p.data;n.mat4.multiply(y,r,p.transformation),n.mat4.invert(b,y),n.mat4.transpose(b,b);var h=a.end;o.write({transformation:y,invTranspTransformation:b},f,o.vertexBufferLayout.createView(e.buffer.array.buffer),a.end/i);var v=o.elementCount(f)*i,m=h+v;l.assert(null==e.instances.get(p.uniqueName));var g=d.generateRenderGeometryVisibleIndexRanges(p),x=d.generateRenderGeometryHighlightRanges(p);x&&(e.highlightCount=null);var _=new u(p.name,h/i,m/i,g,x,void 0,void 0,p.idx);e.instances.set(p.uniqueName,_),g&&(a.updatedDisplayedIndexRange=!0),e.optimalCount+=v,a.end+=v}},Object.defineProperty(e.prototype,"test",{get:function(){return{material:this._material}},enumerable:!0,configurable:!0}),e}(),m={updatedDisplayedIndexRange:!1,begin:0,end:0},g=i.mat4f64.create(),y=i.mat4f64.create(),b=i.mat4f64.create(),x=new Set;return v}).apply(null,i))||(e.exports=r)},aExC:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("9sIV"),n("qsST")],void 0===(r=(function(e,t,n,i){Object.defineProperty(t,"__esModule",{value:!0});var r=i.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder"),a=function(){function e(){this.vertex=new l,this.fragment=new l,this.attributes=new c,this.varyings=new u,this.extensions=new d,this.defines=new p,this._includedModules=new Map}return e.prototype.include=function(e,t){this._includedModules.has(e)?this._includedModules.get(e)!==t&&r.error("Trying to include shader module multiple times with different sets of options."):(this._includedModules.set(e,t),"shaderModule"in e?e.shaderModule(this,t):e(this,t))},e.prototype.generateSource=function(e){var t=this.extensions.generateSource(e),n=this.attributes.generateSource(e),i=this.varyings.generateSource(),r="vertex"===e?this.vertex:this.fragment,a=r.uniforms.generateSource(),o=r.code.generateSource(),s="vertex"===e?h:f,l=this.defines.generateSource().concat(r.defines.generateSource());return"\n"+t.join("\n")+"\n\n"+l.join("\n")+"\n\n"+s+"\n\n"+a.join("\n")+"\n\n"+n.join("\n")+"\n\n"+i.join("\n")+"\n\n"+o.join("\n")},e}();t.ShaderBuilder=a;var o=function(){function e(){this._entries=new Array,this._set=new Set}return e.prototype.add=function(e,t,n){var i=e+"_"+t+"_"+n;return this._set.has(i)||(this._entries.push([e,t,n]),this._set.add(i)),this},e.prototype.generateSource=function(){return this._entries.map((function(e){return"uniform "+e[1]+" "+e[0]+function(e){return e?"["+e+"]":""}(e[2])+";"}))},e}(),s=function(){function e(){this._entries=new Array}return e.prototype.add=function(e){this._entries.push(e)},e.prototype.generateSource=function(){return this._entries},e}(),l=function(){this.uniforms=new o,this.code=new s,this.defines=new p},c=function(){function e(){this._entries=new Array}return e.prototype.add=function(e,t){this._entries.push([e,t])},e.prototype.generateSource=function(e){return"fragment"===e?[]:this._entries.map((function(e){return"attribute "+e[1]+" "+e[0]+";"}))},e}(),u=function(){function e(){this._entries=new Array}return e.prototype.add=function(e,t){this._entries.push([e,t])},e.prototype.generateSource=function(){return this._entries.map((function(e){return"varying "+e[1]+" "+e[0]+";"}))},e}(),d=function(){function e(){this._entries=new Set}return e.prototype.add=function(e){this._entries.add(e)},e.prototype.generateSource=function(t){var i="vertex"===t?e.WHITELIST_VERTEX:e.WHITELIST_FRAGMENT;return n.valuesOfSet(this._entries).filter((function(e){return i.indexOf(e)>=0})).map((function(e){return"#extension "+e+" : enable"}))},e.WHITELIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],e.WHITELIST_VERTEX=[],e}(),p=function(){function e(){this._entries=new Map}return e.prototype.addInt=function(e,t){var n=t%1==0?t.toFixed(0):t.toString();this._entries.set(e,n)},e.prototype.addFloat=function(e,t){var n=t%1==0?t.toFixed(1):t.toString();this._entries.set(e,n)},e.prototype.generateSource=function(){return n.pairsOfMap(this._entries).map((function(e){return"#define "+e[0]+" "+e[1]}))},e}(),f="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif",h="precision highp float;\nprecision highp sampler2D;"}).apply(null,i))||(e.exports=r)},aluc:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("mOGR"),n("7Aei")],void 0===(r=(function(e,t,n,i,r){var a,o,s,l,c;Object.defineProperty(t,"__esModule",{value:!0}),t.ComputeNormalTexture=function(e,t){var u=e.fragment;u.uniforms.add("normalTexture","sampler2D"),u.uniforms.add("normalTextureSize","vec2"),t.vertexTangets?(e.attributes.add("tangent","vec4"),e.varyings.add("vTangent","vec4"),e.vertex.code.add(r.glsl(a||(a=n(["\n      void transformVertexTangent(mat3 modelTransformForNormals) {\n        vTangent.xyz = modelTransformForNormals * tangent.xyz;\n        vTangent.w = tangent.w;\n      }\n    "],["\n      void transformVertexTangent(mat3 modelTransformForNormals) {\n        vTangent.xyz = modelTransformForNormals * tangent.xyz;\n        vTangent.w = tangent.w;\n      }\n    "])))),u.code.add(r.glsl(2===t.doubleSidedMode?o||(o=n(["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\n        vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "],["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\n        vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "])):s||(s=n(["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = vTangent.w;\n        vec3 tangent = normalize(vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "],["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = vTangent.w;\n        vec3 tangent = normalize(vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "]))))):(e.extensions.add("GL_OES_standard_derivatives"),u.code.add(r.glsl(l||(l=n(['\n    mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\n\n      vec3 Q1 = dFdx(pos);\n      vec3 Q2 = dFdy(pos);\n\n      vec2 stx = dFdx(st);\n      vec2 sty = dFdy(st);\n\n      float det = stx.t * sty.s - sty.t * stx.s;\n\n      vec3 T = stx.t * Q2 - sty.t * Q1; // compute tangent\n      T = T - normal * dot(normal, T); // orthogonalize tangent\n      T *= inversesqrt(max(dot(T,T), 1.e-10)); // "soft" normalize - goes to 0 when T goes to 0\n      vec3 B = sign(det) * cross(normal, T); // assume normal is normalized, B has the same lenght as B\n      return mat3(T, B, normal); // T and B go to 0 when the tangent space is not well defined by the uv coordinates\n    }\n  '],['\n    mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\n\n      vec3 Q1 = dFdx(pos);\n      vec3 Q2 = dFdy(pos);\n\n      vec2 stx = dFdx(st);\n      vec2 sty = dFdy(st);\n\n      float det = stx.t * sty.s - sty.t * stx.s;\n\n      vec3 T = stx.t * Q2 - sty.t * Q1; // compute tangent\n      T = T - normal * dot(normal, T); // orthogonalize tangent\n      T *= inversesqrt(max(dot(T,T), 1.e-10)); // "soft" normalize - goes to 0 when T goes to 0\n      vec3 B = sign(det) * cross(normal, T); // assume normal is normalized, B has the same lenght as B\n      return mat3(T, B, normal); // T and B go to 0 when the tangent space is not well defined by the uv coordinates\n    }\n  ']))))),0!==t.attributeTextureCoordinates&&(e.include(i.VertexTextureCoordinates,t),u.code.add(r.glsl(c||(c=n(["\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ","\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  "],["\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ","\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  "])),t.supportsTextureAtlas?"vtc.size = normalTextureSize;":"")))}}).apply(null,i))||(e.exports=r)},ama6:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("51bw"),n("vlC2")],void 0===(r=(function(e,t,n,i){var r;return function(e){e.Default={vvSizeEnabled:!1,vvSizeMinSize:i.vec3f32.fromValues(1,1,1),vvSizeMaxSize:i.vec3f32.fromValues(100,100,100),vvSizeOffset:i.vec3f32.fromValues(0,0,0),vvSizeFactor:i.vec3f32.fromValues(1,1,1),vvSizeValue:i.vec3f32.fromValues(1,1,1),vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],vvOpacityEnabled:!1,vvOpacityValues:[0,0,0,0,0,0,0,0],vvOpacityOpacities:[1,1,1,1,1,1,1,1],vvSymbolAnchor:[0,0,0],vvSymbolRotationMatrix:n.mat3f64.create()}}(r||(r={})),r}).apply(null,i))||(e.exports=r)},bF8Q:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("LxLY"),n("o2T8")],void 0===(r=(function(e,t,n,i){function r(e,t,i){var r=null;return e.events.on("drag",(function(a){if("start"===a.action&&(r=t(e,a)),!n.isNone(r)){var o=r(a);n.isSome(o)&&i(o),"end"===a.action&&(r=null)}}))}function a(e,t,n){for(var a=[],o=0,s=e;o<s.length;o++)a.push(r(s[o],t,n));return i.handlesGroup(a)}Object.defineProperty(t,"__esModule",{value:!0}),t.createManipulatorDragHandler=r,t.createManipulatorDragHandlerOneOf=function(e,t,i){var r=null;return a(e,(function(e,i){return n.isSome(r)?null:r=t(e,i)}),(function(e){return"end"===e.action&&(r=null),i(e)}))},t.createManipulatorDragHandlerMany=a}).apply(null,i))||(e.exports=r)},bMXq:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o,s;Object.defineProperty(t,"__esModule",{value:!0}),t.DiscardOrAdjustAlpha=function(e,t){var l=e.fragment;switch(t.alphaDiscardMode){case 0:l.code.add(i.glsl(r||(r=n(["\n        void discardOrAdjustAlpha(inout vec4 color) {}\n      "],["\n        void discardOrAdjustAlpha(inout vec4 color) {}\n      "]))));break;case 1:l.code.add(i.glsl(a||(a=n(["\n        void discardOrAdjustAlpha(inout vec4 color) {\n          color.a = 1.0;\n        }\n      "],["\n        void discardOrAdjustAlpha(inout vec4 color) {\n          color.a = 1.0;\n        }\n      "]))));break;case 2:l.uniforms.add("textureAlphaCutoff","float"),l.code.add(i.glsl(o||(o=n(["\n        #define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }\n      "],["\n        #define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }\n      "]))));break;case 3:e.fragment.uniforms.add("textureAlphaCutoff","float"),e.fragment.code.add(i.glsl(s||(s=n(["\n        #define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }\n      "],["\n        #define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }\n      "]))))}},t.TEXTURE_ALPHA_CUTOFF_DEFAULT=.1}).apply(null,i))||(e.exports=r)},cGZG:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o,s;Object.defineProperty(t,"__esModule",{value:!0}),t.Normals=function(e,t){var l=e.fragment;l.code.add(i.glsl(r||(r=n(["\n    struct ShadingNormalParameters {\n      vec3 normalView;\n      vec3 viewDirection;\n    } shadingParams;\n    "],["\n    struct ShadingNormalParameters {\n      vec3 normalView;\n      vec3 viewDirection;\n    } shadingParams;\n    "])))),l.code.add(i.glsl(1===t.doubleSidedMode?a||(a=n(["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return dot(params.normalView, params.viewDirection) > 0.0 ? normalize(-params.normalView) : normalize(params.normalView);\n      }\n    "],["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return dot(params.normalView, params.viewDirection) > 0.0 ? normalize(-params.normalView) : normalize(params.normalView);\n      }\n    "])):2===t.doubleSidedMode?o||(o=n(["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return gl_FrontFacing ? normalize(params.normalView) : normalize(-params.normalView);\n      }\n    "],["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return gl_FrontFacing ? normalize(params.normalView) : normalize(-params.normalView);\n      }\n    "])):s||(s=n(["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return normalize(params.normalView);\n      }\n    "],["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return normalize(params.normalView);\n      }\n    "]))))}}).apply(null,i))||(e.exports=r)},cj3m:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("DKwL"),n("7Aei")],void 0===(r=(function(e,t,n,i,r){function a(e){e.include(i.RgbaFloatEncoding),e.fragment.uniforms.add("depthTex","sampler2D"),e.fragment.uniforms.add("shadowMapNum","int"),e.fragment.uniforms.add("shadowMapDistance","vec4"),e.fragment.uniforms.add("shadowMapMatrix","mat4",4),e.fragment.uniforms.add("depthHalfPixelSz","float"),e.fragment.code.add(r.glsl(o||(o=n(["\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      float halfPixelSize = depthHalfPixelSz;\n      vec4 distance = shadowMapDistance;\n      float depth = _linearDepth;\n\n      //choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      if (i >= shadowMapNum) { return 0.0; }\n\n      mat4 mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n\n      // vertex completely outside? -> no shadow\n      vec3 lvpos = 0.5 * lv.xyz + vec3(0.5);\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n\n      float texSize = 0.5 / halfPixelSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\n\n      float s00 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s10 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s11 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s01 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n  "],["\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      float halfPixelSize = depthHalfPixelSz;\n      vec4 distance = shadowMapDistance;\n      float depth = _linearDepth;\n\n      //choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      if (i >= shadowMapNum) { return 0.0; }\n\n      mat4 mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n\n      // vertex completely outside? -> no shadow\n      vec3 lvpos = 0.5 * lv.xyz + vec3(0.5);\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n\n      float texSize = 0.5 / halfPixelSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\n\n      float s00 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s10 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s11 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s01 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n  "]))))}var o;Object.defineProperty(t,"__esModule",{value:!0}),t.ReadShadowMap=a,function(e){e.bindUniforms=function(e,t){t.shadowMappingEnabled&&t.shadowMap.bindView(e,t.origin)}}(a=t.ReadShadowMap||(t.ReadShadowMap={}))}).apply(null,i))||(e.exports=r)},cmSR:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o;Object.defineProperty(t,"__esModule",{value:!0}),t.ForwardLinearDepth=function(e,t){0===t.output&&t.receiveShadows?(e.varyings.add("linearDepth","float"),e.vertex.code.add(i.glsl(r||(r=n(["\n      void forwardLinearDepth() { linearDepth = gl_Position.w; }\n    "],["\n      void forwardLinearDepth() { linearDepth = gl_Position.w; }\n    "]))))):1===t.output||3===t.output?(e.varyings.add("linearDepth","float"),e.vertex.uniforms.add("uCameraNearFar","vec2"),e.vertex.code.add(i.glsl(a||(a=n(["\n      void forwardLinearDepth() {\n        linearDepth = (-position_view().z - uCameraNearFar[0]) / (uCameraNearFar[1] - uCameraNearFar[0]);\n      }\n    "],["\n      void forwardLinearDepth() {\n        linearDepth = (-position_view().z - uCameraNearFar[0]) / (uCameraNearFar[1] - uCameraNearFar[0]);\n      }\n    "]))))):e.vertex.code.add(i.glsl(o||(o=n(["\n      void forwardLinearDepth() {}\n    "],["\n      void forwardLinearDepth() {}\n    "]))))}}).apply(null,i))||(e.exports=r)},cqYc:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("8TPw"),n("7Aei")],void 0===(r=(function(e,t,n,i,r){function a(e,t){0===t.normalType||1===t.normalType?(e.include(i.NormalAttribute,t),e.varyings.add("vNormalWorld","vec3"),e.varyings.add("vNormalView","vec3"),e.vertex.uniforms.add("uTransformNormal_GlobalFromModel","mat3"),e.vertex.uniforms.add("uTransformNormal_ViewFromGlobal","mat3"),e.vertex.code.add(r.glsl(o||(o=n(["\n      void forwardNormal() {\n        vNormalWorld = uTransformNormal_GlobalFromModel * normalModel();\n        vNormalView = uTransformNormal_ViewFromGlobal * vNormalWorld;\n      }\n    "],["\n      void forwardNormal() {\n        vNormalWorld = uTransformNormal_GlobalFromModel * normalModel();\n        vNormalView = uTransformNormal_ViewFromGlobal * vNormalWorld;\n      }\n    "]))))):e.vertex.code.add(r.glsl(s||(s=n(["\n      void forwardNormal() {}\n    "],["\n      void forwardNormal() {}\n    "]))))}var o,s;Object.defineProperty(t,"__esModule",{value:!0}),t.VertexNormal=a,function(e){e.bindUniforms=function(e,t){e.setUniformMatrix4fv("viewNormal",t.viewInvTransp)}}(a=t.VertexNormal||(t.VertexNormal={}))}).apply(null,i))||(e.exports=r)},d0uo:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("2Atf"),n("pcDC"),n("BcWh"),n("eIBl"),n("LxLY"),n("8MXS"),n("Vx27"),n("0LE5"),n("ZcgO"),n("DtIM"),n("woUR"),n("5T2R"),n("+soW"),n("1eTA"),n("TCLX"),n("JjCO"),n("ys4y"),n("4ziW"),n("bF8Q"),n("wOtw")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_,S,P){function w(e){return"vertex"===e.handle.type}function A(e){return"edge"===e.handle.type}Object.defineProperty(t,"__esModule",{value:!0});var C=function(e){function t(t){var n=e.call(this,t)||this;return n._vertexManipulatorMaterial=v.createManipulatorMaterial([1,.5,0],1),n._edgeManipulatorMaterial=v.createManipulatorMaterial([.5,.5,.5],1),n._selectedManipulatorMaterial=v.createManipulatorMaterial([1,1,1],1),n._manipulatorGeometry=new x(_.createSphereGeometry(1,16,16),"reshape-manipulator"),n._handles=new s,n._manipulatorHandles=new s,n._manipulatorInfos=[],n._reshapeHelper=null,n._moveManipulator=null,n._moveZManipulator=null,n._numGrabbing=0,n._reshapeEventState=0,n.view=null,n.graphic=null,n.outputGeometry=null,n.manipulators=null,n._emitter.target=null,n}return i(t,e),t.prototype.initialize=function(){var e=this;this._handles.add(this.watch(["graphic.visible","graphic.layer.visible"],(function(){for(var t=e.graphic.visible&&e.graphic.layer.visible,n=0,i=e._manipulatorInfos;n<i.length;n++)i[n].manipulator.visible=!!t;l.isSome(e._moveZManipulator)&&(e._moveZManipulator.visible=!!t)})))},t.prototype.destroy=function(){this._clear(),this._handles.destroy()},Object.defineProperty(t.prototype,"inputGeometry",{get:function(){return l.isSome(this._reshapeHelper)?this._reshapeHelper.geometry:null},set:function(e){this._recreateManipulators(e)},enumerable:!0,configurable:!0}),t.prototype.removeSelectedVertices=function(){var e=this._manipulatorInfos.filter((function(e){return e.manipulator.selected&&"vertex"===e.handle.type}));this._removeVertices(e)},t.prototype.manipulatorSelectionChanged=function(){this._updateMoveZManipulatorPosition()},t.prototype._clear=function(){this._manipulatorHandles.removeAll(),this.manipulators.removeAll(),this._manipulatorInfos=[],this._moveManipulator=null,this._reshapeHelper=null,this._numGrabbing=0},t.prototype._recreateManipulators=function(e){if(this._clear(),this._reshapeHelper=y.createReshapeHelper(e,"global"===this.view.viewingMode),!l.isNone(this._reshapeHelper)){for(var t=f.getGraphicEffectiveElevationInfo(this.graphic),n=0,i=this._reshapeHelper.components;n<i.length;n++){for(var r=i[n],a=0,o=r.vertices;a<o.length;a++)this._createPerVertexManipulator(o[a],t);for(var s=0,c=r.edges;s<c.length;s++)this._createPerVertexManipulator(c[s],t)}this._createGraphicMoveManipulators()}},t.prototype._perGraphicManipulatorDragAction=function(e,t){if("end"!==t.action){for(var n=[],i=this._manipulatorInfos.some((function(e){return"vertex"===e.handle.type&&e.manipulator.selected})),r=1===e&&i,a=l.expect(this._reshapeHelper),o=0,s=this._manipulatorInfos;o<s.length;o++)"vertex"===(d=s[o]).handle.type&&(d.manipulator.grabbing||r&&!d.manipulator.selected||(l.expect(a).addDelta(d.handle,t.deltaDeltaX,t.deltaDeltaY,t.deltaDeltaZ),n.push(d.handle.pos),this._updateManipulatorPosition(d)));if(0!==n.length){for(var c=0,u=this._manipulatorInfos;c<u.length;c++){var d;"vertex"!==(d=u[c]).handle.type&&this._updateManipulatorPosition(d)}this.outputGeometry=a.commit(),n.length===this._manipulatorInfos.length?(this._updateEventState(1),this.emit("move",{type:"move",dx:t.screenDeltaDeltaX,dy:t.screenDeltaDeltaY,mover:this.graphic})):(this._updateEventState(2),this.emit("reshape",{type:"reshape",mover:this.graphic}))}}},t.prototype._perVertexManipulatorDragAction=function(e,t){var n=A(e)?this._splitEdgeManipulator(e):e;this._updateEventState(2),!1===e.manipulator.selected&&(this._clearManipulatorSelection(),this._updateMoveZManipulatorPosition());var i=t.deltaDeltaX,r=t.deltaDeltaY,a=t.deltaDeltaZ;if(i||r||a){for(var o=[],s=0,c=this._manipulatorInfos;s<c.length;s++){var u=c[s];w(u)&&(u.manipulator.selected&&!u.manipulator.grabbing||u===n)&&o.push(u)}for(var d=l.expect(this._reshapeHelper),p=0,f=o;p<f.length;p++)d.addDelta(g=(m=f[p]).handle,i,r,a),this._updateManipulatorPosition(m);this.outputGeometry=d.commit();for(var h=0,v=o;h<v.length;h++){var m,g;this._updateManipulatorPosition(this._getManipulatorInfoFromHandle((g=(m=v[h]).handle).left)),this._updateManipulatorPosition(this._getManipulatorInfoFromHandle(g.right))}this.emit("reshape",{type:"reshape",mover:this.graphic})}},t.prototype._updateEventState=function(e){if(e===this._reshapeEventState)return!1;switch(e){case 0:if(0!==this._numGrabbing)return!1;switch(this._reshapeEventState){case 1:this.emit("move",{type:"move-stop",dx:0,dy:0,mover:this.graphic});break;case 2:this.emit("reshape",{type:"reshape-stop",mover:this.graphic})}break;case 1:switch(this._reshapeEventState){case 0:this.emit("move",{type:"move-start",dx:0,dy:0,mover:this.graphic});break;case 2:this.emit("reshape",{type:"reshape-stop",mover:this.graphic}),this.emit("move",{type:"move-start",dx:0,dy:0,mover:this.graphic})}break;case 2:switch(this._reshapeEventState){case 0:this.emit("reshape",{type:"reshape-start",mover:this.graphic});break;case 1:this.emit("move",{type:"move-stop",dx:0,dy:0,mover:this.graphic}),this.emit("reshape",{type:"reshape-start",mover:this.graphic})}}var t=this._reshapeEventState!==e;return this._reshapeEventState=e,t},t.prototype._createGraphicMoveManipulators=function(){var e=this;this._moveManipulator=g.createGraphicMoveXYManipulator(this.view,this.graphic),this._manipulatorHandles.add(S.createManipulatorDragHandler(this._moveManipulator,(function(t,n){return P.withScreenHistoryInfo(P.withHistoryInfo(g.createGraphicMoveXYScreenDragToMap(e.view,t,n)))}),(function(t){return e._perGraphicManipulatorDragAction(0,t)}))),this._manipulatorHandles.add(this._watchAndUpdateGrabState(this._moveManipulator)),this._moveManipulator.events.on("immediate-click",(function(t){e.emit("immediate-click"),t.stopPropagation()})),this.manipulators.add(this._moveManipulator),this._moveZManipulator=g.createGraphicMoveZManipulator({view:this.view,graphic:this.graphic}),l.isSome(this._moveZManipulator)&&(this._manipulatorHandles.add(S.createManipulatorDragHandler(this._moveZManipulator,(function(t){return P.withScreenHistoryInfo(P.withHistoryInfo(g.createGraphicMoveZScreenDragToMap(e.view,t)))}),(function(t){return e._perGraphicManipulatorDragAction(1,t)}))),this._manipulatorHandles.add(this._watchAndUpdateGrabState(this._moveZManipulator)),this.manipulators.add(this._moveZManipulator),this._manipulatorHandles.add(c.init(this.graphic,"geometry",(function(){return e._updateMoveZManipulatorPosition()}))))},t.prototype._clearManipulatorSelection=function(){for(var e=0,t=this._manipulatorInfos;e<t.length;e++)t[e].manipulator.selected=!1;this._updateMoveZManipulatorPosition()},t.prototype._createPerVertexManipulator=function(e,t){var n=this;void 0===t&&(t=f.getGraphicEffectiveElevationInfo(this.graphic));var i=new h.Manipulator3D({view:this.view,renderObjects:[{geometry:this._manipulatorGeometry,material:this._vertexManipulatorMaterial,stateMask:4|O.Vertex},{geometry:this._manipulatorGeometry,material:this._edgeManipulatorMaterial,stateMask:4|O.Edge},{geometry:this._manipulatorGeometry,material:this._selectedManipulatorMaterial,stateMask:8}],radius:5,elevationInfo:t,visible:!(!this.graphic.visible||!this.graphic.layer.visible)});this._setTypeSpecificManipulatorSettings(i,e);var r={manipulator:i,handle:e};return this._manipulatorInfos.push(r),this.manipulators.add(i),this._updateManipulatorPosition(r),this._manipulatorHandles.add(this._watchAndUpdateGrabState(i),i),this._manipulatorHandles.add(S.createManipulatorDragHandler(i,(function(e){return P.withHistoryInfo(P.createXYConstrainedFromProject(m.createForGraphicAtLocation(n.view,n.graphic,e.elevationAlignedLocation),e.location.spatialReference))}),(function(e){return n._perVertexManipulatorDragAction(r,e)}))),i.events.on("immediate-click",(function(e){return n._manipulatorClickCallback(e,r)})),i},t.prototype._setTypeSpecificManipulatorSettings=function(e,t){switch(t.type){case"vertex":e.state=O.Vertex,e.selectable=!0,e.cursor="move",e.collisionPriority=2,e.hideOnGrab=!0;break;case"edge":e.state=O.Edge,e.selectable=!1,e.cursor="copy",e.collisionPriority=1,e.hideOnGrab=!1;break;default:a.neverReached(t)}},t.prototype._watchAndUpdateGrabState=function(e){var t=this;return e.events.on("grab",(function(e){"start"===e.action?t._numGrabbing++:(t._numGrabbing--,t._updateEventState(0))}))},t.prototype._removeManipulator=function(e){e&&(this._manipulatorHandles.remove(e.manipulator),this._manipulatorInfos.splice(this._manipulatorInfos.indexOf(e),1),this.manipulators.remove(e.manipulator))},t.prototype._getManipulatorInfoFromHandle=function(e){if(e)for(var t=0,n=this._manipulatorInfos;t<n.length;t++){var i=n[t];if(e===i.handle)return i}return null},t.prototype._updateManipulatorPosition=function(e){if(e){var t=l.expect(this._reshapeHelper);"vertex"===e.handle.type?e.manipulator.location=t.getVertexPositionAsPoint(e.handle,M):"edge"===e.handle.type&&(e.manipulator.location=t.getEdgePositionAsPoint(e.handle,.5,M))}},t.prototype._splitEdgeManipulator=function(e){var t=l.expect(this._reshapeHelper).splitEdge(e.handle,.5),n=e;return n.handle=t,this._setTypeSpecificManipulatorSettings(e.manipulator,e.handle),t.left&&this._createPerVertexManipulator(t.left),t.right&&this._createPerVertexManipulator(t.right),n},t.prototype._updateMoveZManipulatorPosition=function(){if(!l.isNone(this._moveZManipulator)){var e=b.sv3d.get();d.vec3.set(e,0,0,0);for(var t=0,n=0,i=this._manipulatorInfos;n<i.length;n++){var r=i[n];w(r)&&r.manipulator.selected&&(t++,d.vec3.add(e,e,r.manipulator.renderLocation))}if(0!==t&&(d.vec3.scale(e,e,1/t),M.spatialReference=l.expect(this._reshapeHelper).geometry.spatialReference,this.view.renderCoordsHelper.fromRenderCoords(e,M)))return void(this._moveZManipulator.elevationAlignedLocation=M);v.placeManipulatorAtGraphic(this._moveZManipulator,this.graphic)}},t.prototype._removeVertices=function(e){for(var t=[],n=l.expect(this._reshapeHelper),i=0,r=e;i<r.length;i++){var a=r[i];if("vertex"===a.handle.type&&n.canRemoveVertex(a.handle)){t.push(a.handle.unnormalizedPos),this._removeManipulator(a),this._removeManipulator(this._getManipulatorInfoFromHandle(a.handle.left)),this._removeManipulator(this._getManipulatorInfoFromHandle(a.handle.right));var o=n.removeVertex(a.handle);o&&this._createPerVertexManipulator(o)}}if(t.length>0){this.outputGeometry=n.commit();var s=this._updateEventState(2);this.emit("vertex-remove",{type:"vertex-remove",removed:t}),s&&this._updateEventState(0),this._updateMoveZManipulatorPosition()}},t.prototype._manipulatorClickCallback=function(e,t){if("vertex"===t.handle.type&&2===e.button&&this._removeVertices([t]),A(t)&&0===e.button){var n=this._splitEdgeManipulator(t);this.outputGeometry=l.expect(this._reshapeHelper).commit();var i=this._updateEventState(2);this.emit("vertex-add",{type:"vertex-add",added:[n.handle.unnormalizedPos]}),i&&this._updateEventState(0)}e.stopPropagation()},n([u.property({constructOnly:!0})],t.prototype,"view",void 0),n([u.property({constructOnly:!0})],t.prototype,"graphic",void 0),n([u.property()],t.prototype,"inputGeometry",null),n([u.property()],t.prototype,"outputGeometry",void 0),n([u.property({constructOnly:!0})],t.prototype,"manipulators",void 0),n([u.subclass("esri.views.3d.interactive.editingTools.graphicReshape3D.ReshapeOperation")],t)}(u.declared(o.EventedAccessor));t.ReshapeOperation=C;var O,M=p.makeDehydratedPoint(0,0,null,null);!function(e){e.Vertex=16,e.Edge=32}(O||(O={}))}).apply(null,i))||(e.exports=r)},dXKx:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("pcDC"),n("LxLY"),n("x7Wq"),n("CF4u"),n("NsXp"),n("Z91k"),n("35hF")],void 0===(r=(function(e,t,n,i,r,a,o,s,l){Object.defineProperty(t,"__esModule",{value:!0}),t.defaultPointSymbol2D=o.fromJSON(l.defaultPointSymbolJSON),t.defaultPolylineSymbol2D=a.fromJSON(l.defaultPolylineSymbolJSON),t.defaultPolygonSymbol2D=r.fromJSON(l.defaultPolygonSymbolJSON),t.defaultTextSymbol2D=s.fromJSON(l.defaultTextSymbolJSON),t.getDefaultSymbol2D=function(e){if(i.isNone(e))return null;switch(e.type){case"mesh":return null;case"point":case"multipoint":return t.defaultPointSymbol2D;case"polyline":return t.defaultPolylineSymbol2D;case"polygon":case"extent":return t.defaultPolygonSymbol2D;default:n.neverReached(e)}return null},t.errorPointSymbol2D=o.fromJSON(l.errorPointSymbolJSON),t.errorPolylineSymbol2D=a.fromJSON(l.errorPolylineSymbolJSON),t.errorPolygonSymbol2D=r.fromJSON(l.errorPolygonSymbolJSON)}).apply(null,i))||(e.exports=r)},eYHx:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateAmbientOcclusion=function(e,t){var o=e.fragment;t.receiveAmbientOcclusion?(o.uniforms.add("ssaoTex","sampler2D"),o.uniforms.add("viewportPixelSz","vec4"),o.code.add(i.glsl(r||(r=n(["\n      float evaluateAmbientOcclusion() {\n        return 1.0 - texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n      }\n\n      float evaluateAmbientOcclusionInverse() {\n        float ssao = texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        return viewportPixelSz.z < 0.0 ? 1.0 : ssao;\n      }\n    "],["\n      float evaluateAmbientOcclusion() {\n        return 1.0 - texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n      }\n\n      float evaluateAmbientOcclusionInverse() {\n        float ssao = texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        return viewportPixelSz.z < 0.0 ? 1.0 : ssao;\n      }\n    "]))))):o.code.add(i.glsl(a||(a=n(["\n      float evaluateAmbientOcclusion() { return 0.0; } // no occlusion\n      float evaluateAmbientOcclusionInverse() { return 1.0; }\n    "],["\n      float evaluateAmbientOcclusion() { return 0.0; } // no occlusion\n      float evaluateAmbientOcclusionInverse() { return 1.0; }\n    "]))))}}).apply(null,i))||(e.exports=r)},fese:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("0LE5"),n("Rdxj"),n("7Aei")],void 0===(r=(function(e,t,n,i,r,a){function o(e,t){t.slicePlaneEnabled?(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.uniforms.add("slicePlaneOrigin","vec3"),e.fragment.uniforms.add("slicePlaneBasis1","vec3"),e.fragment.uniforms.add("slicePlaneBasis2","vec3"),e.fragment.code.add(a.glsl(s||(s=n(["\n      struct SliceFactors {\n        float front;\n        float side0;\n        float side1;\n        float side2;\n        float side3;\n      };\n\n      SliceFactors calculateSliceFactors(vec3 pos) {\n        vec3 rel = pos - slicePlaneOrigin;\n\n        vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);\n        float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);\n\n        float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);\n        float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);\n\n        float basis1Dot = dot(slicePlaneBasis1, rel);\n        float basis2Dot = dot(slicePlaneBasis2, rel);\n\n        return SliceFactors(\n          dot(slicePlaneNormal, pos) + slicePlaneW,\n          -basis1Dot - basis1Len2,\n          basis1Dot - basis1Len2,\n          -basis2Dot - basis2Len2,\n          basis2Dot - basis2Len2\n        );\n      }\n\n      bool sliceByFactors(SliceFactors factors) {\n        return factors.front < 0.0\n          && factors.side0 < 0.0\n          && factors.side1 < 0.0\n          && factors.side2 < 0.0\n          && factors.side3 < 0.0;\n      }\n\n      bool sliceByPlane(vec3 pos) {\n        return sliceByFactors(calculateSliceFactors(pos));\n      }\n\n      vec4 applySliceHighlight(vec4 color, vec3 pos) {\n        SliceFactors factors = calculateSliceFactors(pos);\n\n        if (sliceByFactors(factors)) {\n          return color;\n        }\n\n        const float HIGHLIGHT_WIDTH = 1.0;\n        const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);\n\n        factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n        factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n        factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n        factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n        factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n\n        float highlightFactor = (1.0 - step(0.5, factors.front))\n          * (1.0 - step(0.5, factors.side0))\n          * (1.0 - step(0.5, factors.side1))\n          * (1.0 - step(0.5, factors.side2))\n          * (1.0 - step(0.5, factors.side3));\n\n        return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n      }\n      #define rejectBySlice(_pos_) sliceByPlane(_pos_)\n      #define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n      "],["\n      struct SliceFactors {\n        float front;\n        float side0;\n        float side1;\n        float side2;\n        float side3;\n      };\n\n      SliceFactors calculateSliceFactors(vec3 pos) {\n        vec3 rel = pos - slicePlaneOrigin;\n\n        vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);\n        float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);\n\n        float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);\n        float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);\n\n        float basis1Dot = dot(slicePlaneBasis1, rel);\n        float basis2Dot = dot(slicePlaneBasis2, rel);\n\n        return SliceFactors(\n          dot(slicePlaneNormal, pos) + slicePlaneW,\n          -basis1Dot - basis1Len2,\n          basis1Dot - basis1Len2,\n          -basis2Dot - basis2Len2,\n          basis2Dot - basis2Len2\n        );\n      }\n\n      bool sliceByFactors(SliceFactors factors) {\n        return factors.front < 0.0\n          && factors.side0 < 0.0\n          && factors.side1 < 0.0\n          && factors.side2 < 0.0\n          && factors.side3 < 0.0;\n      }\n\n      bool sliceByPlane(vec3 pos) {\n        return sliceByFactors(calculateSliceFactors(pos));\n      }\n\n      vec4 applySliceHighlight(vec4 color, vec3 pos) {\n        SliceFactors factors = calculateSliceFactors(pos);\n\n        if (sliceByFactors(factors)) {\n          return color;\n        }\n\n        const float HIGHLIGHT_WIDTH = 1.0;\n        const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);\n\n        factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n        factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n        factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n        factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n        factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n\n        float highlightFactor = (1.0 - step(0.5, factors.front))\n          * (1.0 - step(0.5, factors.side0))\n          * (1.0 - step(0.5, factors.side1))\n          * (1.0 - step(0.5, factors.side2))\n          * (1.0 - step(0.5, factors.side3));\n\n        return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n      }\n      #define rejectBySlice(_pos_) sliceByPlane(_pos_)\n      #define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n      "])))),e.fragment.code.add(a.glsl(t.sliceHighlightDisabled?l||(l=n(["\n        #define highlightSlice(_color_, _pos_) (_color_)\n      "],["\n        #define highlightSlice(_color_, _pos_) (_color_)\n      "])):c||(c=n(["\n      #define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\n    "],["\n      #define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\n    "]))))):e.fragment.code.add(a.glsl(u||(u=n(["\n      #define rejectBySlice(_pos_) false\n      #define discardBySlice(_pos_) {}\n      #define highlightSlice(_color_, _pos_) (_color_)\n    "],["\n      #define rejectBySlice(_pos_) false\n      #define discardBySlice(_pos_) {}\n      #define highlightSlice(_color_, _pos_) (_color_)\n    "]))))}Object.defineProperty(t,"__esModule",{value:!0}),t.Slice=o,function(e){e.bindUniformsWithOrigin=function(t,n,i){e.bindUniforms(t,n,i.slicePlane,i.origin)},e.bindUniforms=function(e,t,n,r){t.slicePlaneEnabled&&(r?(i.vec3.subtract(d,n.origin,r),e.setUniform3fv("slicePlaneOrigin",d)):e.setUniform3fv("slicePlaneOrigin",n.origin),e.setUniform3fv("slicePlaneBasis1",n.basis1),e.setUniform3fv("slicePlaneBasis2",n.basis2))}}(o=t.Slice||(t.Slice={}));var s,l,c,u,d=r.vec3f64.create()}).apply(null,i))||(e.exports=r)},"ff/U":function(e,t,n){var i,r;i=[n.dj.c(e.i),t],void 0===(r=(function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.Default3D={position:0,normal:1,normalCompressed:1,uv0:2,color:3,instanceColor:3,size:4,tangent:4,auxpos1:5,symbolColor:5,componentIndex:5,auxpos2:6,featureAttribute:6,instanceFeatureAttribute:6,region:7,model:8,modelNormal:12,modelOriginHi:11,modelOriginLo:15}}).apply(null,i))||(e.exports=r)},hlOa:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("qKT0"),n("2Atf"),n("LxLY"),n("fese"),n("3kdR"),n("PaEL"),n("W/V4"),n("FQ4r"),n("lBa0"),n("ff/U"),n("1eB5"),n("G0ER"),n("qbr3")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v){Object.defineProperty(t,"__esModule",{value:!0});var m=function(t){function i(e,n){var i=t.call(this,e,n)||this;return i.stipplePattern=null,i.stippleTextureBind=null,i.stippleTextureRepository=e.stippleTextureRepository,i}return n(i,t),i.prototype.initializeProgram=function(e){var t=i.shader.get(),n=this.configuration,r=t.build({output:n.output,attributeColor:n.vertexColors,slicePlaneEnabled:n.slicePlaneEnabled,sliceHighlightDisabled:n.sliceHighlightDisabled,stippleEnabled:n.stippleEnabled,stippleOffColorEnabled:n.stippleOffColorEnabled,stippleUVMaxEnabled:!1,stippleIntegerRepeatsEnabled:n.stippleIntegerRepeatsEnabled});return new h(e.rctx,r.generateSource("vertex"),r.generateSource("fragment"),p.Default3D)},i.prototype.dispose=function(){t.prototype.dispose.call(this),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null},i.prototype.bindPass=function(e,t,n){if(this.stipplePattern!==t.stipplePattern){var i=t.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,i),this.stipplePattern=i}if(this.configuration.stippleEnabled){var r=a.isSome(this.stippleTextureBind)?this.stippleTextureBind(e,0)*n.pixelRatio:1;this.program.setUniform1i("stipplePatternTexture",0),this.program.setUniform1f("stipplePatternPixelSizeInv",1/r),this.program.setUniform2f("ndcToPixel",n.viewport[2]/2,n.viewport[3]/2)}if(0===this.configuration.output){if(this.program.setUniform4fv("constantColor",t.color),this.program.setUniform1f("alphaCoverage",Math.min(1,t.width*n.pixelRatio)),this.configuration.stippleOffColorEnabled){var o=a.expect(t.stippleOffColor);this.program.setUniform4f("stippleOffColor",o[0],o[1],o[2],o.length>3?o[3]:1)}}else l.OutputHighlight.bindOutputHighlight(e,this.program,n)},i.prototype.bindDraw=function(e){s.Transform.bindUniforms(this.program,e),o.Slice.bindUniformsWithOrigin(this.program,this.configuration,e)},i.prototype.initializePipeline=function(){var e=this.configuration;return v.makePipelineState(0===e.output?{blending:e.transparent||e.stippleEnabled?v.separateBlendingParams(770,1,771,771):null,depthTest:{func:513},depthWrite:v.defaultDepthWriteParams,colorWrite:v.defaultColorWriteParams}:{depthTest:{func:513},colorWrite:v.defaultColorWriteParams})},i.prototype.bindPipelineState=function(e){e.setPipelineState(this.pipeline)},i.shader=new c.ReloadableShaderModule(f,"./NativeLine.glsl",e),i}(u.ShaderTechnique);t.NativeLineTechnique=m;var g=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.output=0,t.slicePlaneEnabled=!1,t.sliceHighlightDisabled=!1,t.vertexColors=!1,t.transparent=!1,t.stippleEnabled=!1,t.stippleOffColorEnabled=!1,t.stippleIntegerRepeatsEnabled=!1,t}return n(t,e),i([d.parameter({count:6})],t.prototype,"output",void 0),i([d.parameter()],t.prototype,"slicePlaneEnabled",void 0),i([d.parameter()],t.prototype,"sliceHighlightDisabled",void 0),i([d.parameter()],t.prototype,"vertexColors",void 0),i([d.parameter()],t.prototype,"transparent",void 0),i([d.parameter()],t.prototype,"stippleEnabled",void 0),i([d.parameter()],t.prototype,"stippleOffColorEnabled",void 0),i([d.parameter()],t.prototype,"stippleIntegerRepeatsEnabled",void 0),t}(d.ShaderTechniqueConfiguration);t.NativeLineTechniqueConfiguration=g}).apply(null,i))||(e.exports=r)},hsRy:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("Q2wQ"),n("HZ3d"),n("qsST"),n("DIqE"),n("weRx"),n("Zp3t")],void 0===(r=(function(e,t,n,i,r,a,o,s){Object.defineProperty(t,"__esModule",{value:!0});var l=r.getLogger("esri.views.3d.webgl-engine.materials.internal.waterMaterialUtils");t.waterParameterDefaultsLocal={waveTexture:e.toUrl("../../../../../images/materials/water/normals.jpg"),perturbationTexture:e.toUrl("../../../../../images/materials/water/perturbation.jpg"),waveStrength:.06,waveTextureRepeat:32,waveDirection:a.vec2f64.fromValues(1,0),waveVelocity:.05,flowStrength:.015,flowOffset:-.5,animationSpeed:.35,color:[0,.35686,.4,1],transparent:!1,writeDepth:!0,slicePlaneEnabled:!1,isDraped:!1,receiveShadows:!0},t.wavePresets={"calm-small":{waveStrength:.005,perturbationStrength:.02,textureRepeat:12,waveVelocity:.01},"rippled-small":{waveStrength:.02,perturbationStrength:.09,textureRepeat:32,waveVelocity:.07},"slight-small":{waveStrength:.05,perturbationStrength:.07,textureRepeat:28,waveVelocity:.1},"moderate-small":{waveStrength:.075,perturbationStrength:.07,textureRepeat:24,waveVelocity:.1},"calm-medium":{waveStrength:.003125,perturbationStrength:.01,textureRepeat:8,waveVelocity:.02},"rippled-medium":{waveStrength:.035,perturbationStrength:.015,textureRepeat:12,waveVelocity:.07},"slight-medium":{waveStrength:.06,perturbationStrength:.015,textureRepeat:8,waveVelocity:.12},"moderate-medium":{waveStrength:.09,perturbationStrength:.03,textureRepeat:4,waveVelocity:.12},"calm-large":{waveStrength:.01,perturbationStrength:0,textureRepeat:4,waveVelocity:.05},"rippled-large":{waveStrength:.025,perturbationStrength:.01,textureRepeat:8,waveVelocity:.11},"slight-large":{waveStrength:.06,perturbationStrength:.02,textureRepeat:3,waveVelocity:.13},"moderate-large":{waveStrength:.14,perturbationStrength:.03,textureRepeat:2,waveVelocity:.15}};var c=function(){function e(){this.loadingCount=0,this.data=[],this.loadingState=0}return e.prototype.loadTexture=function(e,t,r){return i(this,void 0,void 0,(function(){var i,a;return n(this,(function(n){switch(n.label){case 0:this.loadingCount++,n.label=1;case 1:return n.trys.push([1,3,,4]),[4,o.requestImage(r)];case 2:return i=n.sent(),this.data[t]=new s(e,this.getTextureProps(i.width,i.height,!0),i),[3,4];case 3:return a=n.sent(),l.warn("Failed to load texture for water material.",a),this.data[t]=new s(e,this.getTextureProps(1,1,!0)),[3,4];case 4:return this.loadingCount--,[2]}}))}))},e.prototype.getTextureProps=function(e,t,n){return void 0===n&&(n=!1),{target:3553,pixelFormat:6408,dataType:5121,wrapMode:10497,samplingMode:9987,hasMipmap:n,maxAnisotropy:8,width:e,height:t}},e.prototype.ready=function(){return 2===this.loadingState||1===this.loadingState&&0===this.loadingCount&&(this.loadingState=2,!0)},e.prototype.loading=function(){return 1===this.loadingState},e.prototype.initialize=function(e,t){for(var n=0;n<t.length;n++)this.loadTexture(e,n,t[n]);this.loadingState=1},e.prototype.bindRepo=function(e){for(var t=0;t<this.data.length;t++)e.bindTexture(this.data[t],t)},e}();t.waterTextureRepo=new c}).apply(null,i))||(e.exports=r)},jl7D:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("cmSR"),n("fese"),n("3kdR"),n("pLfv"),n("cj3m"),n("vGsU"),n("RdU/"),n("7Aei"),n("aExC")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d){var p,f,h,v,m,g,y,b,x;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new d.ShaderBuilder;return t.include(a.Transform,{linearDepth:!1}),t.attributes.add("position","vec3"),t.attributes.add("uv0","vec2"),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4").add("localOrigin","vec3"),0===e.output&&(t.include(o.NormalUtils,e),t.include(i.ForwardLinearDepth,e),t.varyings.add("vuv","vec2"),t.varyings.add("vpos","vec3"),t.varyings.add("vnormal","vec3"),t.varyings.add("vtbnMatrix","mat3"),t.vertex.code.add(u.glsl(p||(p=n(["\n      void main(void) {\n        vuv = uv0;\n        vpos = (model * vec4(position, 1.0)).xyz;\n\n        vnormal = getLocalUp(vpos, localOrigin);\n        vtbnMatrix = getTBNMatrix(vnormal);\n\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardLinearDepth();\n      }\n    "],["\n      void main(void) {\n        vuv = uv0;\n        vpos = (model * vec4(position, 1.0)).xyz;\n\n        vnormal = getLocalUp(vpos, localOrigin);\n        vtbnMatrix = getTBNMatrix(vnormal);\n\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardLinearDepth();\n      }\n    "])))),t.include(c.WaterDistortion,e),t.include(r.Slice,e),e.receiveShadows&&t.include(s.ReadShadowMap,e),t.include(l.Water,e),t.fragment.uniforms.add("waterColor","vec4").add("lightingMainDirection","vec3").add("lightingMainIntensity","vec3").add("camPos","vec3").add("timeElapsed","float"),t.fragment.code.add(u.glsl(f||(f=n(["\n      void main() {\n        discardBySlice(vpos);\n        vec3 localUp = vnormal;\n        // the created normal is in tangent space\n        vec3 tangentNormal = getSurfaceNormal(vuv, timeElapsed);\n\n        // we rotate the normal according to the tangent-bitangent-normal-Matrix\n        vec3 n = normalize(vtbnMatrix * tangentNormal);\n        vec3 v = -normalize(vpos - camPos);\n        vec3 l = normalize(-lightingMainDirection);\n        "],["\n      void main() {\n        discardBySlice(vpos);\n        vec3 localUp = vnormal;\n        // the created normal is in tangent space\n        vec3 tangentNormal = getSurfaceNormal(vuv, timeElapsed);\n\n        // we rotate the normal according to the tangent-bitangent-normal-Matrix\n        vec3 n = normalize(vtbnMatrix * tangentNormal);\n        vec3 v = -normalize(vpos - camPos);\n        vec3 l = normalize(-lightingMainDirection);\n        "])))),t.fragment.code.add(u.glsl(e.receiveShadows?h||(h=n(["\n        float shadow = 1.0 - readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow = 1.0 - readShadowMap(vpos, linearDepth);\n      "])):v||(v=n(["\n        float shadow = 1.0;\n      "],["\n        float shadow = 1.0;\n      "])))),t.fragment.code.add(u.glsl(m||(m=n(["\n        vec4 final = vec4(getSeaColor(n, v, l, waterColor.rgb, lightingMainIntensity, localUp, shadow), waterColor.w);\n\n        // gamma correction\n        gl_FragColor = delinearizeGamma(final);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n        vec4 final = vec4(getSeaColor(n, v, l, waterColor.rgb, lightingMainIntensity, localUp, shadow), waterColor.w);\n\n        // gamma correction\n        gl_FragColor = delinearizeGamma(final);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "]))))),2===e.output&&(t.include(o.NormalUtils,e),t.include(c.WaterDistortion,e),t.include(r.Slice,e),t.varyings.add("vpos","vec3"),t.varyings.add("vuv","vec2"),t.vertex.code.add(u.glsl(g||(g=n(["\n        void main(void) {\n          vuv = uv0;\n          vpos = (model * vec4(position, 1.0)).xyz;\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vuv = uv0;\n          vpos = (model * vec4(position, 1.0)).xyz;\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "])))),t.fragment.uniforms.add("timeElapsed","float"),t.fragment.code.add(u.glsl(y||(y=n(["\n        void main() {\n          discardBySlice(vpos);\n          // the created normal is in tangent space\n          vec3 tangentNormal = getSurfaceNormal(vuv, timeElapsed);\n          tangentNormal = normalize(tangentNormal);\n          gl_FragColor = vec4((tangentNormal + vec3(1.0)) * 0.5, 0.0);\n        }\n    "],["\n        void main() {\n          discardBySlice(vpos);\n          // the created normal is in tangent space\n          vec3 tangentNormal = getSurfaceNormal(vuv, timeElapsed);\n          tangentNormal = normalize(tangentNormal);\n          gl_FragColor = vec4((tangentNormal + vec3(1.0)) * 0.5, 0.0);\n        }\n    "]))))),5===e.output&&(t.include(o.NormalUtils,e),t.varyings.add("vpos","vec3"),t.vertex.code.add(u.glsl(b||(b=n(["\n        void main(void) {\n          vpos = (model * vec4(position, 1.0)).xyz;\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vpos = (model * vec4(position, 1.0)).xyz;\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "])))),t.fragment.uniforms.add("waterColor","vec4"),t.fragment.code.add(u.glsl(x||(x=n(["\n        void main() {\n          gl_FragColor = waterColor;\n        }\n    "],["\n        void main() {\n          gl_FragColor = waterColor;\n        }\n    "]))))),t}}).apply(null,i))||(e.exports=r)},juLw:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o;Object.defineProperty(t,"__esModule",{value:!0}),t.AnalyticalSkyModel=function(e){var t=e.fragment.code;t.add(i.glsl(r||(r=n(["\n    vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)\n    {\n      return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n    }\n    "],["\n    vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)\n    {\n      return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n    }\n    "])))),t.add(i.glsl(a||(a=n(["\n    float integratedRadiance(float cosTheta2, float roughness)\n    {\n      return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);\n    }\n    "],["\n    float integratedRadiance(float cosTheta2, float roughness)\n    {\n      return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);\n    }\n    "])))),t.add(i.glsl(o||(o=n(["\n    vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)\n    {\n      float cosTheta2 = 1.0 - RdotNG * RdotNG;\n      float intRadTheta = integratedRadiance(cosTheta2, roughness);\n\n      // Calculate the integrated directional radiance of the ground and the sky\n      float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;\n      float sky = 2.0 - ground;\n      return (ground * ambientGround + sky * ambientSky) * 0.5;\n    }\n    "],["\n    vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)\n    {\n      float cosTheta2 = 1.0 - RdotNG * RdotNG;\n      float intRadTheta = integratedRadiance(cosTheta2, roughness);\n\n      // Calculate the integrated directional radiance of the ground and the sky\n      float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;\n      float sky = 2.0 - ground;\n      return (ground * ambientGround + sky * ambientSky) * 0.5;\n    }\n    "]))))}}).apply(null,i))||(e.exports=r)},lBa0:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xoE+")],void 0===(r=(function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.ShaderTechniqueConfiguration=function(){this.key=0},t.parameter=function(e){return void 0===e&&(e={}),function(t,i){var r=t;r.__configurationParameters=r.__configurationParameters||[],r.__configurationParameters.push(i);var a="_"+i;void 0===r.__configurationParameters__offset&&(r.__configurationParameters__offset=0);var o=r.__configurationParameters__offset,s=Math.ceil(n.log2(e.count||2)),l=(1<<s)-1<<o;if(r.__configurationParameters__offset+=s,r.__configurationParameters__offset>=32)throw new Error("ShaderTechniqueConfiguration is too complex, requiring more than 32 bits to encode.\n      Either the configuration must be simplified, or this restriction must be relaxed.(Currently used: "+r.__configurationParameters__offset+")");Object.defineProperty(r,i,{get:function(){return this[a]},set:function(e){this.key=this.key&~l|e<<o&l,this[a]=e}})}}}).apply(null,i))||(e.exports=r)},lF8C:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureCoordinateAttribute=function(e,t){1===t.attributeTextureCoordinates&&(e.attributes.add("uv0","vec2"),e.varyings.add("vuv0","vec2"),e.vertex.code.add(i.glsl(r||(r=n(["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n      }\n    "],["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n      }\n    "]))))),2===t.attributeTextureCoordinates&&(e.attributes.add("uv0","vec2"),e.varyings.add("vuv0","vec2"),e.attributes.add("uvRegion","vec4"),e.varyings.add("vuvRegion","vec4"),e.vertex.code.add(i.glsl(a||(a=n(["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n        vuvRegion = uvRegion;\n      }\n    "],["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n        vuvRegion = uvRegion;\n      }\n    "]))))),0===t.attributeTextureCoordinates&&e.vertex.code.add(i.glsl(o||(o=n(["\n      void forwardTextureCoordinates() {}\n    "],["\n      void forwardTextureCoordinates() {}\n    "]))))}}).apply(null,i))||(e.exports=r)},m4lJ:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("H1tY"),n("LxLY"),n("VCyw"),n("1m5D"),n("0LE5"),n("Rdxj"),n("aWgr"),n("9DjX")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c){var u=n("dojo-debug-messages"),d=1e-5;return function(){function e(e){this.options=new c.IntersectorOptions,this.results=new c.IntersectorResults,this.transform=new c.IntersectorTransform,this.performanceInfo={queryDuration:0,numObjectsTested:0},this.tolerance=d,this._ray={origin:s.vec3f64.create(),direction:s.vec3f64.create()},this._rayEndPoint=s.vec3f64.create(),this._rayStartPointTransformed=s.vec3f64.create(),this._rayEndPointTransformed=s.vec3f64.create(),this.viewingMode=e||"global"}return Object.defineProperty(e.prototype,"ray",{get:function(){return this._ray},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"rayBeginPoint",{get:function(){return this._ray.origin},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"rayEndPoint",{get:function(){return this._rayEndPoint},enumerable:!0,configurable:!0}),e.prototype.reset=function(e,t){this.resetWithRay(l.ray.fromPoints(e,t,this._ray))},e.prototype.resetWithRay=function(e){e!==this._ray&&l.ray.copy(e,this._ray),o.vec3.add(this._rayEndPoint,this._ray.origin,this._ray.direction),this._numObjectsTested=0,this.results.init(this._ray)},e.prototype.intersect=function(e,t,n,a,o,s){var l=this;this.point=t,this.camera=n,this.filterPredicate=o,this.tolerance=null==a?d:a;var c,p=i.isSome(this.options.verticalOffset)?this.options.verticalOffset.object3D:null;u&&(c=r());var f=s?function(e){s(e)&&l.intersectObject(e)}:function(e){l.intersectObject(e)};if(e&&e.length>0)for(var h=0,v=e;h<v.length;h++){var m=v[h],g=m.getSpatialQueryAccelerator?m.getSpatialQueryAccelerator():void 0;if(g)p?g.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,f,p):g.forEachAlongRay(this._ray.origin,this._ray.direction,f),this.options.selectionMode&&this.options.hud&&g.forEachDegenerateObject(f);else for(var y=0,b=m.getObjects();y<b.length;y++)f(b[y])}this.sortResults(),u&&(this.performanceInfo.queryDuration=r()-c,this.performanceInfo.numObjectsTested=this._numObjectsTested)},e.prototype.intersectObject=function(e){var t=this;this._numObjectsTested++;var n=e.geometryRecords;if(n)for(var r,s=e.id,l=e.objectTransformation,u=i.isSome(this.options.verticalOffset)?this.options.verticalOffset.object3D:null,d=this,p=0,f=n;p<f.length;p++)!function(n){var p=n.geometry,f=n.material,h=n.instanceParameters;if(h.hidden)return"continue";r=p.id,d.transform.setAndInvalidateLazyTransforms(l,n.getShaderTransformation()),o.vec3.transformMat4(d._rayStartPointTransformed,d._ray.origin,d.transform.inverse),o.vec3.transformMat4(d._rayEndPointTransformed,d._rayEndPoint,d.transform.inverse);var v=d.transform.transform;i.isSome(u)&&(u.objectTransform=d.transform),f.intersect(p,h,d.transform.transform,d,d._rayStartPointTransformed,d._rayEndPointTransformed,(function(n,i,o,l,u,d){if(n>=0){if(null!=t.filterPredicate&&!t.filterPredicate(t._ray.origin,t._rayEndPoint,n))return;if(u)return void((null==t.results.hud.dist||n<t.results.hud.dist)&&t.results.hud.set(e,s,n,i,a.mat4f64.IDENTITY,l,d,r,o));var p=function(t){return t.set(e,s,n,i,v,l,null,r,o)};if((null==t.results.min.drapedLayerOrder||l>=t.results.min.drapedLayerOrder)&&(null==t.results.min.dist||n<t.results.min.dist)&&p(t.results.min),0!==t.options.store&&(null==t.results.max.drapedLayerOrder||l<t.results.max.drapedLayerOrder)&&(null==t.results.max.dist||n>t.results.max.dist)&&p(t.results.max),2===t.options.store){var f=new c.IntersectorResult(t._ray);p(f),t.results.all.push(f)}}}),n.shaderTransformation)}(f[p])},e.prototype.sortResults=function(){this.results.all.sort((function(e,t){return e.dist!==t.dist?e.dist-t.dist:e.drapedLayerOrder!==t.drapedLayerOrder?(void 0!==e.drapedLayerOrder?e.drapedLayerOrder:Number.MAX_VALUE)-(void 0!==t.drapedLayerOrder?t.drapedLayerOrder:Number.MAX_VALUE):(void 0!==t.drapedLayerGraphicOrder?t.drapedLayerGraphicOrder:Number.MIN_VALUE)-(void 0!==e.drapedLayerGraphicOrder?e.drapedLayerGraphicOrder:Number.MIN_VALUE)}))},e.DEFAULT_TOLERANCE=d,e}()}).apply(null,i))||(e.exports=r)},mOGR:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("lF8C"),n("nJqw"),n("7Aei")],void 0===(r=(function(e,t,n,i,r,a){var o,s,l;Object.defineProperty(t,"__esModule",{value:!0}),t.VertexTextureCoordinates=function(e,t){e.include(i.TextureCoordinateAttribute,t),e.fragment.code.add(a.glsl(o||(o=n(["\n  struct TextureLookupParameter {\n    vec2 uv;\n    ","\n  } vtc;\n  "],["\n  struct TextureLookupParameter {\n    vec2 uv;\n    ","\n  } vtc;\n  "])),t.supportsTextureAtlas?"vec2 size;":"")),1===t.attributeTextureCoordinates&&e.fragment.code.add(a.glsl(s||(s=n(["\n      vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return texture2D(tex, params.uv);\n      }\n    "],["\n      vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return texture2D(tex, params.uv);\n      }\n    "])))),2===t.attributeTextureCoordinates&&(e.include(r.TextureAtlasLookup),e.fragment.code.add(a.glsl(l||(l=n(["\n    vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return textureAtlasLookup(tex, params.size, params.uv, vuvRegion);\n      }\n    "],["\n    vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return textureAtlasLookup(tex, params.size, params.uv, vuvRegion);\n      }\n    "])))))}}).apply(null,i))||(e.exports=r)},mYMs:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("SyoC"),n("KBgh"),n("0LE5"),n("Rdxj"),n("aWgr"),n("CIy2")],void 0===(r=(function(e,t,n,i,r,a,o,s){function l(e,t,n){e[0]=Math.min(e[0],t[0]-n),e[1]=Math.min(e[1],t[1]-n),e[2]=Math.min(e[2],t[2]-n)}function c(e,t,n){e[0]=Math.max(e[0],t[0]+n),e[1]=Math.max(e[1],t[1]+n),e[2]=Math.max(e[2],t[2]+n)}function u(e,t,n){return(n=n||e)[0]=e[0]+t,n[1]=e[1]+t,n[2]=e[2]+t,n}function d(e,t,n){return!o.frustum.intersectsSphere(n.planes,o.sphere.wrap(t,e))}function p(e,t){for(var n=1/0,i=null,r=0;r<8;++r){var a=f(e,t,g[r]);a<n&&(n=a,i=g[r])}return i}function f(e,t,n){return t*(e[0]*n[0]+e[1]*n[1]+e[2]*n[2])}var h=function(){function e(e,t,n,i){this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._objectCount=0,this._objectToBoundingSphere=n,i&&(void 0!==i.maximumObjectsPerNode&&(this._maximumObjectsPerNode=i.maximumObjectsPerNode),void 0!==i.maximumDepth&&(this._maximumDepth=i.maximumDepth)),this._root=isNaN(e[0])||isNaN(e[1])||isNaN(e[2])||isNaN(t)?new v(null,a.vec3f64.fromValues(0,0,0),.5):new v(null,e,t/2)}return Object.defineProperty(e.prototype,"center",{get:function(){return this._root.center},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"size",{get:function(){return 2*this._root.halfSize},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"root",{get:function(){return this._root.node},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"maximumObjectsPerNode",{get:function(){return this._maximumObjectsPerNode},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"maximumDepth",{get:function(){return this._maximumDepth},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"objectCount",{get:function(){return this._objectCount},enumerable:!0,configurable:!0}),e.prototype.destroy=function(){this._degenerateObjects.clear(),this._root=null,v.clearPool(),b=[null],w.prune(),R.prune(),T.prune()},e.prototype.add=function(e,t){var n=this._objectOrObjectsArray(e);this._objectCount+=t=null==t?n.length:t,this._grow(n,t);for(var i=v.acquire(),r=0;r<t;r++){var a=n[r];i.init(this._root),this._isDegenerate(a)?this._degenerateObjects.add(a):this._add(a,i)}v.release(i)},e.prototype.remove=function(e,t){var n=this._objectOrObjectsArray(e);this._objectCount-=n.length;for(var i=v.acquire(),r=0;r<n.length;r++){var a=n[r],o=t||this._boundingSphereFromObject(a,A);this._isValidRadius(o.radius)?(i.init(this._root),this._remove(a,o,i)):this._degenerateObjects.delete(a)}v.release(i),this._shrink()},e.prototype.update=function(e,t){!this._isValidRadius(t.radius)&&this._isDegenerate(e)||(this.remove(e,t),this.add(e))},e.prototype.forEachAlongRay=function(e,t,n){var i=this,r=o.ray.wrap(e,t);this._forEachNode(this._root,(function(e){if(!i._intersectsNode(r,e))return!1;var t=e.node;return t.terminals.forEach((function(e){i._intersectsObject(r,e)&&n(e)})),null!==t.residents&&t.residents.forEach((function(e){i._intersectsObject(r,e)&&n(e)})),!0}))},e.prototype.forEachAlongRayWithVerticalOffset=function(e,t,n,i){var r=this,a=o.ray.wrap(e,t);this._forEachNode(this._root,(function(e){if(!r._intersectsNodeWithOffset(a,e,i))return!1;var t=e.node;return t.terminals.forEach((function(e){r._intersectsObjectWithOffset(a,e,i)&&n(e)})),null!==t.residents&&t.residents.forEach((function(e){r._intersectsObjectWithOffset(a,e,i)&&n(e)})),!0}))},e.prototype.forEach=function(e){this._forEachNode(this._root,(function(t){var n=t.node;return n.terminals.forEach(e),null!==n.residents&&n.residents.forEach(e),!0})),this._degenerateObjects.forEach(e)},e.prototype.forEachDegenerateObject=function(e){this._degenerateObjects.forEach(e)},e.prototype.findClosest=function(e,t,n,i,r){return this._findClosest(e,"front-to-back"===t?1:-1,n,i,r)},e.prototype.forEachInDepthRange=function(e,t,n,i,r,a,o,s){this._forEachInDepthRange(e,t,"front-to-back"===n?1:-1,i,r,a,o,s)},e.prototype.forEachNode=function(e){this._forEachNode(this._root,(function(t){return e(t.node,t.center,2*t.halfSize)}))},e.prototype._intersectsNode=function(e,t){return u(t.center,2*-t.halfSize,S),u(t.center,2*t.halfSize,P),s.rayBoxTest(e.origin,e.direction,S,P)},e.prototype._intersectsNodeWithOffset=function(e,t,n){return u(t.center,2*-t.halfSize,S),u(t.center,2*t.halfSize,P),n.applyToMinMax(S,P),s.rayBoxTest(e.origin,e.direction,S,P)},e.prototype._intersectsObject=function(e,t){var n=this._objectToBoundingSphere.getRadius(t);return!(n>0)||o.sphere.intersectsRay(o.sphere.wrap(n,this._objectToBoundingSphere.getCenter(t)),e)},e.prototype._intersectsObjectWithOffset=function(e,t,n){var i=this._objectToBoundingSphere.getRadius(t);return!(i>0)||o.sphere.intersectsRay(n.applyToBoundingSphere(i,this._objectToBoundingSphere.getCenter(t)),e)},e.prototype._forEachNode=function(e,t){for(var n=v.acquire().init(e),i=[n];0!==i.length;){if(t(n=i.pop())&&!n.isLeaf())for(var r=0;r<n.node.children.length;r++)n.node.children[r]&&i.push(v.acquire().init(n).advance(r));v.release(n)}},e.prototype._forEachNodeDepthOrdered=function(e,t,n,i){void 0===i&&(i=1);var r=v.acquire().init(e),a=[r];for(function(e,t,n){if(!R.length)for(var i=0;i<8;++i)R.push({index:0,distance:0});for(i=0;i<8;++i){var r=m[i];R.data[i].index=i,R.data[i].distance=f(e,t,r)}for(R.sort((function(e,t){return e.distance-t.distance})),n.clear(),i=0;i<8;++i)n.push(R.data[i].index)}(n,i,T);0!==a.length;){if(t(r=a.pop())&&!r.isLeaf())for(var o=7;o>=0;--o){var s=T.data[o];s>=r.node.children.length||r.node.children[s]&&a.push(v.acquire().init(r).advance(s))}v.release(r)}},e.prototype._findClosest=function(e,t,n,i,a){var o=this,s=1/0,l=1/0,c=null,u=p(e,t),h=0,v=function(r){if(++h,!i||i(r)){var a=o._objectToBoundingSphere.getCenter(r),u=o._objectToBoundingSphere.getRadius(r);if(!n||!d(a,u,n)){var p=f(e,t,a),v=p-u;v<s&&(s=v,l=p+u,c=r)}}};return this._forEachNodeDepthOrdered(this._root,(function(i){if(null!=a&&h>=a)return!1;if(n&&d(i.center,i.halfSize*y,n))return!1;if(r.vec3.scale(_,u,i.halfSize),r.vec3.add(_,_,i.center),f(e,t,_)>l)return!1;var o=i.node;return o.terminals.forEach((function(e){v(e)})),null!==o.residents&&o.residents.forEach((function(e){v(e)})),!0}),e,t),c},e.prototype._forEachInDepthRange=function(e,t,n,i,a,o,s,l){var c=this,u=-1/0,h=1/0,v={setRange:function(e){1===n?(u=Math.max(u,e.near),h=Math.min(h,e.far)):(u=Math.max(u,-e.far),h=Math.min(h,-e.near))}};v.setRange(i);var m=f(t,n,e),g=p(t,n),b=p(t,-1*n),x=0,S=function(e){if(++x,!s||s(e)){var i=c._objectToBoundingSphere.getCenter(e),r=c._objectToBoundingSphere.getRadius(e),l=f(t,n,i)-m;l-r>h||l+r<u||o&&d(i,r,o)||a(e,v)}};this._forEachNodeDepthOrdered(this._root,(function(e){if(null!=l&&x>=l)return!1;if(o&&d(e.center,e.halfSize*y,o))return!1;if(r.vec3.scale(_,g,e.halfSize),r.vec3.add(_,_,e.center),f(t,n,_)-m>h)return!1;if(r.vec3.scale(_,b,e.halfSize),r.vec3.add(_,_,e.center),f(t,n,_)-m<u)return!1;var i=e.node;return i.terminals.forEach((function(e){S(e)})),null!==i.residents&&i.residents.forEach((function(e){S(e)})),!0}),t,n)},e.prototype._objectOrObjectsArray=function(e){return Array.isArray(e)?e:(b[0]=e,b)},e.prototype._remove=function(e,t,n){w.clear();var i=n.advanceTo(t,(function(e,t){w.push(e.node),w.push(t)}))?n.node.terminals:n.node.residents;if(i.removeUnordered(e),0===i.length)for(var r=w.length-2;r>=0&&this._purge(w.data[r],w.data[r+1]);r-=2);},e.prototype._nodeIsEmpty=function(e){if(0!==e.terminals.length)return!1;if(null!==e.residents)return 0===e.residents.length;for(var t=0;t<e.children.length;t++)if(e.children[t])return!1;return!0},e.prototype._purge=function(e,t){return t>=0&&(e.children[t]=null),!!this._nodeIsEmpty(e)&&(null===e.residents&&(e.residents=new i({shrink:!0})),!0)},e.prototype._add=function(e,t){t.advanceTo(this._boundingSphereFromObject(e,A))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))},e.prototype._split=function(e){var t=e.node.residents;e.node.residents=null;for(var n=0;n<t.length;n++){var i=v.acquire().init(e);this._add(t.data[n],i),v.release(i)}},e.prototype._grow=function(e,t){var n=this;if(0!==t){var i=this._boundingSphereFromObjects(e,t,(function(e,t){return n._boundingSphereFromObject(e,t)}),C);if(this._isValidRadius(i.radius)&&!this._fitsInsideTree(i))if(this._nodeIsEmpty(this._root.node))r.vec3.copy(this._root.center,i.center),this._root.halfSize=1.25*i.radius;else{var a=v.acquire();this._rootBoundsForRootAsSubNode(i,a),this._placingRootViolatesMaxDepth(a)?this._rebuildTree(i,a):this._growRootAsSubNode(a),v.release(a)}}},e.prototype._rebuildTree=function(e,t){var n=this;r.vec3.copy(O.center,t.center),O.radius=t.halfSize;var i=this._boundingSphereFromObjects([e,O],2,(function(e){return e}),M),a=v.acquire().init(this._root);this._root.initFrom(null,i.center,1.25*i.radius),this._forEachNode(a,(function(e){return n.add(e.node.terminals.data,e.node.terminals.length),null!==e.node.residents&&n.add(e.node.residents.data,e.node.residents.length),!0})),v.release(a)},e.prototype._placingRootViolatesMaxDepth=function(e){var t=0;return this._forEachNode(this._root,(function(e){return t=Math.max(t,e.depth),!0})),t+Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E>this._maximumDepth},e.prototype._rootBoundsForRootAsSubNode=function(e,t){for(var n=e.radius,i=e.center,r=-1/0,a=this._root.center,o=this._root.halfSize,s=0;s<3;s++){var l=i[s]+n-(a[s]+o),c=Math.max(0,Math.ceil((a[s]-o-(i[s]-n))/(2*o))),u=Math.max(0,Math.ceil(l/(2*o)))+1,d=Math.pow(2,Math.ceil(Math.log(c+u)*Math.LOG2E));r=Math.max(r,d),D[s].min=c,D[s].max=u}for(s=0;s<3;s++){var p=(r-((c=D[s].min)+(u=D[s].max)))/2;c+=Math.ceil(p),u+=Math.floor(p),x[s]=a[s]-o-c*o*2+(u+c)*o}return t.initFrom(null,x,r*o,0)},e.prototype._growRootAsSubNode=function(e){var t=this._root.node;r.vec3.copy(C.center,this._root.center),C.radius=this._root.halfSize,this._root.init(e),e.advanceTo(C,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals},e.prototype._shrink=function(){for(;;){var e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0}},e.prototype._findShrinkIndex=function(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;for(var e=null,t=this._root.node.children,n=0,i=0;i<t.length&&null==e;)e=t[n=i++];for(;i<t.length;)if(t[i++])return-1;return n},e.prototype._isDegenerate=function(e){var t=this._objectToBoundingSphere.getRadius(e);return!this._isValidRadius(t)},e.prototype._isValidRadius=function(e){return!isNaN(e)&&e!==-1/0&&e!==1/0&&e>0},e.prototype._fitsInsideTree=function(e){var t=this._root.center,n=this._root.halfSize,i=e.center;return e.radius<=n&&i[0]>=t[0]-n&&i[0]<=t[0]+n&&i[1]>=t[1]-n&&i[1]<=t[1]+n&&i[2]>=t[2]-n&&i[2]<=t[2]+n},e.prototype._boundingSphereFromObject=function(e,t){return r.vec3.copy(t.center,this._objectToBoundingSphere.getCenter(e)),t.radius=this._objectToBoundingSphere.getRadius(e),t},e.prototype._boundingSphereFromObjects=function(e,t,n,i){if(1===t){var a=n(e[0],C);r.vec3.copy(i.center,a.center),i.radius=a.radius}else{S[0]=1/0,S[1]=1/0,S[2]=1/0,P[0]=-1/0,P[1]=-1/0,P[2]=-1/0;for(var o=0;o<t;o++)a=n(e[o],C),this._isValidRadius(a.radius)&&(l(S,a.center,a.radius),c(P,a.center,a.radius));r.vec3.lerp(i.center,S,P,.5),i.radius=Math.max(P[0]-S[0],P[1]-S[1],P[2]-S[2])/2}return i},e}(),v=function(){function e(e,t,n){void 0===n&&(n=0),this.center=a.vec3f64.create(),this.initFrom(e,t,n,0)}return e.prototype.init=function(e){return this.initFrom(e.node,e.center,e.halfSize,e.depth)},e.prototype.initFrom=function(t,n,i,a){return void 0===t&&(t=null),void 0===i&&(i=this.halfSize),void 0===a&&(a=this.depth),this.node=t||e.createEmptyNode(),n&&r.vec3.copy(this.center,n),this.halfSize=i,this.depth=a,this},e.prototype.advance=function(t){var n=this.node.children[t];n||(n=e.createEmptyNode(),this.node.children[t]=n),this.node=n,this.halfSize/=2,this.depth++;var i=m[t];return this.center[0]+=i[0]*this.halfSize,this.center[1]+=i[1]*this.halfSize,this.center[2]+=i[2]*this.halfSize,this},e.prototype.advanceTo=function(e,t,n){for(void 0===n&&(n=!1);;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()&&!n)return t&&t(this,-1),!1;this.isLeaf()&&(this.node.residents=null);var i=this._childIndex(e);t&&t(this,i),this.advance(i)}},e.prototype.isLeaf=function(){return null!=this.node.residents},e.prototype.isTerminalFor=function(e){return e.radius>this.halfSize/2},e.prototype._childIndex=function(e){for(var t=e.center,n=this.center,i=0,r=0;r<3;r++)n[r]<t[r]&&(i|=1<<r);return i},e.createEmptyNode=function(){return{children:[null,null,null,null,null,null,null,null],terminals:new i({shrink:!0}),residents:new i({shrink:!0})}},e.acquire=function(){return e._pool.acquire()},e.release=function(t){e._pool.release(t)},e.clearPool=function(){e._pool.prune()},e._pool=new n(e),e}(),m=[a.vec3f64.fromValues(-1,-1,-1),a.vec3f64.fromValues(1,-1,-1),a.vec3f64.fromValues(-1,1,-1),a.vec3f64.fromValues(1,1,-1),a.vec3f64.fromValues(-1,-1,1),a.vec3f64.fromValues(1,-1,1),a.vec3f64.fromValues(-1,1,1),a.vec3f64.fromValues(1,1,1)],g=[a.vec3f64.fromValues(-1,-1,-1),a.vec3f64.fromValues(-1,-1,1),a.vec3f64.fromValues(-1,1,-1),a.vec3f64.fromValues(-1,1,1),a.vec3f64.fromValues(1,-1,-1),a.vec3f64.fromValues(1,-1,1),a.vec3f64.fromValues(1,1,-1),a.vec3f64.fromValues(1,1,1)],y=Math.sqrt(3),b=[null],x=a.vec3f64.create(),_=a.vec3f64.create(),S=a.vec3f64.create(),P=a.vec3f64.create(),w=new i,A={center:a.vec3f64.create(),radius:0},C={center:a.vec3f64.create(),radius:0},O={center:a.vec3f64.create(),radius:0},M={center:a.vec3f64.create(),radius:0},D=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],R=new i,T=new i;return h}).apply(null,i))||(e.exports=r)},nJqw:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureAtlasLookup=function(e){e.extensions.add("GL_EXT_shader_texture_lod"),e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(i.glsl(r||(r=n(["\n    #ifndef GL_EXT_shader_texture_lod\n      float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n        float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));\n        return max(0.0, 0.5 * log2(deltaMaxSqr));\n      }\n    #endif\n\n    vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {\n      //[umin, vmin, umax, vmax]\n      vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;\n      vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;\n\n      // calculate derivative of continuous texture coordinate\n      // to avoid mipmapping artifacts caused by manual wrapping in shader\n      vec2 dUVdx = dFdx(textureCoordinates) * atlasScale;\n      vec2 dUVdy = dFdy(textureCoordinates) * atlasScale;\n\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);\n      #else\n        // use bias to compensate for difference in automatic vs desired mipmap level\n        vec2 dUVdxAuto = dFdx(uvAtlas);\n        vec2 dUVdyAuto = dFdy(uvAtlas);\n        float mipMapLevel = calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);\n        float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);\n\n        return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);\n      #endif\n    }\n  "],["\n    #ifndef GL_EXT_shader_texture_lod\n      float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n        float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));\n        return max(0.0, 0.5 * log2(deltaMaxSqr));\n      }\n    #endif\n\n    vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {\n      //[umin, vmin, umax, vmax]\n      vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;\n      vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;\n\n      // calculate derivative of continuous texture coordinate\n      // to avoid mipmapping artifacts caused by manual wrapping in shader\n      vec2 dUVdx = dFdx(textureCoordinates) * atlasScale;\n      vec2 dUVdy = dFdy(textureCoordinates) * atlasScale;\n\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);\n      #else\n        // use bias to compensate for difference in automatic vs desired mipmap level\n        vec2 dUVdxAuto = dFdx(uvAtlas);\n        vec2 dUVdyAuto = dFdy(uvAtlas);\n        float mipMapLevel = calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);\n        float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);\n\n        return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);\n      #endif\n    }\n  "]))))}}).apply(null,i))||(e.exports=r)},ne9J:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("fese"),n("E/g4"),n("7zqm"),n("quQL"),n("7Aei"),n("aExC")],void 0===(r=(function(e,t,n,i,r,a,o,s,l){var c,u,d,p,f,h,v,m,g,y,b,x,_,S,P,w,A,C;Object.defineProperty(t,"__esModule",{value:!0}),t.build=function(e){var t=new l.ShaderBuilder;return t.extensions.add("GL_OES_standard_derivatives"),t.include(o.PiUtils),t.include(r.RibbonVertexPosition,e),t.include(a.LineStipple,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4").add("nearPlane","float").add("pixelRatio","float").add("miterLimit","float").add("screenSize","vec2"),t.attributes.add("position","vec3"),t.attributes.add("subdivisionFactor","float"),t.attributes.add("uv0","vec2"),t.attributes.add("auxpos1","vec3"),t.attributes.add("auxpos2","vec3"),t.varyings.add("vColor","vec4"),t.varyings.add("vpos","vec3"),t.vertex.code.add(s.glsl(c||(c=n(["\n\t\t#define PERPENDICULAR(v) vec2(v.y, -v.x);\n\t\t#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y > 0.0\n\n\t\tfloat interp(float ncp, vec4 a, vec4 b) {\n\t\t\treturn (-ncp - a.z) / (b.z - a.z);\n\t\t}\n\n\t\tvec2 rotate(vec2 v, float a) {\n\t\t\tfloat s = sin(a);\n\t\t\tfloat c = cos(a);\n\t\t\tmat2 m = mat2(c, -s, s, c);\n\t\t\treturn m * v;\n\t\t}\n"],["\n\t\t#define PERPENDICULAR(v) vec2(v.y, -v.x);\n\t\t#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y > 0.0\n\n\t\tfloat interp(float ncp, vec4 a, vec4 b) {\n\t\t\treturn (-ncp - a.z) / (b.z - a.z);\n\t\t}\n\n\t\tvec2 rotate(vec2 v, float a) {\n\t\t\tfloat s = sin(a);\n\t\t\tfloat c = cos(a);\n\t\t\tmat2 m = mat2(c, -s, s, c);\n\t\t\treturn m * v;\n\t\t}\n"])))),t.vertex.code.add(s.glsl(u||(u=n(["\n    vec4 projectAndScale(vec4 pos) {\n      vec4 posNdc = proj * pos;\n\n      // Note that posNdc is in -1:1, scaling by screenSize converts this to a coordinate system\n      // that is twice scaled (going from -size:size).\n      posNdc.xy *= screenSize / posNdc.w;\n      return posNdc;\n    }\n"],["\n    vec4 projectAndScale(vec4 pos) {\n      vec4 posNdc = proj * pos;\n\n      // Note that posNdc is in -1:1, scaling by screenSize converts this to a coordinate system\n      // that is twice scaled (going from -size:size).\n      posNdc.xy *= screenSize / posNdc.w;\n      return posNdc;\n    }\n"])))),t.vertex.code.add(s.glsl(d||(d=n(["\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearPlane*0.99;\n\n      //current pos behind ncp --\x3e we need to clip\n      if(pos.z > -nearPlane) {\n        if (!isStartVertex) {\n          //previous in front of ncp\n          if(prev.z < -nearPlane) {\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n        //next in front of ncp\n        if(isStartVertex) {\n          if(next.z < -nearPlane) {\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        //previous behind ncp\n        if (prev.z > -nearPlane) {\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        //next behind ncp\n        if (next.z > -nearPlane) {\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n"],["\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearPlane*0.99;\n\n      //current pos behind ncp --\x3e we need to clip\n      if(pos.z > -nearPlane) {\n        if (!isStartVertex) {\n          //previous in front of ncp\n          if(prev.z < -nearPlane) {\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n        //next in front of ncp\n        if(isStartVertex) {\n          if(next.z < -nearPlane) {\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        //previous behind ncp\n        if (prev.z > -nearPlane) {\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        //next behind ncp\n        if (next.z > -nearPlane) {\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n"])))),t.vertex.code.add(s.glsl(p||(p=n(["\n  void main(void) {\n    float coverage = 1.0;\n    vpos = (model * vec4(position, 1.0)).xyz;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n      bool isJoin = abs(uv0.y)-3.0 < 0.0;\n\n      float lineWidth = getSize() * pixelRatio;\n\n      // convert sub-pixel coverage to alpha\n      if( lineWidth<1.0 ){\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }\n\n      vec4 pos  = view * vec4((model * vec4(position.xyz, 1.0)).xyz, 1.0);\n      vec4 prev = view * vec4((model * vec4(auxpos1.xyz, 1.0)).xyz, 1.0);\n      vec4 next = view * vec4((model * vec4(auxpos2.xyz, 1.0)).xyz, 1.0);\n\n      clipAndTransform(pos, prev, next, isStartVertex);\n\n      vec2 left = (pos.xy - prev.xy);\n      vec2 right = (next.xy - pos.xy);\n\n      float leftLen = length(left);\n      float rightLen = length(right);\n  "],["\n  void main(void) {\n    float coverage = 1.0;\n    vpos = (model * vec4(position, 1.0)).xyz;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n      bool isJoin = abs(uv0.y)-3.0 < 0.0;\n\n      float lineWidth = getSize() * pixelRatio;\n\n      // convert sub-pixel coverage to alpha\n      if( lineWidth<1.0 ){\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }\n\n      vec4 pos  = view * vec4((model * vec4(position.xyz, 1.0)).xyz, 1.0);\n      vec4 prev = view * vec4((model * vec4(auxpos1.xyz, 1.0)).xyz, 1.0);\n      vec4 next = view * vec4((model * vec4(auxpos2.xyz, 1.0)).xyz, 1.0);\n\n      clipAndTransform(pos, prev, next, isStartVertex);\n\n      vec2 left = (pos.xy - prev.xy);\n      vec2 right = (next.xy - pos.xy);\n\n      float leftLen = length(left);\n      float rightLen = length(right);\n  "])))),e.stippleEnabled&&t.vertex.code.add(s.glsl(f||(f=n(["\n      // uv0.x is either 0 or 1, depending on whether this is considered the start of a line segment\n      // or the end. If start, then use pos->next, otherwise use prev->pos to define the line segment\n      // vector\n      vec4 stippleSegmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), uv0.x);\n      vec2 stippleSegmentOrigin = stippleSegmentInfo.xy;\n\n      // Scale s.t. it's in units of stipple pattern size.\n      vec2 stippleSegmentDirection = stippleSegmentInfo.zw;\n    "],["\n      // uv0.x is either 0 or 1, depending on whether this is considered the start of a line segment\n      // or the end. If start, then use pos->next, otherwise use prev->pos to define the line segment\n      // vector\n      vec4 stippleSegmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), uv0.x);\n      vec2 stippleSegmentOrigin = stippleSegmentInfo.xy;\n\n      // Scale s.t. it's in units of stipple pattern size.\n      vec2 stippleSegmentDirection = stippleSegmentInfo.zw;\n    "])))),t.vertex.code.add(s.glsl(h||(h=n(['\n    left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\n    right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\n\n    vec2 capDisplacementDir = vec2(0, 0);\n    vec2 joinDisplacementDir = vec2(0, 0);\n    float displacementLen = lineWidth;\n\n    if (isJoin) {\n\n      // JOIN handling ---------------------------------------------------\n      // determine if vertex is on the "outside or "inside" of the join\n      bool isOutside = ISOUTSIDE;\n\n      // compute miter join position first\n      joinDisplacementDir = normalize(left + right);\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      // computer miter stretch\n      if (leftLen > 0.001 && rightLen > 0.001) {\n        float nDotSeg = dot(joinDisplacementDir, left);\n        displacementLen /= length(nDotSeg*left - joinDisplacementDir);\n\n        // limit displacement of inner vertices\n        if (!isOutside) {\n          displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n        }\n      }\n\n      if (isOutside && (displacementLen > miterLimit*lineWidth)) {\n    '],['\n    left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\n    right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\n\n    vec2 capDisplacementDir = vec2(0, 0);\n    vec2 joinDisplacementDir = vec2(0, 0);\n    float displacementLen = lineWidth;\n\n    if (isJoin) {\n\n      // JOIN handling ---------------------------------------------------\n      // determine if vertex is on the "outside or "inside" of the join\n      bool isOutside = ISOUTSIDE;\n\n      // compute miter join position first\n      joinDisplacementDir = normalize(left + right);\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      // computer miter stretch\n      if (leftLen > 0.001 && rightLen > 0.001) {\n        float nDotSeg = dot(joinDisplacementDir, left);\n        displacementLen /= length(nDotSeg*left - joinDisplacementDir);\n\n        // limit displacement of inner vertices\n        if (!isOutside) {\n          displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n        }\n      }\n\n      if (isOutside && (displacementLen > miterLimit*lineWidth)) {\n    '])))),t.vertex.code.add(s.glsl(e.roundJoins?v||(v=n(["\n        vec2 startDir;\n        vec2 endDir;\n\n        if (leftLen < 0.001) {\n          startDir = right;\n        }\n        else{\n          startDir = left;\n        }\n        startDir = normalize(startDir);\n        startDir = PERPENDICULAR(startDir);\n\n        if (rightLen < 0.001) {\n          endDir = left;\n        }\n        else{\n          endDir = right;\n        }\n        endDir = normalize(endDir);\n        endDir = PERPENDICULAR(endDir);\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * subdivisionFactor * rotationAngle);\n      "],["\n        vec2 startDir;\n        vec2 endDir;\n\n        if (leftLen < 0.001) {\n          startDir = right;\n        }\n        else{\n          startDir = left;\n        }\n        startDir = normalize(startDir);\n        startDir = PERPENDICULAR(startDir);\n\n        if (rightLen < 0.001) {\n          endDir = left;\n        }\n        else{\n          endDir = right;\n        }\n        endDir = normalize(endDir);\n        endDir = PERPENDICULAR(endDir);\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * subdivisionFactor * rotationAngle);\n      "])):m||(m=n(["\n        // convert to bevel join if miterLimit is exceeded\n        if (leftLen < 0.001) {\n          joinDisplacementDir = right;\n        }\n        else if (rightLen < 0.001) {\n          joinDisplacementDir = left;\n        }\n        else {\n          joinDisplacementDir = isStartVertex ? right : left;\n        }\n        joinDisplacementDir = normalize(joinDisplacementDir);\n        joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n  "],["\n        // convert to bevel join if miterLimit is exceeded\n        if (leftLen < 0.001) {\n          joinDisplacementDir = right;\n        }\n        else if (rightLen < 0.001) {\n          joinDisplacementDir = left;\n        }\n        else {\n          joinDisplacementDir = isStartVertex ? right : left;\n        }\n        joinDisplacementDir = normalize(joinDisplacementDir);\n        joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n  "])))),t.vertex.code.add(s.glsl(g||(g=n(["\n        displacementLen = lineWidth;\n      }\n    } else {\n    // CAP handling ---------------------------------------------------\n    if (leftLen < 0.001) {\n      joinDisplacementDir = right;\n    }\n    else if (rightLen < 0.001) {\n      joinDisplacementDir = left;\n    }\n    else {\n      joinDisplacementDir = isStartVertex ? right : left;\n    }\n    joinDisplacementDir = normalize(joinDisplacementDir);\n    joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n    displacementLen = lineWidth;\n\n    capDisplacementDir = isStartVertex ? -right : left;\n  "],["\n        displacementLen = lineWidth;\n      }\n    } else {\n    // CAP handling ---------------------------------------------------\n    if (leftLen < 0.001) {\n      joinDisplacementDir = right;\n    }\n    else if (rightLen < 0.001) {\n      joinDisplacementDir = left;\n    }\n    else {\n      joinDisplacementDir = isStartVertex ? right : left;\n    }\n    joinDisplacementDir = normalize(joinDisplacementDir);\n    joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n    displacementLen = lineWidth;\n\n    capDisplacementDir = isStartVertex ? -right : left;\n  "])))),t.vertex.code.add(s.glsl(e.roundCaps?y||(y=n(["\n    float angle = subdivisionFactor*PI*0.5;\n    joinDisplacementDir *= cos(angle);\n    capDisplacementDir *= sin(angle);\n    "],["\n    float angle = subdivisionFactor*PI*0.5;\n    joinDisplacementDir *= cos(angle);\n    capDisplacementDir *= sin(angle);\n    "])):b||(b=n(["\n    capDisplacementDir *= subdivisionFactor;\n    "],["\n    capDisplacementDir *= subdivisionFactor;\n    "])))),t.vertex.code.add(s.glsl(x||(x=n(["\n  }\n\n  pos.xy += joinDisplacementDir * sign(uv0.y) * displacementLen;\n  pos.xy += capDisplacementDir * displacementLen;\n  "],["\n  }\n\n  pos.xy += joinDisplacementDir * sign(uv0.y) * displacementLen;\n  pos.xy += capDisplacementDir * displacementLen;\n  "])))),e.stippleEnabled&&(t.vertex.code.add(s.glsl(_||(_=n(["\n    {\n      // Compute the stipple pattern UV coordinate from the actual position, based on the origin\n      // and direction of the line segment on which the stipple pattern is based.\n\n      // Project the vector from the origin of the segment to the vertex onto the line segment.\n      // Note the 0.5 factor due to projected positions being at twice the screen size scale (see projectAndScale)\n      vec2 posVec = pos.xy - stippleSegmentOrigin;\n\n      float stippleSegmentDirectionLength = length(stippleSegmentDirection);\n    "],["\n    {\n      // Compute the stipple pattern UV coordinate from the actual position, based on the origin\n      // and direction of the line segment on which the stipple pattern is based.\n\n      // Project the vector from the origin of the segment to the vertex onto the line segment.\n      // Note the 0.5 factor due to projected positions being at twice the screen size scale (see projectAndScale)\n      vec2 posVec = pos.xy - stippleSegmentOrigin;\n\n      float stippleSegmentDirectionLength = length(stippleSegmentDirection);\n    "])))),e.stippleIntegerRepeatsEnabled&&t.vertex.code.add(s.glsl(S||(S=n(["\n      float numberOfPatternRepeats = stippleSegmentDirectionLength * 0.5 * stipplePatternPixelSizeInv;\n      float roundedNumberOfPatternRepeats = max(1.0, floor(numberOfPatternRepeats + 0.5));\n      stipplePatternUvMax = roundedNumberOfPatternRepeats;\n      "],["\n      float numberOfPatternRepeats = stippleSegmentDirectionLength * 0.5 * stipplePatternPixelSizeInv;\n      float roundedNumberOfPatternRepeats = max(1.0, floor(numberOfPatternRepeats + 0.5));\n      stipplePatternUvMax = roundedNumberOfPatternRepeats;\n      "])))),t.vertex.code.add(s.glsl(P||(P=n(["\n      if (stippleSegmentDirectionLength >= 0.001) {\n        // Project the vertex position onto the line segment.\n        float projectedLength = dot(stippleSegmentDirection, posVec) / stippleSegmentDirectionLength * 0.5;\n     ","\n        stipplePatternUv = projectedLength * wholeNumberOfRepeatsScale * stipplePatternPixelSizeInv * pos.w;\n        } else {\n          stipplePatternUv = 1.0;\n        }\n      }\n    "],["\n      if (stippleSegmentDirectionLength >= 0.001) {\n        // Project the vertex position onto the line segment.\n        float projectedLength = dot(stippleSegmentDirection, posVec) / stippleSegmentDirectionLength * 0.5;\n     ","\n        stipplePatternUv = projectedLength * wholeNumberOfRepeatsScale * stipplePatternPixelSizeInv * pos.w;\n        } else {\n          stipplePatternUv = 1.0;\n        }\n      }\n    "])),e.stippleIntegerRepeatsEnabled?"float wholeNumberOfRepeatsScale = roundedNumberOfPatternRepeats / numberOfPatternRepeats;":"float wholeNumberOfRepeatsScale = 1.0;"))),t.vertex.code.add(s.glsl(w||(w=n(["\n      // Convert back into NDC\n      pos.xy = pos.xy / screenSize * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      gl_Position = pos;\n    }\n  }\n  "],["\n      // Convert back into NDC\n      pos.xy = pos.xy / screenSize * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      gl_Position = pos;\n    }\n  }\n  "])))),t.include(i.Slice,e),0===e.output&&(t.fragment.uniforms.add("symbolColor","vec4"),t.fragment.code.add(s.glsl(A||(A=n(["\n    void main() {\n      discardBySlice(vpos);\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n      vec4 color = symbolColor * vColor;\n      gl_FragColor = highlightSlice(blendStipple(color, stippleAlpha), vpos);\n    }\n    "],["\n    void main() {\n      discardBySlice(vpos);\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n      vec4 color = symbolColor * vColor;\n      gl_FragColor = highlightSlice(blendStipple(color, stippleAlpha), vpos);\n    }\n    "]))))),4===e.output&&t.fragment.code.add(s.glsl(C||(C=n(["\n      void main() {\n        discardBySlice(vpos);\n        discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n    "])))),t}}).apply(null,i))||(e.exports=r)},nobt:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.Offset=function(e){e.vertex.code.add(i.glsl(r||(r=n(["\n    vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {\n      vec3 camToVert = posWorld - camPosWorld;\n\n      bool isBackface = dot(camToVert, normalWorld) > 0.0;\n      if (isBackface) {\n        posClip.z += 0.0000003 * posClip.w;\n      }\n      return posClip;\n    }\n  "],["\n    vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {\n      vec3 camToVert = posWorld - camPosWorld;\n\n      bool isBackface = dot(camToVert, normalWorld) > 0.0;\n      if (isBackface) {\n        posClip.z += 0.0000003 * posClip.w;\n      }\n      return posClip;\n    }\n  "]))))}}).apply(null,i))||(e.exports=r)},o5p5:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("2Atf"),n("xhoE"),n("tUyH"),n("FNtW"),n("LZD4"),n("s6rJ"),n("s6rJ"),n("ZeO9"),n("EiS2")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u){var d=function(e){function t(t,n){var i=e.call(this,n)||this;return i.supportsEdges=!0,i.techniqueConfig=new u.ColorMaterialTechniqueConfiguration,i.params=l.copyParameters(t,v),i}return i(t,e),t.prototype.setParameterValues=function(e){s.updateParameters(this.params,e)&&this.notifyDirty("matChanged")},t.prototype.getParameters=function(){return this.params},t.prototype.getTechniqueConfig=function(e){return this.techniqueConfig.output=e,this.techniqueConfig.cullFace=this.params.cullFace,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig},t.prototype.getPassParameters=function(){return this.params},t.prototype.intersect=function(e,t,n,i,r,a,o){l.intersectTriangleGeometry(e,t,i,r,a,void 0,o)},t.prototype.getGLMaterials=function(){return{color:f,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:h}},t.prototype.createBufferWriter=function(){return new o.DefaultBufferWriter(o.PositionColorLayout)},t.prototype.createRenderer=function(e,t){return new c(e,t,this)},t}(a.Material),p=function(e){function t(t){var n=e.call(this,t)||this;return n.output=t.output,n.updateParameters(),n}return i(t,e),t.prototype.updateParameters=function(){this.technique=this.techniqueRep.acquireAndReleaseExisting(u.ColorMaterialTechnique,this.material.getTechniqueConfig(this.output),this.technique)},t.prototype.beginSlot=function(e){if(4===this.output)return 4===e;var t=4;return this.technique.configuration.transparent&&(t=this.technique.configuration.writeDepth?6:9),e===t},t.prototype.getProgram=function(){return this.technique.program},t.prototype.getPrograms=function(){return null},t.prototype.bind=function(e,t){e.bindProgram(this.technique.program),this.technique.bindPipelineState(e),this.technique.bindPass(e,this.material.getPassParameters(),t)},t.prototype.release=function(){},t.prototype.bindView=function(e){this.technique.bindDraw(e)},t.prototype.bindInstance=function(e){this.technique.bindInstance(e)},t.prototype.getDrawMode=function(){return 4},t}(r.GLMaterial),f=function(e){function t(t){return e.call(this,n({},t,{output:0}))||this}return i(t,e),t}(p),h=function(e){function t(t){return e.call(this,n({},t,{output:4}))||this}return i(t,e),t}(p),v={color:[1,1,1,1],transparent:!1,writeDepth:!0,vertexColors:!1,polygonOffset:!1,slicePlaneEnabled:!1,cullFace:0};return d}).apply(null,i))||(e.exports=r)},oZZu:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("7Yqx")],void 0===(r=(function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.mat4f32=n}).apply(null,i))||(e.exports=r)},pESw:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("Q2wQ"),n("HZ3d"),n("BcWh"),n("eIBl"),n("qsST"),n("LxLY"),n("8MXS"),n("Vx27"),n("FXVB"),n("0LE5"),n("qysZ"),n("DtIM"),n("XsEe"),n("rm3H"),n("1eTA"),n("UdQa"),n("synF"),n("A3J9"),n("HAIt"),n("OH5z"),n("JjCO"),n("X7Ps")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_,S,P,w,A){Object.defineProperty(t,"__esModule",{value:!0});var C=l.getLogger("esri.views.3d.interactive.editingTools.graphicTransform3D.GraphicTransform3DTool"),O=function(e){function t(t){var n=e.call(this,t)||this;return n.enableRotation=!0,n.enableScaling=!0,n.type="transform-3d",n.handles=new s,n.zTransform=null,n.scaleRotate=null,n}return i(t,e),t.prototype.initialize=function(){this.xyTransform=new _.GraphicXYTransform({tool:this}),this.xyAxisTransform=new x.GraphicXYAxisTransform({tool:this}),(this.enableScaling||this.enableRotation)&&(this.scaleRotate=new b.GraphicScaleRotateTransform({tool:this,mode:this.enableScaling&&this.enableRotation?null:this.enableScaling?"scale":"rotate"})),m.enableEditing3D()&&y.canMoveZ(this.graphic,v.getGraphicEffectiveElevationInfo(this.graphic))&&(this.zTransform=new S.GraphicZTransform({tool:this})),this._recreateManipulators()},t.prototype.destroy=function(){this._clear(),this.xyTransform.destroy(),this.xyTransform=null,this.xyAxisTransform.destroy(),this.xyAxisTransform=null,c.isSome(this.scaleRotate)&&(this.scaleRotate.destroy(),this.scaleRotate=null),c.isSome(this.zTransform)&&(this.zTransform.destroy(),this.zTransform=null),this._set("view",null),this._set("graphic",null)},Object.defineProperty(t.prototype,"graphic",{set:function(e){if(null!=e){var t=P.isSupportedGraphic(e);if(0!==t)return C.error("Transform tool not supported for graphic ("+g.isSupportedGraphicResultMessage(t)+")."),void this._set("graphic",null);this._set("graphic",e)}else C.error("invalid graphic")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"symbolRotationAngle",{get:function(){var e=this.graphic.symbol;if(e){var t=e.symbolLayers.find((function(e){return"object"===e.type}));return h.toRadian(-(t&&t.heading||0))}return 0},enumerable:!0,configurable:!0}),t.prototype.reset=function(){},t.prototype.onDetach=function(){c.isSome(this.scaleRotate)&&this.scaleRotate.cancelActiveAnimation()},t.prototype.onHide=function(){c.isSome(this.scaleRotate)&&this.scaleRotate.cancelActiveAnimation()},t.prototype._clear=function(){this.handles.removeAll()},t.prototype._recreateManipulators=function(){var e=this;this._clear();var t=c.unwrap(this.graphic);this.xyTransform.recreateManipulators(),this.xyAxisTransform.recreateManipulators(),c.isSome(this.scaleRotate)&&this.scaleRotate.recreateManipulators(),c.isSome(this.zTransform)&&this.zTransform.recreateManipulators(),this.handles.add([u.watch(t,"geometry",(function(){return e.updateManipulators()}))]),this.updateManipulators()},t.prototype.updateManipulators=function(){var e=this.view.renderCoordsHelper.basisMatrixAtPosition(this.xyTransform.renderLocation,w.sm4d.get()),t="none";this.xyTransform.focused?t="xy":this.xyAxisTransform.focused?t="xy-axis":c.isSome(this.scaleRotate)&&this.scaleRotate.getFocused()&&(t="scale-rotate"),c.isSome(this.zTransform)&&this.zTransform.dragging&&(t="z"),c.isSome(this.scaleRotate)&&this.scaleRotate.dragging&&(t="scale-rotate"),this.xyAxisTransform.dragging&&(t="xy-axis"),this.xyTransform.dragging&&(t="xy");var n=e;if(c.isSome(this.scaleRotate)){this.scaleRotate.updateManipulators(e,"scale-rotate"===t);var i=this.scaleRotate.getScale(),r=p.mat4.fromScaling(w.sm4d.get(),f.vec3.set(w.sv3d.get(),i,i,i));n=p.mat4.multiply(w.sm4d.get(),e,r)}this.xyTransform.updateManipulators(n,"none"===t||"xy"===t),this.xyAxisTransform.updateManipulators(n,"xy"===t||"xy-axis"===t,"xy-axis"===t),c.isSome(this.zTransform)&&this.zTransform.updateManipulators(n)},n([d.property({constructOnly:!0,nonNullable:!0})],t.prototype,"view",void 0),n([d.property({value:null})],t.prototype,"graphic",null),n([d.property()],t.prototype,"enableRotation",void 0),n([d.property()],t.prototype,"enableScaling",void 0),n([d.property({readOnly:!0})],t.prototype,"type",void 0),n([d.subclass("esri.views.3d.interactive.editingTools.graphicTransform3D.GraphicTransform3DTool")],t)}(d.declared(o.EventedMixin(A.InteractiveToolBase)));t.GraphicTransform3DTool=O}).apply(null,i))||(e.exports=r)},pLfv:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o,s;Object.defineProperty(t,"__esModule",{value:!0}),t.NormalUtils=function(e,t){e.vertex.code.add(i.glsl(0===t.viewingMode?r||(r=n(["\n      vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n          return normalize(pos + origin);\n      }\n    "],["\n      vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n          return normalize(pos + origin);\n      }\n    "])):a||(a=n(["\n      vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n          return vec3(0.0, 0.0, 1.0); // WARNING: up-axis dependent code\n      }\n    "],["\n      vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n          return vec3(0.0, 0.0, 1.0); // WARNING: up-axis dependent code\n      }\n    "])))),e.vertex.code.add(i.glsl(0===t.viewingMode?o||(o=n(["\n        mat3 getTBNMatrix(in vec3 n) {\n            vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));\n            vec3 b = normalize(cross(n, t));\n            return mat3(t, b, n);\n        }\n    "],["\n        mat3 getTBNMatrix(in vec3 n) {\n            vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));\n            vec3 b = normalize(cross(n, t));\n            return mat3(t, b, n);\n        }\n    "])):s||(s=n(["\n        mat3 getTBNMatrix(in vec3 n) {\n            vec3 t = vec3(1.0, 0.0, 0.0);\n            vec3 b = normalize(cross(n, t));\n            return mat3(t, b, n);\n        }\n    "],["\n        mat3 getTBNMatrix(in vec3 n) {\n            vec3 t = vec3(1.0, 0.0, 0.0);\n            vec3 b = normalize(cross(n, t));\n            return mat3(t, b, n);\n        }\n    "]))))}}).apply(null,i))||(e.exports=r)},pbva:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("FXVB"),n("1m5D")],void 0===(r=(function(e,t,n,i){return function(e,t,r,a,o,s,l,c,u){this.name=e,this.from=t,this.to=r,this.displayedIndexRange=a,this.highlightedIndexRanges=o,this.transformation=s,this.instanceParameters=l,this.idx=c,this.dataId=u,null!=s&&(this.transformationNormal=i.mat4f64.clone(s),n.mat4.invert(this.transformationNormal,this.transformationNormal),n.mat4.transpose(this.transformationNormal,this.transformationNormal))}}).apply(null,i))||(e.exports=r)},piY7:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("juLw"),n("quQL"),n("7Aei")],void 0===(r=(function(e,t,n,i,r,a){var o,s,l,c,u,d,p,f,h,v,m;Object.defineProperty(t,"__esModule",{value:!0}),t.PhysicallyBasedRendering=function(e,t){var g=e.fragment.code;e.include(r.PiUtils),t.usePBRforWater?(g.add(a.glsl(o||(o=n(["\n    struct PBRShadingWater\n    {\n        float NdotL;   // cos angle between normal and light direction\n        float NdotV;   // cos angle between normal and view direction\n        float NdotH;   // cos angle between normal and half vector\n        float VdotH;   // cos angle between view direction and half vector\n        float LdotH;   // cos angle between light direction and half vector\n        float VdotN;   // cos angle between view direction and normal vector\n    };\n\n    float dtrExponent = ",";\n    "],["\n    struct PBRShadingWater\n    {\n        float NdotL;   // cos angle between normal and light direction\n        float NdotV;   // cos angle between normal and view direction\n        float NdotH;   // cos angle between normal and half vector\n        float VdotH;   // cos angle between view direction and half vector\n        float LdotH;   // cos angle between light direction and half vector\n        float VdotN;   // cos angle between view direction and normal vector\n    };\n\n    float dtrExponent = ",";\n    "])),t.useCustomDTRExponentForWater?"2.2":"2.0")),g.add(a.glsl(s||(s=n(["\n    vec3 fresnelReflection(float angle, vec3 f0, float f90) {\n      return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n    }\n    "],["\n    vec3 fresnelReflection(float angle, vec3 f0, float f90) {\n      return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n    }\n    "])))),g.add(a.glsl(l||(l=n(["\n    float normalDistributionWater(float NdotH, float roughness)\n    {\n      float r2 = roughness * roughness;\n      float NdotH2 = NdotH * NdotH;\n      float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;\n      return r2 / denom;\n    }\n    "],["\n    float normalDistributionWater(float NdotH, float roughness)\n    {\n      float r2 = roughness * roughness;\n      float NdotH2 = NdotH * NdotH;\n      float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;\n      return r2 / denom;\n    }\n    "])))),g.add(a.glsl(c||(c=n(["\n    float geometricOcclusionKelemen(float LoH)\n    {\n        return 0.25 / (LoH * LoH);\n    }\n    "],["\n    float geometricOcclusionKelemen(float LoH)\n    {\n        return 0.25 / (LoH * LoH);\n    }\n    "])))),g.add(a.glsl(u||(u=n(["\n    vec3 brdfWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)\n    {\n      vec3  F = fresnelReflection(props.VdotH, F0, F0Max);\n      float D = normalDistributionWater(props.NdotH, roughness);\n      float V = geometricOcclusionKelemen(props.LdotH);\n      return (D * V) * F;\n    }\n\n    vec3 tonemapACES(const vec3 x) {\n      return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n    }\n    "],["\n    vec3 brdfWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)\n    {\n      vec3  F = fresnelReflection(props.VdotH, F0, F0Max);\n      float D = normalDistributionWater(props.NdotH, roughness);\n      float V = geometricOcclusionKelemen(props.LdotH);\n      return (D * V) * F;\n    }\n\n    vec3 tonemapACES(const vec3 x) {\n      return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n    }\n    "]))))):t.usePBR&&(e.include(i.AnalyticalSkyModel),g.add(a.glsl(d||(d=n(["\n    struct PBRShadingInfo\n    {\n        float NdotL;                  // cos angle between normal and light direction\n        float NdotV;                  // cos angle between normal and view direction\n        float NdotH;                  // cos angle between normal and half vector\n        float VdotH;                  // cos angle between view direction and half vector\n        float LdotH;                  // cos angle between view light direction and half vector\n        float NdotNG;                 // cos angle between normal and normal of the ground\n        float RdotNG;                 // cos angle between view direction reflected of the normal and normal of the ground\n        float NdotAmbDir;             // cos angle between view direction and the fill light in ambient illumination\n        float NdotH_Horizon;          // cos angle between normal and half vector defined with horizon illumination\n        vec3 skyRadianceToSurface;         // integrated radiance of the sky based on the surface roughness (used for specular reflection)\n        vec3 groundRadianceToSurface;      // integrated radiance of the ground based on the surface roughness (used for specular reflection)\n        vec3 skyIrradianceToSurface;       // irradiance of the sky (used for diffuse reflection)\n        vec3 groundIrradianceToSurface;    // irradiance of the ground (used for diffuse reflection)\n\n        float averageAmbientRadiance;      // average ambient radiance used to deduce black level in gamut mapping\n        float ssao;                   // ssao coefficient\n        vec3 groundReflectance;       // reflectance of the ground\n        vec3 albedoLinear;            // linear color of the albedo\n        vec3 f0;                      // fresnel value at normal incident light\n        vec3 f90;                     // fresnel value at 90o of incident light\n\n        vec3 diffuseColor;            // diffuse color of the material used in environment illumination\n        float metalness;              // metalness of the material\n        float roughness;              // roughness of the material\n    };\n    "],["\n    struct PBRShadingInfo\n    {\n        float NdotL;                  // cos angle between normal and light direction\n        float NdotV;                  // cos angle between normal and view direction\n        float NdotH;                  // cos angle between normal and half vector\n        float VdotH;                  // cos angle between view direction and half vector\n        float LdotH;                  // cos angle between view light direction and half vector\n        float NdotNG;                 // cos angle between normal and normal of the ground\n        float RdotNG;                 // cos angle between view direction reflected of the normal and normal of the ground\n        float NdotAmbDir;             // cos angle between view direction and the fill light in ambient illumination\n        float NdotH_Horizon;          // cos angle between normal and half vector defined with horizon illumination\n        vec3 skyRadianceToSurface;         // integrated radiance of the sky based on the surface roughness (used for specular reflection)\n        vec3 groundRadianceToSurface;      // integrated radiance of the ground based on the surface roughness (used for specular reflection)\n        vec3 skyIrradianceToSurface;       // irradiance of the sky (used for diffuse reflection)\n        vec3 groundIrradianceToSurface;    // irradiance of the ground (used for diffuse reflection)\n\n        float averageAmbientRadiance;      // average ambient radiance used to deduce black level in gamut mapping\n        float ssao;                   // ssao coefficient\n        vec3 groundReflectance;       // reflectance of the ground\n        vec3 albedoLinear;            // linear color of the albedo\n        vec3 f0;                      // fresnel value at normal incident light\n        vec3 f90;                     // fresnel value at 90o of incident light\n\n        vec3 diffuseColor;            // diffuse color of the material used in environment illumination\n        float metalness;              // metalness of the material\n        float roughness;              // roughness of the material\n    };\n    "])))),g.add(a.glsl(p||(p=n(["\n    const float fillLightIntensity = 0.25;              // intensity of the directional ambient component\n    const float horizonLightDiffusion = 0.4;            // diffusion value describing the area and smoothness of the horizon light\n    const vec3  skyTransmittance = vec3(0.9, 0.9, 1.0);  // bluish transmittance of the sky\n    const float additionalAmbientIrradianceFactor = 0.02;// Additional irradiance factor - making everything brighter and more colorful\n    "],["\n    const float fillLightIntensity = 0.25;              // intensity of the directional ambient component\n    const float horizonLightDiffusion = 0.4;            // diffusion value describing the area and smoothness of the horizon light\n    const vec3  skyTransmittance = vec3(0.9, 0.9, 1.0);  // bluish transmittance of the sky\n    const float additionalAmbientIrradianceFactor = 0.02;// Additional irradiance factor - making everything brighter and more colorful\n    "])))),g.add(a.glsl(f||(f=n(["\n    float normalDistribution(float NdotH, float roughness)\n    {\n        float a = NdotH * roughness;\n        float b = roughness / (1.0 - NdotH * NdotH + a * a);\n        return b * b * INV_PI;\n    }\n    "],["\n    float normalDistribution(float NdotH, float roughness)\n    {\n        float a = NdotH * roughness;\n        float b = roughness / (1.0 - NdotH * NdotH + a * a);\n        return b * b * INV_PI;\n    }\n    "])))),g.add(a.glsl(h||(h=n(["\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n    const vec2 c2 = vec2(-1.04, 1.04);\n\n    vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {\n        vec4 r = roughness * c0 + c1;\n        float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;\n        return c2 * a004 + r.zw;\n    }\n    "],["\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n    const vec2 c2 = vec2(-1.04, 1.04);\n\n    vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {\n        vec4 r = roughness * c0 + c1;\n        float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;\n        return c2 * a004 + r.zw;\n    }\n    "])))),g.add(a.glsl(v||(v=n(["\n    vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {\n      vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);\n      vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);\n\n      // From diffuse illumination calculate reflected color\n      vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;\n\n      // From specular illumination calculate reflected color\n      vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);\n      vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;\n      vec3 specularComponent = specularColor * indirectSpecular;\n\n      return (diffuseComponent + specularComponent);\n    }\n    "],["\n    vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {\n      vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);\n      vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);\n\n      // From diffuse illumination calculate reflected color\n      vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;\n\n      // From specular illumination calculate reflected color\n      vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);\n      vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;\n      vec3 specularComponent = specularColor * indirectSpecular;\n\n      return (diffuseComponent + specularComponent);\n    }\n    "])))),g.add(a.glsl(m||(m=n(["\n    float gamutMapChanel(float x, vec2 p){\n      return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );\n    }\n\n    // Because of the fresnel refletion the image might be too bright we apply black level soft compression gamut mapping\n    vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){\n      vec3 outColor;\n      // based on the average ambient radiance we approximate the black level for a specific time of a day\n      // p.x - the deduced black level\n      // p.y - the value to which we map the black level (around 1/3 of the black level)\n      vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));\n      // gamut map individual color changels\n      outColor.x = gamutMapChanel(inColor.x, p) ;\n      outColor.y = gamutMapChanel(inColor.y, p) ;\n      outColor.z = gamutMapChanel(inColor.z, p) ;\n\n      return outColor;\n    }\n    "],["\n    float gamutMapChanel(float x, vec2 p){\n      return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );\n    }\n\n    // Because of the fresnel refletion the image might be too bright we apply black level soft compression gamut mapping\n    vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){\n      vec3 outColor;\n      // based on the average ambient radiance we approximate the black level for a specific time of a day\n      // p.x - the deduced black level\n      // p.y - the value to which we map the black level (around 1/3 of the black level)\n      vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));\n      // gamut map individual color changels\n      outColor.x = gamutMapChanel(inColor.x, p) ;\n      outColor.y = gamutMapChanel(inColor.y, p) ;\n      outColor.z = gamutMapChanel(inColor.z, p) ;\n\n      return outColor;\n    }\n    "])))))}}).apply(null,i))||(e.exports=r)},qkUi:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("runW"),n("x82K"),n("pESw")],void 0===(r=(function(e,t,n,i,r){Object.defineProperty(t,"__esModule",{value:!0}),t.GraphicMove3DTool=n.GraphicMove3DTool,t.GraphicReshape3DTool=i.GraphicReshape3DTool,t.GraphicTransform3DTool=r.GraphicTransform3DTool}).apply(null,i))||(e.exports=r)},quQL:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a;Object.defineProperty(t,"__esModule",{value:!0}),t.PiUtils=function(e){e.vertex.code.add(i.glsl(r||(r=n(["\n    const float PI = 3.141592653589793;\n  "],["\n    const float PI = 3.141592653589793;\n  "])))),e.fragment.code.add(i.glsl(a||(a=n(["\n    const float PI = 3.141592653589793;\n    const float LIGHT_NORMALIZATION = 1.0 / PI;\n    const float INV_PI = 0.3183098861837907;\n    const float HALF_PI = 1.570796326794897;\n    "],["\n    const float PI = 3.141592653589793;\n    const float LIGHT_NORMALIZATION = 1.0 / PI;\n    const float INV_PI = 0.3183098861837907;\n    const float HALF_PI = 1.570796326794897;\n    "]))))}}).apply(null,i))||(e.exports=r)},r0i9:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("H1tY"),n("7Aei"),n("rxbe")],void 0===(r=(function(e,t,n,i,r,a){var o,s;Object.defineProperty(t,"__esModule",{value:!0}),t.DoublePrecision=function(e,t){e.vertex.code.add(r.glsl(t.doublePrecisionRequiresObfuscation?o||(o=n(["\n      vec3 dpPlusFrc(vec3 a, vec3 b) {\n        return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n      }\n\n      vec3 dpMinusFrc(vec3 a, vec3 b) {\n        return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n      }\n\n      // based on https://www.thasler.com/blog/blog/glsl-part2-emu\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = dpPlusFrc(hiA, hiB);\n        vec3 e = dpMinusFrc(t1, hiA);\n        vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n        return t1 + t2;\n      }\n    "],["\n      vec3 dpPlusFrc(vec3 a, vec3 b) {\n        return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n      }\n\n      vec3 dpMinusFrc(vec3 a, vec3 b) {\n        return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n      }\n\n      // based on https://www.thasler.com/blog/blog/glsl-part2-emu\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = dpPlusFrc(hiA, hiB);\n        vec3 e = dpMinusFrc(t1, hiA);\n        vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n        return t1 + t2;\n      }\n    "])):s||(s=n(["\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = hiA + hiB;\n        vec3 e = t1 - hiA;\n        vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n        return t1 + t2;\n      }\n    "],["\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = hiA + hiB;\n        vec3 e = t1 - hiA;\n        vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n        return t1 + t2;\n      }\n    "]))))},t.doublePrecisionRequiresObfuscation=function(e){return!!i("force-double-precision-obfuscation")||a.testWebGLDriver(e).doublePrecisionRequiresObfuscation}}).apply(null,i))||(e.exports=r)},rCq5:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r,a,o,s;Object.defineProperty(t,"__esModule",{value:!0}),t.ColorConversion=function(e,t){var l=[i.glsl(r||(r=n(["\n      vec4 premultiplyAlpha(vec4 v) {\n        return vec4(v.rgb * v.a, v.a);\n      }\n    "],["\n      vec4 premultiplyAlpha(vec4 v) {\n        return vec4(v.rgb * v.a, v.a);\n      }\n    "]))),i.glsl(a||(a=n(["\n      vec3 rgb2hsv(vec3 c) {\n        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n        vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n      }\n    "],["\n      vec3 rgb2hsv(vec3 c) {\n        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n        vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n      }\n    "]))),i.glsl(o||(o=n(["\n      vec3 hsv2rgb(vec3 c) {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n      }\n    "],["\n      vec3 hsv2rgb(vec3 c) {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n      }\n    "]))),i.glsl(s||(s=n(["\n      float rgb2v(vec3 c) {\n        return max(c.x, max(c.y, c.z));\n      }\n    "],["\n      float rgb2v(vec3 c) {\n        return max(c.x, max(c.y, c.z));\n      }\n    "])))];switch(t.stages){case 0:l.forEach((function(t){return e.vertex.code.add(t)}));break;case 1:l.forEach((function(t){return e.fragment.code.add(t)}));break;default:l.forEach((function(t){return e.vertex.code.add(t)})),l.forEach((function(t){return e.fragment.code.add(t)}))}}}).apply(null,i))||(e.exports=r)},runW:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("2Atf"),n("y4WC"),n("BcWh"),n("eIBl"),n("LxLY"),n("8MXS"),n("Vx27"),n("woUR"),n("5T2R"),n("1eTA"),n("I5JL"),n("X7Ps"),n("sGGe"),n("bF8Q")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g){Object.defineProperty(t,"__esModule",{value:!0});var y=function(e){this.allGraphics=e,this.type="graphic-move-start"};t.GraphicMoveStartEvent=y;var b=function(e,t,n,i){this.dx=e,this.dy=t,this.dz=n,this.allGraphics=i,this.type="graphic-move"};t.GraphicMoveEvent=b;var x=function(e){this.allGraphics=e,this.type="graphic-move-stop"};t.GraphicMoveStopEvent=x;var _=function(e){function t(t){var n=e.call(this,t)||this;return n.graphics=new a,n.type="move-3d",n._handles=new s,n}return i(t,e),t.prototype.initialize=function(){var e=this;this._handles.add(this.graphics.on("change",(function(){e._refreshManipulators()}))),this._refreshManipulators()},t.prototype.destroy=function(){this._handles.destroy(),this._handles=null,this.graphics.removeAll(),this._set("view",null)},t.prototype.reset=function(){},t.prototype._createDragAction=function(e){var t=this,n=m.createGraphicDragActionMany(e);return function(i){switch(i.action){case"start":t.emit("graphic-move-start",new y(e))}switch(n(i),i.action){case"start":case"update":("update"===i.action||i.deltaX||i.deltaY||i.deltaZ)&&t.emit("graphic-move",new b(i.deltaX,i.deltaY,i.deltaZ,e));break;case"end":t.emit("graphic-move-stop",new x(e))}}},t.prototype._refreshManipulators=function(){var e=this;this._handles.remove("graphics"),this.manipulators.removeAll();for(var t=this.graphics.toArray(),n=[],i=this,a=0,o=t;a<o.length;a++)!function(t){if(0!==h.isSupportedGraphic(t))return"continue";var a=f.createGraphicMoveXYManipulator(i.view,t);i._handles.add(a.events.on("immediate-click",(function(n){e.emit("immediate-click",r({},n,{graphic:t})),n.stopPropagation()})),"graphics"),i.manipulators.add(a),n.push(a);var o=f.createGraphicMoveZManipulator({view:i.view,graphic:t});if(l.isNone(o))return"continue";i._handles.add([c.init(t,"geometry",(function(){return p.placeManipulatorAtGraphic(o,t)})),c.init(t,["visible","layer.visible"],(function(){return o.visible=t.visible&&t.layer.visible}))],"graphics"),i.manipulators.add(o),n.push(o)}(o[a]);g.createManipulatorDragHandlerOneOf(n,(function(t,n){return t instanceof d.Manipulator3D?f.createGraphicMoveZScreenDragToMap(e.view,t):f.createGraphicMoveXYScreenDragToMap(e.view,t,n)}),this._createDragAction(t))},n([u.property({constructOnly:!0,nonNullable:!0})],t.prototype,"view",void 0),n([u.property({readOnly:!0})],t.prototype,"graphics",void 0),n([u.property({readOnly:!0})],t.prototype,"type",void 0),n([u.subclass("esri.views.3d.interactive.editingTools.graphicMove3D.GraphicMove3DTool")],t)}(u.declared(o.EventedMixin(v.InteractiveToolBase)));t.GraphicMove3DTool=_}).apply(null,i))||(e.exports=r)},rxbe:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("LxLY"),n("Rdxj"),n("DJpR"),n("1f+t"),n("CIy2"),n("VVgn")],void 0===(r=(function(e,t,n,i,r,a,o,s){function l(e,t){var n=new r.FramebufferObject(e,{colorTarget:0,depthStencilTarget:0},{target:3553,wrapMode:33071,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1}),l=r.BufferObject.createVertex(e,35044,new Uint16Array([0,0,1,0,0,1,1,1])),c=new r.VertexArrayObject(e,{a_pos:0},{geometry:[{name:"a_pos",count:2,type:5123,offset:0,stride:4,normalized:!1}]},{geometry:l}),u=i.vec3f64.fromValues(5633261.287538229,2626832.878767164,1434988.0495278358),d=i.vec3f64.fromValues(5633271.46742708,2626873.6381334523,1434963.231608387);e.bindFramebuffer(n);var p=function(n,i){var o=new r.Program(e,"\n\n  precision highp float;\n\n  attribute vec2 a_pos;\n\n  uniform vec3 u_highA;\n  uniform vec3 u_lowA;\n  uniform vec3 u_highB;\n  uniform vec3 u_lowB;\n\n  varying vec4 v_color;\n\n  "+(t?"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION":"")+"\n\n  "+s.util["doublePrecision.glsl"]+"\n\n  const float MAX_RGBA_FLOAT =\n    255.0 / 256.0 +\n    255.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n  vec4 float2rgba(const float value) {\n    // Make sure value is in the domain we can represent\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n    // Decompose value in 32bit fixed point parts represented as\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\n    // by a power of 256 (this removes the bits that are represented in the previous\n    // component) and then converts the fractional part to 8bits.\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n    // Convert uint8 values (from 0 to 255) to floating point representation for\n    // the shader\n    const float toU8AsFloat = 1.0 / 255.0;\n\n    return fixedPointU8 * toU8AsFloat;\n  }\n\n  void main() {\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\n\n    v_color = float2rgba(val.z / 25.0);\n\n    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n  }\n  ","\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ",{a_pos:0}),l=new Float32Array(6);a.encodeDoubleArray(n,l,3);var c=new Float32Array(6);return a.encodeDoubleArray(i,c,3),e.bindProgram(o),o.setUniform3f("u_highA",l[0],l[2],l[4]),o.setUniform3f("u_lowA",l[1],l[3],l[5]),o.setUniform3f("u_highB",c[0],c[2],c[4]),o.setUniform3f("u_lowB",c[1],c[3],c[5]),o}(u,d),f=e.getViewport(),h=f.x,v=f.y,m=f.width,g=f.height;e.setViewport(0,0,1,1),e.bindVAO(c),e.drawArrays(5,0,4),e.setViewport(h,v,m,g);var y=new Uint8Array(4);n.readPixels(0,0,1,1,6408,5121,y),p.dispose(),c.dispose(!1),l.dispose(),n.dispose();var b=(u[2]-d[2])/25,x=o.unpackFloatRGBA(y);return Math.abs(b-x)}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e){this.context=e,this._doublePrecisionRequiresObfuscation=null}return Object.defineProperty(e.prototype,"doublePrecisionRequiresObfuscation",{get:function(){if(n.isNone(this._doublePrecisionRequiresObfuscation)){var e=l(this.context,!1),t=l(this.context,!0);this._doublePrecisionRequiresObfuscation=0!==e&&(0===t||e/t>5)}return this._doublePrecisionRequiresObfuscation},enumerable:!0,configurable:!0}),e}(),u=null;t.testWebGLDriver=function(e){return(n.isNone(u)||u.context!==e)&&(u=new c(e)),u}}).apply(null,i))||(e.exports=r)},s6rJ:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("2Atf"),n("xoE+"),n("LxLY"),n("FXVB"),n("oZZu"),n("1m5D"),n("0LE5"),n("Rdxj"),n("2fXB"),n("WRgd"),n("rjU6"),n("1f+t"),n("+wMf"),n("CIy2")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v){function m(e,t,n,i,a,o){var s=x(t,n,M);if(d.setMin(C,e.getBBMin()),d.setMax(C,e.getBBMax()),r.isSome(a)&&a.applyToAABB(C),_(C,t,s,i)){var l=e.getPrimitiveIndices(),c=e.getIndices(),u=e.getPosition(),p=l?l.length:c.length/3;if(p>V){var f=e.getChildren();if(void 0!==f){for(var h=0;h<8;++h)void 0!==f[h]&&m(f[h],t,n,i,a,o);return}}y(t,n,0,p,c,u,l,a,o)}}function g(e,t,n,i,a,o,s){var l=x(n,i,M),c=e.componentCount,u=e.componentOffsets,f=e.getIndices(O.POSITION),h=e.getAttribute(O.POSITION),v=e.boundingInfo;if(!v||(d.setMin(C,v.getBBMin()),d.setMax(C,v.getBBMax()),r.isSome(o)&&o.applyToAABB(C),_(C,n,l,a)))for(var m=0;m<c;m++)if(!t||p.getVisibility(t,m)){if(e.getComponentAABB){var g=e.getComponentAABB(m,C);if(r.isSome(o)&&o.applyToAABB(g),!_(g,n,l,a))continue}y(n,i,u[m]/3,u[m+1]/3,f,h,void 0,o,s)}}function y(e,t,n,i,a,o,s,l,c){var u,d,p;if(s)return function(e,t,n,i,a,o,s,l,c){for(var u,d,p,f=o.data,h=o.offsetIdx,v=o.strideIdx,m=e[0],g=e[1],y=e[2],x=t[0]-m,_=t[1]-g,S=t[2]-y,P=n;P<i;++P){var w=s[P],A=3*w,C=h+v*a[A++],O=f[C++],M=f[C++],T=f[C];C=h+v*a[A++];var I=f[C++],z=f[C++],L=f[C];C=h+v*a[A];var E=f[C++],j=f[C++],V=f[C];r.isSome(l)&&(O=(u=l.applyToVertex(O,M,T))[0],M=u[1],T=u[2],I=(d=l.applyToVertex(I,z,L))[0],z=d[1],L=d[2],E=(p=l.applyToVertex(E,j,V))[0],j=p[1],V=p[2]);var N=I-O,F=z-M,G=L-T,B=E-O,H=j-M,U=V-T,q=_*U-H*S,k=S*B-U*x,W=x*H-B*_,Z=N*q+F*k+G*W;if(!(Math.abs(Z)<=D)){var X=m-O,Y=g-M,J=y-T,K=X*q+Y*k+J*W;if(Z>0){if(K<0||K>Z)continue}else if(K>0||K<Z)continue;var Q=Y*G-F*J,$=J*N-G*X,ee=X*F-N*Y,te=x*Q+_*$+S*ee;if(Z>0){if(te<0||K+te>Z)continue}else if(te>0||K+te<Z)continue;var ne=(B*Q+H*$+U*ee)/Z;ne>=0&&c(ne,b(N,F,G,B,H,U,R),w)}}}(e,t,n,i,a,o,s,l,c);for(var f=o.data,h=o.offsetIdx,v=o.strideIdx,m=e[0],g=e[1],y=e[2],x=t[0]-m,_=t[1]-g,S=t[2]-y,P=n,w=3*n;P<i;++P){var A=h+v*a[w++],C=f[A++],O=f[A++],M=f[A];A=h+v*a[w++];var T=f[A++],I=f[A++],z=f[A];A=h+v*a[w++];var L=f[A++],E=f[A++],j=f[A];r.isSome(l)&&(C=(u=l.applyToVertex(C,O,M))[0],O=u[1],M=u[2],T=(d=l.applyToVertex(T,I,z))[0],I=d[1],z=d[2],L=(p=l.applyToVertex(L,E,j))[0],E=p[1],j=p[2]);var V=T-C,N=I-O,F=z-M,G=L-C,B=E-O,H=j-M,U=_*H-B*S,q=S*G-H*x,k=x*B-G*_,W=V*U+N*q+F*k;if(!(Math.abs(W)<=D)){var Z=m-C,X=g-O,Y=y-M,J=Z*U+X*q+Y*k;if(W>0){if(J<0||J>W)continue}else if(J>0||J<W)continue;var K=X*F-N*Y,Q=Y*V-F*Z,$=Z*N-V*X,ee=x*K+_*Q+S*$;if(W>0){if(ee<0||J+ee>W)continue}else if(ee>0||J+ee<W)continue;var te=(G*K+B*Q+H*$)/W;te>=0&&c(te,b(V,N,F,G,B,H,R),P)}}}function b(e,t,n,i,r,a,o){return l.vec3.set(T,e,t,n),l.vec3.set(I,i,r,a),l.vec3.cross(o,T,I),l.vec3.normalize(o,o),o}function x(e,t,n){return l.vec3.set(n,1/(t[0]-e[0]),1/(t[1]-e[1]),1/(t[2]-e[2]))}function _(e,t,n,i){return S(e,t,n,i,1/0)}function S(e,t,n,i,r){var a=(e[0]-i-t[0])*n[0],o=(e[3]+i-t[0])*n[0],s=Math.min(a,o),l=Math.max(a,o),c=(e[1]-i-t[1])*n[1],u=(e[4]+i-t[1])*n[1];if((l=Math.min(l,Math.max(c,u)))<0)return!1;if((s=Math.max(s,Math.min(c,u)))>l)return!1;var d=(e[2]-i-t[2])*n[2],p=(e[5]+i-t[2])*n[2];return!((l=Math.min(l,Math.max(d,p)))<0)&&!((s=Math.max(s,Math.min(d,p)))>l)&&s<r}function P(e,t,n,i){return h.scale(e,n,t,i)}function w(e){var t=[];return e.forEach((function(e){return t.push(e)})),t}Object.defineProperty(t,"__esModule",{value:!0});var A=s.mat4f64.create(),C=d.create(),O=v.VertexAttrConstants;t.intersectTriangleGeometry=function(e,t,n,i,r,a,o){var s=t&&t.componentVisibilities,l=n.tolerance;if(e.componentCount>1)g(e,s,i,r,l,a,o);else if(!s||p.getVisibility(s,0))if(e.boundingInfo)v.assert("triangle"===e.data.primitiveType),m(e.boundingInfo,i,r,l,a,o);else{var c=e.getIndices(O.POSITION),u=e.getAttribute(O.POSITION);y(i,r,0,c.length/3,c,u,void 0,a,o)}};var M=c.vec3f64.create(),D=Math.pow(2,-52),R=c.vec3f64.create();t.intersectTriangles=y;var T=c.vec3f64.create(),I=c.vec3f64.create();t.computeNormal=b,t.computeInvDir=x,t.intersectAabbInvDir=_,t.intersectAabbInvDirBefore=S,t.transformToWorld=function(e,t,n){return u.vec4.set(n,e[0]-t[0],e[1]-t[1],e[2]-t[2],1)},t.transformToView=function(e,t,n,i){return a.mat4.translate(A,n,t),u.vec4.transformMat4(i,e,n=A)},t.transformToProjection=function(e,t,n,i){return i[0]=e[0]+n[0],i[1]=e[1]+n[1],i[2]=e[2]+n[2],i[3]=e[3],u.vec4.transformMat4(i,i,t)},t.transformToNDC=function(e,t){return u.vec4.scale(t,e,1/Math.abs(e[3]))},t.applyScreenSizePerspectiveScale=P,t.verticalOffsetAtDistance=function(e,t,n,r,a){var o=(n.screenLength||0)*e.pixelRatio;a&&(o=P(o,t,r,a));var s=o*Math.tan(.5*e.fovY)/(.5*e.fullHeight);return i.clamp(s*t,n.minWorldLength||0,null!=n.maxWorldLength?n.maxWorldLength:1/0)},t.acquireIfNotUndefined=function(e,t,n){if(void 0!==e)return t.acquire(e,n)},t.releaseIfNotUndefined=function(e,t){void 0!==e&&t.release(e)};var z=o.mat4f32.create();t.bindView=function(e,t,n){a.mat4.translate(z,t,e),n.setUniform3fv("localOrigin",e),n.setUniformMatrix4fv("view",z)},t.bindCamPos=function(e,t,n){n.setUniform3f("camPos",t[3]-e[0],t[7]-e[1],t[11]-e[2])};var L=c.vec3f64.create(),E=c.vec3f64.create();t.bindViewOriginDouble=function(e,t){f.encodeDoubleArraySplit(e,L,E,3),t.setUniform3fv("viewOriginHi",L),t.setUniform3fv("viewOriginLo",E)};var j=c.vec3f64.create();t.bindSlicePlane=function(e,t,n){l.vec3.subtract(j,t.origin,e),n.setUniform3fv("slicePlaneOrigin",j),n.setUniform3fv("slicePlaneBasis1",t.basis1),n.setUniform3fv("slicePlaneBasis2",t.basis2)},t.bindVerticalOffset=function(e,t,n){if(e){var i=function(e,t,n,i){return void 0===i&&(i=N),i.screenLength=e.screenLength,i.perDistance=Math.tan(.5*t)/(.5*n),i.minWorldLength=e.minWorldLength,i.maxWorldLength=e.maxWorldLength,i}(e,t.fovY,t.viewport[3]);n.setUniform4f("verticalOffset",i.screenLength*(t.pixelRatio||1),i.perDistance,i.minWorldLength,i.maxWorldLength)}},t.bindHighlightRendering=function(e,t,n){e.bindTexture(t.highlightDepthTexture,5),n.setUniform1i("depthTex",5),n.setUniform4f("highlightViewportPixelSz",0,0,1/t.viewport[2],1/t.viewport[3])},t.bindScreenSizePerspective=function(e,t,n){if(void 0===n&&(n="screenSizePerspectiveAlignment"),e){var i=e.parameters;t.setUniform4f(n,i.divisor,i.offset,i.minPixelSize,e.paddingPixelsOverride)}},t.copyParameters=function e(t,n){var i=n?e(n):{};for(var r in t){var a=t[r];a&&a.forEach&&(a=w(a)),null==a&&r in i||(i[r]=a)}return i},t.updateParameters=function(e,t){var n=!1;for(var i in t){var r=t[i];void 0!==r&&(n=!0,e[i]=Array.isArray(r)?r.slice():r)}return n},function(e){function t(e){return(e.shadowMappingEnabled?1:0)|(e.ssaoEnabled?2:0)}e.create=function(e,n){for(var i=[],r=0;r<2;r++)for(var a=0;a<2;a++){var o=t({shadowMappingEnabled:1===r,ssaoEnabled:1===a}),s=t({shadowMappingEnabled:1===r,ssaoEnabled:1===a&&e.receiveSSAO});i[o]=i[s]||n({receiveShadows:1===r,receiveSSAO:1===a&&e.receiveSSAO})}return{programs:i.filter((function(e){return null!=e})),byParameter:i}},e.lookup=function(e,n){return e.byParameter[t(n)]},e.programs=function(e){return e.programs}}(t.BindParametersMap||(t.BindParametersMap={})),t.intersectDrapedRenderLineGeometry=function(e,t,n,r,a){if(t.options.selectionMode){for(var o=e.getAttribute(O.POSITION).data,s=e.getAttribute(O.SIZE),l=n[0],c=n[1],u=(((s&&s.data[0])+r)/2+4)*e.pixelRatio,d=Number.MAX_VALUE,p=0;p<o.length-5;p+=3){var f=o[p],h=o[p+1],v=l-f,m=c-h,g=o[p+3]-f,y=o[p+4]-h,b=i.clamp((g*v+y*m)/(g*g+y*y),0,1),x=g*b-v,_=y*b-m,S=x*x+_*_;S<d&&(d=S)}d<u*u&&a()}},t.colorMixModes={multiply:1,ignore:2,replace:3,tint:4};var V=1e3,N={screenLength:0,perDistance:0,minWorldLength:0,maxWorldLength:0};t.defaultPBRMaterialParameters={roughnessFactor:.6,metallicFactor:0,reflectanceFactor:.2},t.defaultPBRTreeMaterialParameters={roughnessFactor:1,metallicFactor:0,reflectanceFactor:.2},t.getDefaultPBRMaterialParameters=function(e,i){return n({usePBR:e},i?t.defaultPBRTreeMaterialParameters:t.defaultPBRMaterialParameters)}}).apply(null,i))||(e.exports=r)},sGGe:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("LxLY"),n("vtMp"),n("tJCi")],void 0===(r=(function(e,t,n,i,r){function a(e,t){var a=null,o=n.isSome(e[t])?e[t].spatialReference:null;return function(s){if("start"===s.action&&n.isSome(e[t])&&(a=function(e,t){return n.isNone(e)||"mesh"===e.type?null:e.spatialReference.equals(t)?e.clone():i.canProject(e,t)?i.project(e,t):null}(e[t],s.spatialReference)),!n.isNone(a)){var l=r.move(a.clone(),s.deltaX,s.deltaY,s.deltaZ);e[t]=l.spatialReference.equals(o)?l:i.project(l,o)}}}function o(e){return a(e,"geometry")}Object.defineProperty(t,"__esModule",{value:!0}),t.createGeometryDragAction=a,t.createGraphicDragAction=o,t.createGraphicDragActionMany=function(e){var t=e.map(o);return function(e){return t.forEach((function(t){return t(e)}))}}}).apply(null,i))||(e.exports=r)},synF:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("Q2wQ"),n("HZ3d"),n("eIBl"),n("H1tY"),n("LxLY"),n("8MXS"),n("FXVB"),n("1m5D"),n("0LE5"),n("Rdxj"),n("woUR"),n("5T2R"),n("+soW"),n("Z0CD"),n("JjCO"),n("ys4y"),n("4ziW"),n("o5p5"),n("sGGe"),n("bF8Q"),n("wOtw")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_,S,P,w){var A;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.Highlighted=512,e.Visible=1024}(A||(A={}));var C=function(){function e(e){this._handles=new o,this.arrowManipulatorInfos=[],this.tool=e.tool}return e.prototype.destroy=function(){this._clear()},e.prototype._clear=function(){var e=this;this._handles.removeAll(),this.arrowManipulatorInfos.forEach((function(t){e.tool.manipulators.remove(t.manipulator)})),this.arrowManipulatorInfos=[]},Object.defineProperty(e.prototype,"focused",{get:function(){return this.arrowManipulatorInfos.some((function(e){return e.manipulator.focused}))},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"dragging",{get:function(){return this.arrowManipulatorInfos.some((function(e){return e.manipulator.dragging}))},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"arrowRotationAngle",{get:function(){return"local"===this.tool.view.viewingMode||this.tool.view.scale<g.ALIGN_ARROWS_SCALE_THRESHOLD?this.tool.symbolRotationAngle:0},enumerable:!0,configurable:!0}),e.prototype.createDragAction=function(){var e=this,t=S.createGraphicDragAction(this.tool.graphic);return function(n){switch("start"===n.action&&e.tool.emit("graphic-translate-start",{graphic:e.tool.graphic}),t(n),n.action){case"update":e.tool.emit("graphic-translate",{graphic:e.tool.graphic,dx:n.deltaX,dy:n.deltaY,dz:n.deltaZ,type:"translate"});break;case"end":e.tool.emit("graphic-translate-stop",{graphic:e.tool.graphic})}}},e.prototype.recreateManipulators=function(){var e=this;this._clear();for(var t=[],n=0;n<4;n++){var i=this.createArrowManipulator(n);t.push(i),this.tool.manipulators.add(i.manipulator);var r=this.createDragAction(),a=P.createManipulatorDragHandler(i.manipulator,this.createDragEventMappingFunction(n),r);this._handles.add(a),this._handles.add([i.manipulator.events.on("focus",(function(){e.tool.updateManipulators()})),i.manipulator.events.on("immediate-click",(function(e){e.stopPropagation()}))])}this.arrowManipulatorInfos=t,this.arrowManipulatorInfos.forEach((function(t){v.placeManipulatorAtGraphic(t.manipulator,e.tool.graphic)})),this._handles.add([c.init(this.tool.graphic,"geometry",(function(){e.arrowManipulatorInfos.forEach((function(t){v.placeManipulatorAtGraphic(t.manipulator,e.tool.graphic)}))})),c.init(this.tool.graphic,["visible","layer.visible"],(function(){var t=e.tool.graphic.visible&&e.tool.graphic.layer.visible;e.arrowManipulatorInfos.forEach((function(e){e.manipulator.visible=t}))}))])},e.prototype.updateManipulators=function(e,t,n){var i=this.tool.symbolRotationAngle,r=u.mat4.identity(y.sm4d.get());0!==i&&u.mat4.rotate(r,r,i,f.vec3f64.fromValues(0,0,1));var a=u.mat4.multiply(y.sm4d.get(),e,r),o=function(e){return"local"===e.viewingMode||e.scale<g.ALIGN_ARROWS_SCALE_THRESHOLD}(this.tool.view)?a:e,l=this.dragging,c=t||s("esri-mobile")?A.Visible:0;this.arrowManipulatorInfos.forEach((function(e){var t=u.mat4.multiply(y.sm4d.get(),o,e.transform);e.manipulator.state=l?c|(e.manipulator.dragging?A.Highlighted:0):c|(e.manipulator.focused&&n?A.Highlighted:0),e.manipulator.modelTransform=t}))},e.prototype.createArrowManipulator=function(e){var t=Math.sqrt(g.DISC_TRANSLATE_ARROW_SIZE*g.DISC_TRANSLATE_ARROW_SIZE*3/4),n=x.createExtrudedTriangle(t,g.DISC_TRANSLATE_ARROW_SIZE/2,g.DISC_TRANSLATE_ARROW_SIZE/2,g.DISC_HEIGHT);x.transformInPlace(n,u.mat4.fromTranslation(y.sm4d.get(),p.vec3.set(y.sv3d.get(),0,-t/3,0)));var i=new b(n,"graphic-transform-disc-arrow"+e),r=this.createMaterial(),a=this.createMaterial(.5),o=this.createMaterial(0),s=new h.Manipulator3D({view:this.tool.view,renderObjects:[{geometry:i,material:r,stateMask:A.Visible|A.Highlighted},{geometry:i,material:a,stateMask:A.Visible},{geometry:i,material:o,stateMask:0}],autoScaleRenderObjects:!1,radius:t,focusMultiplier:1,touchMultiplier:1,elevationInfo:{mode:"on-the-ground",offset:0},collisionType:{type:"disc",direction:f.vec3f64.fromValues(0,0,1)}}),l=u.mat4.identity(y.sm4d.get());u.mat4.fromZRotation(l,e*Math.PI/2);var c=u.mat4.identity(y.sm4d.get());u.mat4.fromTranslation(c,p.vec3.set(y.sv3d.get(),0,g.DISC_TRANSLATE_ARROW_OFFSET,0));var v=d.mat4f64.create();return u.mat4.multiply(v,l,c),{manipulator:s,transform:v}},e.prototype.createMaterial=function(e){void 0===e&&(e=1);var t=g.HANDLE_COLOR.concat([e]),n=new _({color:t,transparent:1!==e,cullFace:2},"graphic-transform");return n.renderOccluded=2,n},e.prototype.createDragEventMappingFunction=function(e){var t=this;return function(n){var i=t.arrowRotationAngle,r=[Math.cos(i),Math.sin(i),0],a=[-r[1],r[0],0],o=w.createMapAxisConstrainedScreenToMapDrag(m.createForGraphicAtLocation(t.tool.view,t.tool.graphic,n.elevationAlignedLocation),e%2==0?a:r,l.expect(t.tool.graphic.geometry).spatialReference);return l.isNone(o)?null:function(e){var t=o(e);return l.isNone(t)?null:t}}},e}();t.GraphicXYAxisTransform=C}).apply(null,i))||(e.exports=r)},tUyH:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("9opi"),n("qKT0"),n("Vx27"),n("KRuQ")],void 0===(r=(function(e,t,n,i,r,a){Object.defineProperty(t,"__esModule",{value:!0});var o=function(e){function t(t){var n=e.call(this)||this;return n.material=t.material,n.programRep=t.programRep,n.techniqueRep=t.techniqueRep,n}return n(t,e),t.prototype.isVisible=function(){return this.material.isVisible()},t.prototype.isVisibleInPass=function(e){return this.material.isVisibleInPass(e)},t.prototype.getPrograms=function(){return[this.getProgram()]},t.prototype.getDrawMode=function(){return 4},t.prototype.ensureResources=function(e){return 0},t.prototype.ensureAttributeLocations=function(e){this.getProgram().assertCompatibleVertexAttributeLocations(e)},i([r.subclass("esri.views.3d.webgl-engine.lib.GLMaterial")],t)}(r.declared(a.AutoDisposable));t.GLMaterial=o}).apply(null,i))||(e.exports=r)},"u90+":function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("Lzvl")],void 0===(r=(function(e,t,n){function i(e){return e&&"upperLeft"===e.originPosition}function r(e,t){return Math.round((t-e.translate[0])/e.scale[0])}function a(e,t){return Math.round((e.translate[1]-t)/e.scale[1])}function o(e,t,n){for(var i,o,s,l,c=[],u=0;u<n.length;u++){var d=n[u];u>0?(s=r(e,d[0]),l=a(e,d[1]),s===i&&l===o||(c.push(t(d,s-i,l-o)),i=s,o=l)):(i=r(e,d[0]),o=a(e,d[1]),c.push(t(d,i,o)))}return c.length>0?c:null}function s(e,t,n,i){return o(e,n?i?C:A:i?A:w,t)}function l(e,t,n,i){for(var r=[],a=n?i?C:A:i?A:w,s=0;s<t.length;s++){var l=o(e,a,t[s]);l&&l.length>=3&&r.push(l)}return r.length?r:null}function c(e,t,n,i){for(var r=[],a=n?i?C:A:i?A:w,s=0;s<t.length;s++){var l=o(e,a,t[s]);l&&l.length>=2&&r.push(l)}return r.length?r:null}function u(e,t){return t*e.scale[0]+e.translate[0]}function d(e,t){return e.translate[1]-t*e.scale[1]}function p(e,t,n){var i=new Array(n.length);if(!n.length)return i;var r=e.scale,a=r[0],o=r[1],s=u(e,n[0][0]),l=d(e,n[0][1]);i[0]=t(n[0],s,l);for(var c=1;c<n.length;c++){var p=n[c];i[c]=t(p,s+=p[0]*a,l-=p[1]*o)}return i}function f(e,t,n){for(var i=new Array(n.length),r=0;r<n.length;r++)i[r]=p(e,t,n[r]);return i}function h(e,t,n,i){return p(e,n?i?C:A:i?A:w,t)}function v(e,t,n,i){return f(e,n?i?C:A:i?A:w,t)}function m(e,t,n,i){return f(e,n?i?C:A:i?A:w,t)}function g(e,t,n){for(var i=n[0],r=i[0],a=i[1],o=Math.min(r,t[0]),s=Math.min(a,t[1]),l=Math.max(r,t[2]),c=Math.max(a,t[3]),u=1;u<n.length;u++){var d=n[u],p=d[0],f=d[1];r+=p,a+=f,p<0&&(o=Math.min(o,r)),p>0&&(l=Math.max(l,r)),f<0?s=Math.min(s,a):f>0&&(c=Math.max(c,a))}return e[0]=o,e[1]=s,e[2]=l,e[3]=c,e}function y(e,t){if(!t.length)return null;e[0]=e[1]=Number.POSITIVE_INFINITY,e[2]=e[3]=Number.NEGATIVE_INFINITY;for(var n=0;n<t.length;n++)g(e,e,t[n]);return e}function b(e,t,n,i,o){return t.xmin=r(e,n.xmin),t.ymin=a(e,n.ymin),t.xmax=r(e,n.xmax),t.ymax=a(e,n.ymax),t!==n&&(i&&(t.zmin=n.zmin,t.zmax=n.zmax),o&&(t.mmin=n.mmin,t.mmax=n.mmax)),t}function x(e,t,n,i,r){return t.points=s(e,n.points,i,r),t}function _(e,t,n,i,o){return t.x=r(e,n.x),t.y=a(e,n.y),t!==n&&(i&&(t.z=n.z),o&&(t.m=n.m)),t}function S(e,t,n,i,r){var a=l(e,n.rings,i,r);return a?(t.rings=a,t):null}function P(e,t,n,i,r){var a=c(e,n.paths,i,r);return a?(t.paths=a,t):null}Object.defineProperty(t,"__esModule",{value:!0});var w=function(e,t,n){return[t,n]},A=function(e,t,n){return[t,n,e[2]]},C=function(e,t,n){return[t,n,e[2],e[3]]};t.toQuantizationTransform=function(e){return e?{originPosition:"upper-left"===e.originPosition?"upperLeft":"lower-left"===e.originPosition?"lowerLeft":e.originPosition,scale:[e.tolerance,e.tolerance],translate:[e.extent.xmin,e.extent.ymax]}:null},t.equals=function(e,t){return e===t||null==e&&null==t||null!=e&&null!=t&&(i(e)?(n=e.translate[0],r=e.translate[1],a=e.scale[0]):(n=e.extent.xmin,r=e.extent.ymax,a=e.tolerance),i(t)?(o=t.translate[0],s=t.translate[1],l=t.scale[0]):(o=t.extent.xmin,s=t.extent.ymax,l=t.tolerance),n===o&&r===s&&a===l);var n,r,a,o,s,l},t.quantizeX=r,t.quantizeY=a,t.quantizeBounds=function(e,t,n){return t[0]=r(e,n[0]),t[3]=a(e,n[1]),t[2]=r(e,n[2]),t[1]=a(e,n[3]),t},t.quantizePoints=s,t.quantizeRings=l,t.quantizePaths=c,t.hydrateX=u,t.hydrateY=d,t.hydrateCoordsArray=p,t.hydrateCoordsArrayArray=f,t.hydrateBounds=function(e,t,n){return n?(t[0]=u(e,n[0]),t[1]=d(e,n[3]),t[2]=u(e,n[2]),t[3]=d(e,n[1]),t):[u(e,t[0]),d(e,t[3]),u(e,t[2]),d(e,t[1])]},t.hydratePoints=h,t.hydratePaths=v,t.hydrateRings=m,t.getQuantizedBoundsCoordsArray=g,t.getQuantizedBoundsCoordsArrayArray=y,t.getQuantizedBoundsPoints=function(e){var t=[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY];return g(t,t,e)},t.getQuantizedBoundsPaths=function(e){return y([0,0,0,0],e)},t.getQuantizedBoundsRings=function(e){return y([0,0,0,0],e)},t.quantizeExtent=b,t.quantizeMultipoint=x,t.quantizePoint=_,t.quantizePolygon=S,t.quantizePolyline=P,t.quantizeGeometry=function(e,t){return e&&t?n.isPoint(t)?_(e,{},t,!1,!1):n.isPolyline(t)?P(e,{},t,!1,!1):n.isPolygon(t)?S(e,{},t,!1,!1):n.isMultipoint(t)?x(e,{},t,!1,!1):n.isExtent(t)?b(e,{},t,!1,!1):null:null},t.hydrateExtent=function(e,t,n,i,r){return t.xmin=u(e,n.xmin),t.ymin=d(e,n.ymin),t.xmax=u(e,n.xmax),t.ymax=d(e,n.ymax),t!==n&&(i&&(t.zmin=n.zmin,t.zmax=n.zmax),r&&(t.mmin=n.mmin,t.mmax=n.mmax)),t},t.hydrateMultipoint=function(e,t,n,i,r){return t.points=h(e,n.points,i,r),t},t.hydratePoint=function(e,t,n,i,r){return t.x=u(e,n.x),t.y=d(e,n.y),t!==n&&(i&&(t.z=n.z),r&&(t.m=n.m)),t},t.hydratePolygon=function(e,t,n,i,r){return t.rings=m(e,n.rings,i,r),t},t.hydratePolyline=function(e,t,n,i,r){return t.paths=v(e,n.paths,i,r),t}}).apply(null,i))||(e.exports=r)},uEh2:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("DKwL"),n("7Aei")],void 0===(r=(function(e,t,n,i,r){var a,o;Object.defineProperty(t,"__esModule",{value:!0}),t.OutputDepth=function(e,t){e.include(i.RgbaFloatEncoding),3===t.output?(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(r.glsl(a||(a=n(["\n      float _calculateFragDepth(const in float depth) {\n        // calc polygon offset\n        const float SLOPE_SCALE = 2.0;\n        const float BIAS = 2.0 * .000015259;    // 1 / (2^16 - 1)\n        float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n        float result = depth + SLOPE_SCALE * m + BIAS;\n        return clamp(result, .0, .999999);\n      }\n\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));\n      }\n    "],["\n      float _calculateFragDepth(const in float depth) {\n        // calc polygon offset\n        const float SLOPE_SCALE = 2.0;\n        const float BIAS = 2.0 * .000015259;    // 1 / (2^16 - 1)\n        float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n        float result = depth + SLOPE_SCALE * m + BIAS;\n        return clamp(result, .0, .999999);\n      }\n\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));\n      }\n    "]))))):1===t.output&&e.fragment.code.add(r.glsl(o||(o=n(["\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_linearDepth);\n      }\n    "],["\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_linearDepth);\n      }\n    "]))))}}).apply(null,i))||(e.exports=r)},uNX8:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("1m5D"),n("MzcX"),n("ff/U"),n("pbva"),n("PwS/"),n("QFi0"),n("Kfys"),n("z2+Q")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c){function u(e,t,n){var i=t.elementCount(e),r=t.allocate(i);t.write({},e,r,0),n.setData(r.buffer)}return function(){function e(e,t,n,i){void 0===i&&(i=r.Default3D),this.type="InstancedRenderer",this._dataByOrigin=new Map,this._highlightCount=0,this._rctx=e,this._vertexAttributeLocations=i,this._material=n,this._materialRep=t,this._glMaterials=o.acquireMaterials(this._material,this._materialRep),this._bufferWriter=n.createBufferWriter()}return e.prototype.dispose=function(){o.releaseMaterials(this._material,this._materialRep)},Object.defineProperty(e.prototype,"isEmpty",{get:function(){return 0===this._dataByOrigin.size},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"hasHighlights",{get:function(){return this._highlightCount>0},enumerable:!0,configurable:!0}),e.prototype.hasWater=function(){return!1},e.prototype.renderPriority=function(){return this._material.renderPriority},e.prototype.modify=function(e){this.updateGeometries(e.toUpdate),this.addAndRemoveGeometries(e.toAdd,e.toRemove),this.updateHighlightCount()},e.prototype.addAndRemoveGeometries=function(e,t){var r=this,d=this._rctx,p=this._bufferWriter,f=this._dataByOrigin,h=function(e,t){var n=new Map,i=function(e,t){var i=e.origin.id,r=e.data.id,a=n.get(i);a||(a={origin:e.origin.vec3,deltaByGeometry:new Map},n.set(i,a));var o=a.deltaByGeometry.get(r);o||a.deltaByGeometry.set(r,o={renderData:e.data,toAdd:[],toRemove:[]}),(t?o.toAdd:o.toRemove).push(e)};return e.forEach((function(e){i(e,!0)})),t.forEach((function(e){i(e,!1)})),n}(e,t),v=p.vertexBufferLayout;h.forEach((function(e,t){var h=f.get(t);h||(h={origin:e.origin,highlightCount:0,dataByGeometry:new Map},f.set(t,h)),e.deltaByGeometry.forEach((function(e,t){var f=h.dataByGeometry.get(t);!f&&e.toAdd.length>0&&(f={vao:new c(d,r._vertexAttributeLocations,{geometry:i.glLayout(v)},{geometry:s.createVertex(d,35044)}),vertexCount:0,instances:new Map,highlightCount:0},u(e.renderData,p,f.vao.vertexBuffers.geometry),f.vertexCount=l.vertexCount(f.vao,"geometry"),h.dataByGeometry.set(t,f));var m=f.instances;e.toAdd.forEach((function(e){var t=n.mat4f64.create();o.calculateTransformRelToOrigin(e,t);var i=o.generateRenderGeometryVisibleIndexRanges(e),r=o.generateRenderGeometryHighlightRanges(e),s=new a(e.name,0,f.vertexCount,i,r,t,e.instanceParameters,e.idx,e.data.id);m.set(e.uniqueName,s),h.highlightCount=null,f.highlightCount=null})),e.toRemove.forEach((function(e){m.delete(e.uniqueName)})),0===m.size&&(f.vao.dispose(),h.dataByGeometry.delete(t))})),0===h.dataByGeometry.size&&f.delete(t)}))},e.prototype.updateGeometries=function(e){var t=this._dataByOrigin,n=this._bufferWriter;e.forEach((function(e){var i=e.updateType,r=e.renderGeometry,a=t.get(r.origin.id),s=a&&a.dataByGeometry.get(r.data.id),l=s&&s.instances.get(r.uniqueName);l&&(1&i&&(l.displayedIndexRange=o.generateRenderGeometryVisibleIndexRanges(r)),17&i&&(l.highlightedIndexRanges=o.generateRenderGeometryHighlightRanges(r),a.highlightCount=null,s.highlightCount=null),2&i&&u(r.data,n,s.vao.vertexBuffers.geometry),4&i&&o.calculateTransformRelToOrigin(r,l.transformation,l.transformationNormal))}))},e.prototype.updateHighlightCount=function(){var e=this;this._highlightCount=0,this._dataByOrigin.forEach((function(t){if(null==t.highlightCount){var n=0;t.dataByGeometry.forEach((function(e){if(null==e.highlightCount){var t=0;e.instances.forEach((function(e){e.highlightedIndexRanges&&++t})),e.highlightCount=t}n+=e.highlightCount})),t.highlightCount=n}e._highlightCount+=t.highlightCount}))},e.prototype.render=function(e,t,n,i){var r=this,a=this._rctx,o=this._glMaterials.get(t.pass),s=4===t.pass;if(!o||null!=e&&!o.beginSlot(e)||s&&0===this._highlightCount)return!1;o.bind(a,n);var l=!1;return this._dataByOrigin.forEach((function(e){s&&0===e.highlightCount||(n.origin=e.origin,o.bindView(n),e.dataByGeometry.forEach((function(e){l=s?r.renderHighlightPass(o,e,i)||l:r.renderDefaultPass(o,e,i)||l})))})),a.bindVAO(null),o.release(),l},e.prototype.renderDefaultPass=function(e,t,n){var i=this._rctx,r=e.getDrawMode(),a=t.vao,s=t.vertexCount;e.ensureAttributeLocations(a),i.bindVAO(a);var l=!1;return t.instances.forEach((function(t){var a=t.displayedIndexRange;a&&0===a.length||(e.bindInstance(t),a?o.drawArraysFaceRange(i,a,0,r,n):o.drawArrays(i,r,0,s,n),l=!0)})),l},e.prototype.renderHighlightPass=function(e,t,n){var i=this._rctx,r=e.getDrawMode(),a=t.vao,s=t.vertexCount;if(0!==t.highlightCount){e.ensureAttributeLocations(a),i.bindVAO(a);var l=!1;return t.instances.forEach((function(t){var a=t.highlightedIndexRanges;if(a&&0!==a.length){e.bindInstance(t);for(var c=0;c<a.length;c++){var u=a[c];o.drawArrays(i,r,u.range?u.range[0]:0,u.range?u.range[1]-u.range[0]+1:s,n),l=!0}}})),l}},e}()}).apply(null,i))||(e.exports=r)},uci5:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.PositionAttribute=function(e){e.attributes.add("position","vec3"),e.vertex.code.add(i.glsl(r||(r=n(["\n    vec3 positionModel() { return position; }\n  "],["\n    vec3 positionModel() { return position; }\n  "]))))}}).apply(null,i))||(e.exports=r)},v22c:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("xhoE"),n("qKT0"),n("2Atf"),n("W/V4"),n("FQ4r"),n("lBa0"),n("ff/U"),n("jl7D"),n("G0ER"),n("qbr3")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d){Object.defineProperty(t,"__esModule",{value:!0});var p=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return n(i,t),i.prototype.initializeProgram=function(e){var t=i.shader.get(),n=this.configuration,r=t.build({output:n.output,viewingMode:e.viewingMode,slicePlaneEnabled:n.slice,sliceHighlightDisabled:!1,receiveShadows:n.receiveShadows,usePBR:!1,usePBRforWater:!0,useCustomDTRExponentForWater:!0});return new u(e.rctx,r.generateSource("vertex"),r.generateSource("fragment"),l.Default3D)},i.prototype.initializePipeline=function(){var e=this.configuration;return d.makePipelineState(2===e.output?{depthTest:{func:513},depthWrite:e.writeDepth&&d.defaultDepthWriteParams,colorWrite:d.defaultColorWriteParams}:{blending:e.transparent&&d.separateBlendingParams(770,1,771,771),depthTest:{func:513},depthWrite:e.writeDepth&&d.defaultDepthWriteParams,colorWrite:d.defaultColorWriteParams})},i.prototype.bindPipelineState=function(e){e.setPipelineState(this.pipeline)},i.shader=new a.ReloadableShaderModule(c,"../shaders/WaterSurface.glsl",e),i}(o.ShaderTechnique);t.WaterTechnique=p;var f=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.output=0,t.receiveShadows=!1,t.slice=!1,t.transparent=!1,t.writeDepth=!1,t}return n(t,e),i([s.parameter({count:6})],t.prototype,"output",void 0),i([s.parameter()],t.prototype,"receiveShadows",void 0),i([s.parameter()],t.prototype,"slice",void 0),i([s.parameter()],t.prototype,"transparent",void 0),i([s.parameter()],t.prototype,"writeDepth",void 0),t}(s.ShaderTechniqueConfiguration);t.WaterTechniqueConfiguration=f}).apply(null,i))||(e.exports=r)},vGsU:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("ybGv"),n("piY7"),n("7Aei")],void 0===(r=(function(e,t,n,i,r,a){var o;Object.defineProperty(t,"__esModule",{value:!0}),t.Water=function(e,t){e.include(r.PhysicallyBasedRendering,t),e.include(i.Gamma),e.fragment.code.add(a.glsl(o||(o=n(["\n    const vec3 fresnelSky =  vec3(0.02, 1.0, 5.0); // f0, f0max, exp\n    const vec2 fresnelMaterial =  vec2(0.02, 0.1); // f0, f0max for specular term\n    const float roughness = 0.06;\n\n    const vec3 skyZenitColor = vec3(0, 0.6, 0.9);\n    const vec3 skyColor = vec3(0.72, 0.92, 1.0);\n\n    PBRShadingWater shadingInfo;\n\n    /*\n    *   This function is an approximation for the sky gradient reflected\n    *   the water surface and describes a combination of two fresnel terms.\n    *   @parameter: cosTheta = is the result of max(dot(n,v), 0.0)\n    *   @parameter: horizon = the dominant color of the sky horizon\n    *   @parameter: cosTheta = the dominant color of the sky zenit\n    */\n    vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\n      float exponent = pow((1.0 - cosTheta), fresnelSky[2]);\n      return mix(zenit, horizon, exponent);\n    }\n\n    /*\n    *   This function determines the water color per pixel.\n    *   @parameter: n = normal facing away from the surface\n    *   @parameter: v = view direction facing away from the surface.\n    *   @parameter: l = light direction facing away from the surface\n    *   @parameter: lightIntensity = light intensity, currently between 0...PI\n    *   @parameter: localUp = a normal for the general direction of the surface\n    *   @parameter: shadow = the amount of shadow at this pixel (0 = no shadow)\n    */\n    vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow) {\n\n      vec3 seaWaterColor = linearizeGamma(color);\n      // using half vector to determine the specular light\n      vec3 h = normalize(l + v);\n      shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);\n      shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);\n      shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);\n      shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n      shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n      shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n\n      // angle between vertex normal and view direction\n      float upDotV = max(dot(localUp,v), 0.0);\n      // reflected sky color: the reflected sky color consists of two main colors, the\n      // reflected color at the horizon and the reflected color of the zenit.\n      // the reflected sky color is then an approximation based on the fresnel term.\n      vec3 skyHorizon = linearizeGamma(skyColor);\n      vec3 skyZenit = linearizeGamma(skyZenitColor);\n      vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );\n\n      // we use the upDotL to smoothen out the\n      // reflected color of the water\n      float upDotL = max(dot(localUp,l),0.0);\n\n      // The approximated sky color is adjusted according to the sun position.\n      // This is done as approximation for e.g. night views.\n      skyColor *= 0.1 + upDotL * 0.9;\n\n      // If a water surface is in shadow we just use a slight darkening of the\n      // water surface expressed with this shadowModifier.\n      float shadowModifier = clamp(shadow, 0.8, 1.0);\n\n      // The reflected sky color consists of the fresnel reflection multiplied with the approximated sky color.\n      // The shadow is influencing the frensel term to keep the shadow impression for really near views. As long\n      // as reflection are absent there is a need to have a slight shadow for depth perception.\n      vec3 reflSky = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]) * skyColor * shadowModifier;\n\n      // The reflected sea color is the input water color combined with the reflected sky color.\n      // The reflected sky color is modified by the incoming light.\n      vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;\n\n      vec3 specular = vec3(0.0);\n      // This prevents the specular light to be rendered when:\n      // - sun is behind a polygon (e.g. sundown for elevated polygons where nDotL might be still ok)\n      // - viewer is under water (for this localUp is better than n)\n      if(upDotV > 0.0 && upDotL > 0.0) {\n        // calculate the cook torrance BRDF but with simplified occlusion\n        vec3 specularSun = brdfWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);\n        // Normalize light intensity to be between 0...1. Shadow cancels out specular light here\n        vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;\n\n        specular = shadingInfo.NdotL * incidentLight * specularSun;\n      }\n      // combining reflected sky, reflected sea and specular highlight.\n      return tonemapACES(reflSky + reflSea + specular);\n    }\n  "],["\n    const vec3 fresnelSky =  vec3(0.02, 1.0, 5.0); // f0, f0max, exp\n    const vec2 fresnelMaterial =  vec2(0.02, 0.1); // f0, f0max for specular term\n    const float roughness = 0.06;\n\n    const vec3 skyZenitColor = vec3(0, 0.6, 0.9);\n    const vec3 skyColor = vec3(0.72, 0.92, 1.0);\n\n    PBRShadingWater shadingInfo;\n\n    /*\n    *   This function is an approximation for the sky gradient reflected\n    *   the water surface and describes a combination of two fresnel terms.\n    *   @parameter: cosTheta = is the result of max(dot(n,v), 0.0)\n    *   @parameter: horizon = the dominant color of the sky horizon\n    *   @parameter: cosTheta = the dominant color of the sky zenit\n    */\n    vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\n      float exponent = pow((1.0 - cosTheta), fresnelSky[2]);\n      return mix(zenit, horizon, exponent);\n    }\n\n    /*\n    *   This function determines the water color per pixel.\n    *   @parameter: n = normal facing away from the surface\n    *   @parameter: v = view direction facing away from the surface.\n    *   @parameter: l = light direction facing away from the surface\n    *   @parameter: lightIntensity = light intensity, currently between 0...PI\n    *   @parameter: localUp = a normal for the general direction of the surface\n    *   @parameter: shadow = the amount of shadow at this pixel (0 = no shadow)\n    */\n    vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow) {\n\n      vec3 seaWaterColor = linearizeGamma(color);\n      // using half vector to determine the specular light\n      vec3 h = normalize(l + v);\n      shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);\n      shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);\n      shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);\n      shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n      shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n      shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n\n      // angle between vertex normal and view direction\n      float upDotV = max(dot(localUp,v), 0.0);\n      // reflected sky color: the reflected sky color consists of two main colors, the\n      // reflected color at the horizon and the reflected color of the zenit.\n      // the reflected sky color is then an approximation based on the fresnel term.\n      vec3 skyHorizon = linearizeGamma(skyColor);\n      vec3 skyZenit = linearizeGamma(skyZenitColor);\n      vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );\n\n      // we use the upDotL to smoothen out the\n      // reflected color of the water\n      float upDotL = max(dot(localUp,l),0.0);\n\n      // The approximated sky color is adjusted according to the sun position.\n      // This is done as approximation for e.g. night views.\n      skyColor *= 0.1 + upDotL * 0.9;\n\n      // If a water surface is in shadow we just use a slight darkening of the\n      // water surface expressed with this shadowModifier.\n      float shadowModifier = clamp(shadow, 0.8, 1.0);\n\n      // The reflected sky color consists of the fresnel reflection multiplied with the approximated sky color.\n      // The shadow is influencing the frensel term to keep the shadow impression for really near views. As long\n      // as reflection are absent there is a need to have a slight shadow for depth perception.\n      vec3 reflSky = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]) * skyColor * shadowModifier;\n\n      // The reflected sea color is the input water color combined with the reflected sky color.\n      // The reflected sky color is modified by the incoming light.\n      vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;\n\n      vec3 specular = vec3(0.0);\n      // This prevents the specular light to be rendered when:\n      // - sun is behind a polygon (e.g. sundown for elevated polygons where nDotL might be still ok)\n      // - viewer is under water (for this localUp is better than n)\n      if(upDotV > 0.0 && upDotL > 0.0) {\n        // calculate the cook torrance BRDF but with simplified occlusion\n        vec3 specularSun = brdfWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);\n        // Normalize light intensity to be between 0...1. Shadow cancels out specular light here\n        vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;\n\n        specular = shadingInfo.NdotL * incidentLight * specularSun;\n      }\n      // combining reflected sky, reflected sea and specular highlight.\n      return tonemapACES(reflSky + reflSea + specular);\n    }\n  "]))))}}).apply(null,i))||(e.exports=r)},wOtw:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("2Atf"),n("LxLY")],void 0===(r=(function(e,t,n,i){function r(e,t,n){if(i.isNone(e))return null;var r=null,a=0,o=0,s=0;return function(l){"start"===l.action&&(r=e(l.start,n),a=0,o=0,s=0);var c=a,u=o,d=s,p=e(l.screenPoint,n);return i.isSome(r)&&i.isSome(p)&&(c=1&t?p.x-r.x:0,u=2&t?p.y-r.y:0,d=4&t?p.z-r.z:0),a=c,o=u,s=d,{action:l.action,deltaX:c,deltaY:u,deltaZ:d,spatialReference:n}}}Object.defineProperty(t,"__esModule",{value:!0}),t.createFromProject=r,t.createMapAxisConstrainedScreenToMapDrag=function(e,t,n){if(i.isNone(e))return null;var r=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);if(0===r)return null;var a=t[0]/r,o=t[1]/r,s=t[2]/r,l=null,c=0,u=0,d=0;return function(t){"start"===t.action&&(l=e(t.start,n),c=0,u=0,d=0);var r=c,p=u,f=d,h=e(t.screenPoint,n);if(i.isSome(l)&&i.isSome(h)){var v=(r=h.x-l.x)*a+(p=h.y-l.y)*o+(f=h.z-l.z)*s;r=v*a,p=v*o,f=v*s}var m={action:t.action,deltaX:r,deltaY:p,deltaZ:f,previousDeltaX:c,previousDeltaY:u,previousDeltaZ:d,spatialReference:n};return c=r,u=p,d=f,m}},t.createXYConstrainedFromProject=function(e,n){return r(e,t.horizontalDegreesOfFreedom,n)},t.createZConstrainedFromProject=function(e,n){return r(e,t.verticalDegreesOfFreedom,n)},t.withHistoryInfo=function(e){if(i.isNone(e))return e;var t=0,r=0,a=0;return function(o){var s=e(o);if(i.isNone(s))return null;"start"===o.action&&(t=0,r=0,a=0);var l=n({},s,{deltaDeltaX:s.deltaX-t,deltaDeltaY:s.deltaY-r,deltaDeltaZ:s.deltaZ-a});return t=s.deltaX,r=s.deltaY,a=s.deltaZ,l}},t.withScreenHistoryInfo=function(e){if(i.isNone(e))return e;var t=0,r=0;return function(a){var o=e(a);if(i.isNone(o))return null;"start"===a.action&&(t=a.start.x,r=a.start.y);var s=n({},o,{screenDeltaDeltaX:a.screenPoint.x-t,screenDeltaDeltaY:a.screenPoint.y-r});return t=a.screenPoint.x,r=a.screenPoint.y,s}},t.horizontalDegreesOfFreedom=3,t.verticalDegreesOfFreedom=4}).apply(null,i))||(e.exports=r)},weRx:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("2Atf"),n("zp6E")],void 0===(r=(function(e,t,n,i){Object.defineProperty(t,"__esModule",{value:!0}),t.dataURItoBlob=function(e){for(var t=atob(e.split(",")[1]),n=e.split(",")[0].split(":")[1].split(";")[0],i=new ArrayBuffer(t.length),r=new Uint8Array(i),a=0;a<t.length;a++)r[a]=t.charCodeAt(a);return new Blob([i],{type:n})},t.requestImage=function(e,t){return i(e,n({responseType:"image"},t)).then((function(e){return e.data}))}}).apply(null,i))||(e.exports=r)},woUR:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("2Atf"),n("TMur"),n("pcDC"),n("BcWh"),n("LxLY"),n("jBNx"),n("YX1r"),n("51bw"),n("FXVB"),n("1m5D"),n("W9tT"),n("0LE5"),n("Rdxj"),n("lRq4"),n("ZcgO"),n("aWgr"),n("mmEe"),n("JjCO"),n("RsYQ"),n("ZO6V"),n("ZJC8")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p,f,h,v,m,g,y,b,x,_,S,P){function w(e){return 0!==e[12]||0!==e[13]||0!==e[14]}Object.defineProperty(t,"__esModule",{value:!0});var A=function(){function e(e){for(var t in this.camera=new _.default,this._elevation={offset:0,override:0},this._hideOnGrab=!1,this.collisionType={type:"point"},this.collisionPriority=0,this.renderObjects=[],this.autoScaleRenderObjects=!0,this._visible=!0,this._radius=10,this._worldSized=!1,this.focusMultiplier=2,this.touchMultiplier=2.5,this.worldOriented=!1,this._modelTransform=p.mat4f64.create(),this._worldFrame=null,this._renderLocation=v.vec3f64.create(),this._renderLocationDirty=!0,this._elevationAlignedLocation=new r.Point,this._elevationAlignedLocationDirty=!0,this.interactive=!0,this.selectable=!1,this.cursor=null,this._grabbing=!1,this.dragging=!1,this._hovering=!1,this._selected=!1,this._state=0,this._focused=!1,this.events=new o({target:this}),this._screenLocation={screenPointArray:l.createScreenPointArray(),renderScreenPointArray:l.createRenderScreenPointArray3(),pixelSize:0},this._screenLocationDirty=!0,this._engineResourcesAddedToStage=!1,this._engineResources=null,this._attached=!1,this._engineLayerId=null,this._materialIdReferences=null,this._location=new r.Point({x:0,y:0,z:0,spatialReference:e.view.spatialReference}),e)this[t]=e[t];this.view.state&&this.view.state.camera&&this.camera.copyFrom(this.view.state.camera)}return e.prototype.destroy=function(){this._removeResourcesFromStage(),this._engineResources=null,this.view=null,this.camera=null},Object.defineProperty(e.prototype,"elevationInfo",{get:function(){return this._elevationInfo},set:function(e){this._elevationInfo=e,this._elevationAlignedLocationDirty=!0,this._updateEngineObject()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"hideOnGrab",{get:function(){return this._hideOnGrab},set:function(e){this._hideOnGrab!==e&&(this._hideOnGrab=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"visible",{get:function(){return this._visible},set:function(e){e!==this._visible&&(this._visible=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"radius",{get:function(){return this._radius},set:function(e){e!==this._radius&&(this._radius=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"worldSized",{get:function(){return this._worldSized},set:function(e){e!==this._worldSized&&(this._worldSized=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"modelTransform",{get:function(){return this._modelTransform},set:function(e){w(e)&&(this._screenLocationDirty=!0),d.mat4.copy(this._modelTransform,e),this._updateEngineObject()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"renderLocation",{get:function(){return this._renderLocationDirty&&(this._renderLocationDirty=!1,this.view.renderCoordsHelper.toRenderCoords(this.elevationAlignedLocation,this._renderLocation),this.worldOriented?(this._worldFrame||(this._worldFrame=p.mat4f64.create()),b.computeLinearTransformation(this.view.renderSpatialReference,this._renderLocation,this._worldFrame,this.view.renderSpatialReference),this._worldFrame[12]=0,this._worldFrame[13]=0,this._worldFrame[14]=0):this._worldFrame&&(this._worldFrame=null)),this._renderLocation},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"location",{get:function(){return this._location},set:function(e){g.clonePoint(e,this._location),this._renderLocationDirty=!0,this._screenLocationDirty=!0,this._elevationAlignedLocationDirty=!0,this._updateEngineObject()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"elevationAlignedLocation",{get:function(){return this._elevationAlignedLocationDirty?(this._evaluateElevationAlignment(),this._updateElevationAlignedLocation(),this._elevationAlignedLocation):this.elevationAlignedLocation},set:function(e){g.clonePoint(e,this._location),this._evaluateElevationAlignment(),this._location.z-=this._elevation.offset,this._updateElevationAlignedLocation(),this._updateEngineObject()},enumerable:!0,configurable:!0}),e.prototype._updateElevationAlignedLocation=function(){this._elevationAlignedLocation.x=this.location.x,this._elevationAlignedLocation.y=this.location.y;var e=s.isSome(this._elevation.override)?this._elevation.override:this.location.z||0;this._elevationAlignedLocation.z=e+this._elevation.offset,this._elevationAlignedLocation.spatialReference=this.location.spatialReference,this._renderLocationDirty=!0,this._screenLocationDirty=!0},Object.defineProperty(e.prototype,"grabbing",{get:function(){return this._grabbing},set:function(e){e!==this._grabbing&&(this._grabbing=e,this._setFocused(this._hovering||this._grabbing),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"hovering",{get:function(){return this._hovering},set:function(e){e!==this._hovering&&(this._hovering=e,this._setFocused(this._hovering||this._grabbing),this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"selected",{get:function(){return this._selected},set:function(e){e!==this._selected&&(this._selected=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"state",{get:function(){return this._state},set:function(e){e!==this._state&&(this._state=e,this._updateEngineObject())},enumerable:!0,configurable:!0}),e.prototype._setFocused=function(e){e!==this._focused&&(this._focused=e,this.events.emit("focus",{action:!0===e?"focus":"unfocus"}))},Object.defineProperty(e.prototype,"focused",{get:function(){return this._focused},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"screenLocation",{get:function(){return this.ensureScreenLocation(),this._screenLocation},enumerable:!0,configurable:!0}),e.prototype.ensureScreenLocation=function(){if(this._screenLocationDirty){var e;if(this._screenLocation.pixelSize=this.camera.computeScreenPixelSizeAt(this.renderLocation),this._screenLocationDirty=!1,w(this._modelTransform)){var t=this._calculateModelTransformOffset(N);e=h.vec3.add(t,t,this.renderLocation)}else e=this.renderLocation;this.camera.projectPoint(e,this._screenLocation.renderScreenPointArray),this.camera.renderToScreen(this._screenLocation.renderScreenPointArray,this._screenLocation.screenPointArray)}},e.prototype.intersectionDistance=function(e,t){if(!this.visible)return null;var n=l.screenPointObjectToArray(e,C),i=this._getCollisionRadius(t),r=-1*this.collisionPriority;switch(this.collisionType.type){case"point":if(f.vec2.squaredDistance(this.screenLocation.screenPointArray,n)<i*i)return this.screenLocation.renderScreenPointArray[2]+r;break;case"line":for(var o=this.collisionType.paths,s=this._getWorldToScreenObjectScale(),u=this._calculateObjectTransform(s,T),d=i*this.screenLocation.pixelSize,p=y.ray.fromScreen(this.camera,n,M),v=0,m=o;v<m.length;v++)if(0!==(U=m[v]).length)for(var g=h.vec3.transformMat4(z,U[0],u),b=1;b<U.length;b++){var _=h.vec3.transformMat4(L,U[b],u);if(null!=(q=y.lineSegment.closestRayDistance2(y.lineSegment.fromPoints(g,_,O),p))&&q<d*d){var S=h.vec3.add(x.sv3d.get(),g,_);h.vec3.scale(S,S,.5);var P=l.castRenderScreenPointArray(x.sv3d.get());return this.camera.projectPoint(S,P),P[2]+r}h.vec3.copy(g,_)}break;case"disc":var w=this.collisionType.direction,A=(s=this._getWorldToScreenObjectScale(),u=this._calculateObjectTransform(s,T),d=i*this.screenLocation.pixelSize,p=y.ray.fromScreen(this.camera,n,M),c.mat3.fromMat4(D,u)),R=h.vec3.transformMat3(j,w,A),N=this._calculateModelTransformPosition(V);if(y.plane.fromPositionAndNormal(N,R,I),y.plane.intersectRay(I,p,F=E)&&h.vec3.squaredDistance(F,N)<d*d)return this.screenLocation.renderScreenPointArray[2]+r;break;case"ribbon":var F,G=this.collisionType;if(o=G.paths,w=G.direction,s=this._getWorldToScreenObjectScale(),u=this._calculateObjectTransform(s,T),d=i*this.camera.computeScreenPixelSizeAt(this.renderLocation),p=y.ray.fromScreen(this.camera,n,M),A=c.mat3.fromMat4(D,u),R=h.vec3.transformMat3(j,w,A),N=this._calculateModelTransformPosition(V),y.plane.fromPositionAndNormal(N,R,I),!y.plane.intersectRay(I,p,F=E))break;for(var B=0,H=o;B<H.length;B++){var U;if(0!==(U=H[B]).length)for(g=h.vec3.transformMat4(z,U[0],u),b=1;b<U.length;b++){var q;if(_=h.vec3.transformMat4(L,U[b],u),null!=(q=y.lineSegment.distance2(y.lineSegment.fromPoints(g,_,O),F))&&q<d*d)return S=h.vec3.add(x.sv3d.get(),g,_),h.vec3.scale(S,S,.5),P=l.castRenderScreenPointArray(x.sv3d.get()),this.camera.projectPoint(S,P),P[2]+r;h.vec3.copy(g,_)}}break;default:a.neverReached(this.collisionType)}return null},e.prototype.attach=function(e){if(void 0===e&&(e={manipulator3D:{}}),this.view._stage){var t=e.manipulator3D;if(this._engineLayerId=t.engineLayerId,s.isNone(this._engineLayerId)){var n=new S("manipulator-3d",{isPickable:!1});this.view._stage.add(0,n),this.view._stage.addToViewContent([n.id]),this._engineLayerId=n.id,t.engineLayerId=n.id}t.engineLayerReferences=(t.engineLayerReferences||0)+1,this._materialIdReferences=t.materialIdReferences,s.isNone(this._materialIdReferences)&&(this._materialIdReferences=new Map,t.materialIdReferences=this._materialIdReferences),this.camera.copyFrom(this.view.state.camera),this._attached=!0,this._updateEngineObject(),b.canProject(this._location.spatialReference,this.view.spatialReference)||(this.location=new r.Point({x:0,y:0,z:0,spatialReference:this.view.spatialReference}))}},e.prototype.detach=function(e){void 0===e&&(e={manipulator3D:{}});var t=e.manipulator3D;t.engineLayerReferences--;var n=0===t.engineLayerReferences;n&&(t.engineLayerId=null),this._removeResourcesFromStage(n),this._engineResources=null,this._engineLayerId=null,this._materialIdReferences=null,this._attached=!1},e.prototype.onViewChange=function(){this.camera.copyFrom(this.view.state.camera),this._screenLocationDirty=!0,this._updateEngineObject()},e.prototype.onElevationChange=function(e){m.containsPointObject(e.extent,this.location)&&(this._elevationAlignedLocationDirty=!0,this._updateEngineObject())},e.prototype._evaluateElevationAlignment=function(e){if(void 0===e&&(e=this.location),s.isNone(this.elevationInfo))return!1;var t=null,n=0;switch(this.elevationInfo.mode){case"on-the-ground":t=this.view.elevationProvider.getElevation(e,"ground")||0;break;case"relative-to-ground":n=(this.view.elevationProvider.getElevation(e,"ground")||0)+(this.elevationInfo.offset||0);break;case"relative-to-scene":n=(this.view.elevationProvider.getElevation(e,"scene")||0)+(this.elevationInfo.offset||0);break;case"absolute-height":n=this.elevationInfo.offset||0}return(n!==this._elevation.offset||t!==this._elevation.override)&&(this._elevation.offset=n,this._elevation.override=t,!0)},e.prototype._updateEngineObject=function(){if(this._attached){if(!1===this.visible)return void this._removeResourcesFromStage();var e=this._getWorldToScreenObjectScale(),t=T;if(!0===this.autoScaleRenderObjects){var n=this._getFocusedSize(this._radius,this.focused)*e;this._calculateObjectTransform(n,t)}else this._calculateObjectTransform(e,t);for(var i=this._ensureEngineResources().objectsByState,r=(this.focused?2:1)|(this.selected?8:4),a=this.hideOnGrab&&this.grabbing,o=0,s=i;o<s.length;o++){var l=s[o],c=l.stateMask,u=l.objects;if(a)for(var d=0,p=u;d<p.length;d++)(v=p[d]).hideAllComponents();else if(0!=(15&c)&&(r&c)!=(15&c)||0!=(65520&c)&&(this.state&c)!=(65520&c))for(var f=0,h=u;f<h.length;f++){var v;(v=h[f]).hideAllComponents()}else for(var m=0,g=u;m<g.length;m++)(v=g[m]).unhideAllComponents(),v.objectTransformation=t}}},e.prototype._ensureEngineResources=function(){if(s.isNone(this._engineResources)){var e=this.view._stage.getContent(0,s.expect(this._engineLayerId)),t=[],n=new Set;this.renderObjects.forEach((function(e){var i=e.material;n.has(i)||(t.push(i),n.add(i))}));var i=new Map;this.renderObjects.forEach((function(e){var t=new P({idHint:"manipulator"});!function(e,t){var n=t.geometry,i=t.material,r=t.transform;Array.isArray(n)?n.forEach((function(t){return e.addGeometry(t,i,r)})):e.addGeometry(n,i,r)}(t,e);var n=e.stateMask||0,r=i.get(n)||[];r.push(t),i.set(n,r)}));var r=[];i.forEach((function(e,t){r.push({stateMask:t,objects:e})})),this._engineResources={objectsByState:r,layer:e,materials:t}}return this._addResourcesToStage(),this._engineResources},e.prototype._addResourcesToStage=function(){var e=this;if(!this._engineResourcesAddedToStage&&!s.isNone(this._engineResources)){var t=this._engineResources,n=t.objectsByState,i=t.layer;t.materials.forEach((function(t){var n=s.expect(e._materialIdReferences),i=n.get(t.id)||0;0===i&&e.view._stage.add(3,t),n.set(t.id,i+1)})),n.forEach((function(t){t.objects.forEach((function(t){i.addObject(t),e.view._stage.add(1,t)}))})),this._engineResourcesAddedToStage=!0}},e.prototype._removeResourcesFromStage=function(e){var t=this;if(void 0===e&&(e=!1),this._engineResourcesAddedToStage&&!s.isNone(this._engineResources)){var n=this._engineResources,i=n.layer,r=n.materials;n.objectsByState.forEach((function(e){e.objects.forEach((function(e){i.removeObject(e),t.view._stage.remove(1,e.id)}))})),r.forEach((function(e){var n=s.expect(t._materialIdReferences),i=n.get(e.id);1===i?(t.view._stage.remove(3,e.id),n.delete(e.id)):n.set(e.id,i-1)})),e&&this.view._stage.remove(0,i.id),this._engineResourcesAddedToStage=!1}},e.prototype._getCollisionRadius=function(e){return this._getFocusedSize(this.radius,!0)*("touch"===e?this.touchMultiplier:1)},e.prototype._getFocusedSize=function(e,t){return e*(t?this.focusMultiplier:1)},e.prototype._getWorldToScreenObjectScale=function(){return this._worldSized?1:this.screenLocation.pixelSize},e.prototype._calculateModelTransformPosition=function(e){var t=this._getWorldToScreenObjectScale(),n=this._calculateObjectTransform(t,R);return h.vec3.set(e,n[12],n[13],n[14])},e.prototype._calculateModelTransformOffset=function(e){var t=this._calculateModelTransformPosition(e);return h.vec3.subtract(e,t,this.renderLocation)},e.prototype._calculateObjectTransform=function(e,t){return d.mat4.set(t,e,0,0,0,0,e,0,0,0,0,e,0,0,0,0,1),d.mat4.multiply(t,t,this._modelTransform),this._worldFrame&&d.mat4.multiply(t,t,this._worldFrame),t[12]+=this.renderLocation[0],t[13]+=this.renderLocation[1],t[14]+=this.renderLocation[2],t[15]=1,t},e}();t.Manipulator3D=A;var C=l.createScreenPointArray(),O=y.lineSegment.create(),M=y.ray.create(),D=u.mat3f64.create(),R=p.mat4f64.create(),T=p.mat4f64.create(),I=y.plane.create(),z=v.vec3f64.create(),L=v.vec3f64.create(),E=v.vec3f64.create(),j=v.vec3f64.create(),V=v.vec3f64.create(),N=v.vec3f64.create()}).apply(null,i))||(e.exports=r)},wrIU:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("LxLY"),n("jBNx"),n("Rdxj"),n("aWgr"),n("JjCO")],void 0===(r=(function(e,t,n,i,r,a,o){Object.defineProperty(t,"__esModule",{value:!0}),t.createDragHandler=function(e,t,i){var r=null;return e.events.on("drag",(function(e){if("start"===e.action&&(r=t(e)),!n.isNone(r)){var a=r(e);n.isSome(a)&&i(a),"end"===e.action&&(r=null)}}))},t.createCartesianPlaneDrag=function(e,t,n){var l=i.screenPointObjectToArray(e.start,i.castScreenPointArray(o.sv2d.get())),c=a.ray.fromScreen(t.state.camera,l,s),u=r.vec3f64.create(),d=r.vec3f64.create();return a.plane.intersectRay(n,c,u)?function(e){var r=i.screenPointObjectToArray(e.screenPoint,i.castScreenPointArray(o.sv2d.get())),l=a.ray.fromScreen(t.state.camera,r,s);return a.plane.intersectRay(n,l,d)?{action:e.action,start:u,end:d}:null}:null};var s=a.ray.create()}).apply(null,i))||(e.exports=r)},x82K:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("qKT0"),n("9opi"),n("BcWh"),n("eIBl"),n("LxLY"),n("8MXS"),n("Vx27"),n("BKZ1"),n("d0uo"),n("TCLX"),n("X7Ps")],void 0===(r=(function(e,t,n,i,r,a,o,s,l,c,u,d,p){Object.defineProperty(t,"__esModule",{value:!0});var f=function(e){function t(t){var n=e.call(this,t)||this;return n._handles=new a,n._reshapeOperation=null,n._internalGeometryUpdate=!1,n.type="reshape-3d",n._emitter.target=null,n}return i(t,e),t.prototype.destroy=function(){this._handles.removeAll(),this._reshapeOperation&&(this._reshapeOperation.destroy(),this._reshapeOperation=null),this._set("view",null),this._set("graphic",null)},t.prototype._updateGeometry=function(){this._reshapeOperation.inputGeometry=0===c.isSupportedGraphic(this.graphic)&&d.isReshapeGeometry(this.graphic.geometry)?this.graphic.geometry.clone():null},t.prototype._updateGraphic=function(){var e=this;if(this._handles.remove("onGraphicGeometryChange"),this._updateGeometry(),0===c.isSupportedGraphic(this.graphic)){var t=this.watch("graphic.geometry",(function(){!1===e._internalGeometryUpdate&&e._updateGeometry()}),!0);this._handles.add(t,"onGraphicGeometryChange")}},t.prototype.manipulatorSelectionChanged=function(){this._reshapeOperation&&this._reshapeOperation.manipulatorSelectionChanged()},t.prototype._onReshapeGeometryChanged=function(){o.isNone(this.graphic)||(this._internalGeometryUpdate=!0,this.graphic.geometry=this._reshapeOperation.outputGeometry.clone(),this._internalGeometryUpdate=!1)},t.prototype.initialize=function(){var e=this;this._reshapeOperation=new u.ReshapeOperation({view:this.view,graphic:this.graphic,manipulators:this.manipulators}),this._handles.add([this._reshapeOperation.on("reshape",(function(t){"reshape"===t.type&&e._onReshapeGeometryChanged(),e.emit("reshape",t)})),this._reshapeOperation.on("move",(function(t){"move"===t.type&&e._onReshapeGeometryChanged(),e.emit("move",t)})),this._reshapeOperation.on("vertex-add",(function(t){e._onReshapeGeometryChanged(),e.emit("vertex-add",t)})),this._reshapeOperation.on("vertex-remove",(function(t){e._onReshapeGeometryChanged(),e.emit("vertex-remove",t)})),this._reshapeOperation.on("immediate-click",(function(){return e.emit("immediate-click")})),s.init(this,"graphic",(function(){e._updateGraphic()}),!0)])},t.prototype.handleInputEvent=function(e){"key-down"!==e.type||"Delete"!==e.key&&"Backspace"!==e.key||this._reshapeOperation.removeSelectedVertices()},t.prototype.reset=function(){},n([l.property({constructOnly:!0,nonNullable:!0})],t.prototype,"view",void 0),n([l.property({constructOnly:!0})],t.prototype,"graphic",void 0),n([l.property({readOnly:!0})],t.prototype,"type",void 0),n([l.subclass("esri.views.3d.interactive.editingTools.graphicReshape3D.GraphicReshape3DTool")],t)}(l.declared(r.EventedMixin(p.InteractiveToolBase)));t.GraphicReshape3DTool=f}).apply(null,i))||(e.exports=r)},xDGw:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("2o+p"),n("7Aei")],void 0===(r=(function(e,t,n,i,r){var a,o,s,l,c,u;Object.defineProperty(t,"__esModule",{value:!0}),t.VerticalOffset=function(e,t){var d=e.vertex.code;t.verticalOffsetEnabled&&(e.vertex.uniforms.add("verticalOffset","vec4"),t.screenSizePerspectiveEnabled&&(e.include(i.ScreenSizePerspective),e.vertex.uniforms.add("screenSizePerspectiveAlignment","vec4")),d.add(r.glsl(a||(a=n(["\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n    "],["\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n    "])))),d.add(r.glsl(0===t.viewingMode?o||(o=n(["\n      vec3 worldNormal = normalize(worldPos + localOrigin);\n    "],["\n      vec3 worldNormal = normalize(worldPos + localOrigin);\n    "])):s||(s=n(["\n      vec3 worldNormal = vec3(0.0, 0.0, 1.0);\n    "],["\n      vec3 worldNormal = vec3(0.0, 0.0, 1.0);\n    "])))),d.add(r.glsl(t.screenSizePerspectiveEnabled?l||(l=n(["\n      float cosAngle = dot(worldNormal, normalize(worldPos - camPos));\n      float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\n    "],["\n      float cosAngle = dot(worldNormal, normalize(worldPos - camPos));\n      float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\n    "])):c||(c=n(["\n      float verticalOffsetScreenHeight = verticalOffset.x;\n    "],["\n      float verticalOffsetScreenHeight = verticalOffset.x;\n    "])))),d.add(r.glsl(u||(u=n(["\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n    "],["\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n    "])))))}}).apply(null,i))||(e.exports=r)},xsp2:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("W0kZ")],void 0===(r=(function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var i=new n.IdGen;t.generateHighlightId=function(){return i.gen("highlight")}}).apply(null,i))||(e.exports=r)},ybGv:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("7Aei")],void 0===(r=(function(e,t,n,i){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.Gamma=function(e){e.fragment.code.add(i.glsl(r||(r=n(["\n    const float GAMMA = 2.2;\n    const float INV_GAMMA = 0.4545454545; // 1 / GAMMA\n\n    // gamma correction\n    vec4 delinearizeGamma(vec4 color) {\n      return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);\n    }\n\n    vec3 linearizeGamma(vec3 color) {\n      return pow(color, vec3(GAMMA));\n    }\n    "],["\n    const float GAMMA = 2.2;\n    const float INV_GAMMA = 0.4545454545; // 1 / GAMMA\n\n    // gamma correction\n    vec4 delinearizeGamma(vec4 color) {\n      return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);\n    }\n\n    vec3 linearizeGamma(vec3 color) {\n      return pow(color, vec3(GAMMA));\n    }\n    "]))))}}).apply(null,i))||(e.exports=r)},ys4y:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("3RHn"),n("rjU6"),n("+nCE"),n("W0kZ"),n("CIy2"),n("CIy2")],void 0===(r=(function(e,t,n,i,r,a,o,s){return function(){function e(t,n,i){this.singleUse=!1,this._boundingInfo=null,this._componentAABBs=null,this._id=e.__idGen.gen(n),this._data=t,this._boundingInfo=i}return Object.defineProperty(e.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"data",{get:function(){return this._data},enumerable:!0,configurable:!0}),e.prototype.getIndices=function(e){return this.data.getIndices(e)},Object.defineProperty(e.prototype,"indexCount",{get:function(){return this.data.indexCount},enumerable:!0,configurable:!0}),e.prototype.getAttribute=function(e){return this.data.getAttribute(e)},Object.defineProperty(e.prototype,"componentCount",{get:function(){return i.componentCount(this.data.componentOffsets)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"componentOffsets",{get:function(){return this.data.componentOffsets},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"vertexCount",{get:function(){return this.data.indexCount},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"faceCount",{get:function(){return this.data.indexCount/3},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"boundingInfo",{get:function(){return null==this._boundingInfo&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo},enumerable:!0,configurable:!0}),e.prototype.computeAttachmentOrigin=function(e){return"triangle"===this.data.primitiveType?this.computeAttachmentOriginTriangles(e):this.computeAttachmentOriginPoints(e)},e.prototype.computeAttachmentOriginTriangles=function(e){var t=this.getIndices(s.VertexAttrConstants.POSITION),n=this.getAttribute(s.VertexAttrConstants.POSITION);return r.computeAttachmentOriginTriangles(n,t,e)},e.prototype.computeAttachmentOriginPoints=function(e){var t=this.getIndices(s.VertexAttrConstants.POSITION),n=this.getAttribute(s.VertexAttrConstants.POSITION);return r.computeAttachmentOriginPoints(n,t,e)},e.prototype.invalidateBoundingInfo=function(){this._boundingInfo=null,this._componentAABBs=null},e.prototype.getComponentAABB=function(e,t){null==this._componentAABBs&&(this._componentAABBs=this._computeComponentAABBs());for(var n=0;n<6;n++)t[n]=this._componentAABBs[6*e+n];return t},e.prototype._computeComponentAABBs=function(){for(var e=this.componentCount,t=new Float32Array(6*e),n=0;n<e;n++)this._calculateAABB(n,t,6*n);return t},e.prototype._calculateAABB=function(e,t,n){for(var i=this.data.getIndices(s.VertexAttrConstants.POSITION),r=this.data.getAttribute(s.VertexAttrConstants.POSITION),a=this.data.componentOffsets,o=a.length?a[e+1]:i.length,l=1/0,c=1/0,u=1/0,d=-1/0,p=-1/0,f=-1/0,h=r.offsetIdx,v=r.strideIdx,m=a.length?a[e]:0;m<o;m++){var g=h+v*i[m],y=r.data[g],b=r.data[g+1],x=r.data[g+2];l=Math.min(l,y),c=Math.min(c,b),u=Math.min(u,x),d=Math.max(d,y),p=Math.max(p,b),f=Math.max(f,x)}t[n]=l,t[n+1]=c,t[n+2]=u,t[n+3]=d,t[n+4]=p,t[n+5]=f},e.prototype._calculateBoundingInfo=function(){var e=this.data.getIndices(s.VertexAttrConstants.POSITION),t=this.data.getAttribute(s.VertexAttrConstants.POSITION),i="triangle"===this.data.primitiveType?3:1;if(0===e.length){e=new Uint32Array(i);for(var a=0;a<i;++a)e[a]=a}var l=e.length;o.assert(l%i==0,"Indexing error: "+l.toFixed(0)+" not divisible by "+i.toFixed(0));var c=r.generateDefaultIndexArray(l/i);return new n(c,i,e,t)},e.__idGen=new a.IdGen,e}()}).apply(null,i))||(e.exports=r)},zdOl:function(e,t,n){var i,r;i=[n.dj.c(e.i),t,n("XsoR"),n("mOGR"),n("7Aei")],void 0===(r=(function(e,t,n,i,r){function a(e,t){var a=e.fragment,p=t.hasMetalnessAndRoughnessTexture||t.hasEmissionTexture||t.hasOcclusionTexture;t.usePBR&&p&&e.include(i.VertexTextureCoordinates,t),t.usePBR&&(a.uniforms.add("roughnessFactor","float"),a.uniforms.add("metalnessFactor","float"),a.uniforms.add("emissionFactor","vec3"),a.uniforms.add("reflectanceFactor","float"),a.code.add(r.glsl(o||(o=n(["\n    float reflectance;\n    float roughness;\n    float metalness;\n    vec3 emission;\n    float occlusion;\n    "],["\n    float reflectance;\n    float roughness;\n    float metalness;\n    vec3 emission;\n    float occlusion;\n    "])))),t.hasMetalnessAndRoughnessTexture&&(a.uniforms.add("texMetallicRoughness","sampler2D"),t.supportsTextureAtlas&&a.uniforms.add("texMetallicRoughnessSize","vec2"),a.code.add(r.glsl(s||(s=n(["\n    void applyMetallnessAndRoughness(TextureLookupParameter params) {\n      vec3 metallicRoughness = textureLookup(texMetallicRoughness, params).rgb;\n\n      roughness *= metallicRoughness.g;\n      metalness *= metallicRoughness.b;\n    }\n    "],["\n    void applyMetallnessAndRoughness(TextureLookupParameter params) {\n      vec3 metallicRoughness = textureLookup(texMetallicRoughness, params).rgb;\n\n      roughness *= metallicRoughness.g;\n      metalness *= metallicRoughness.b;\n    }\n    "]))))),t.hasEmissionTexture&&(a.uniforms.add("texEmission","sampler2D"),t.supportsTextureAtlas&&a.uniforms.add("texEmissionSize","vec2"),a.code.add(r.glsl(l||(l=n(["\n    void applyEmission(TextureLookupParameter params) {\n      emission *= textureLookup(texEmission, params).rgb;\n    }\n    "],["\n    void applyEmission(TextureLookupParameter params) {\n      emission *= textureLookup(texEmission, params).rgb;\n    }\n    "])))))),t.usePBR&&t.hasOcclusionTexture?(a.uniforms.add("texOcclusion","sampler2D"),t.supportsTextureAtlas&&a.uniforms.add("texOcclusionSize","vec2"),a.code.add(r.glsl(c||(c=n(["\n    void applyOcclusion(TextureLookupParameter params) {\n      occlusion *= textureLookup(texOcclusion, params).r;\n    }\n\n    float getBakedOcclusion() {\n      return occlusion;\n    }\n    "],["\n    void applyOcclusion(TextureLookupParameter params) {\n      occlusion *= textureLookup(texOcclusion, params).r;\n    }\n\n    float getBakedOcclusion() {\n      return occlusion;\n    }\n    "]))))):a.code.add(r.glsl(u||(u=n(["\n    float getBakedOcclusion() { return 1.0; }\n    "],["\n    float getBakedOcclusion() { return 1.0; }\n    "])))),t.usePBR&&a.code.add(r.glsl(d||(d=n(["\n    void applyPBRFactors() {\n      reflectance = reflectanceFactor;\n      roughness = roughnessFactor;\n      metalness = metalnessFactor;\n      emission = emissionFactor;\n      occlusion = 1.0;\n      ","\n      ","\n      ","\n      ","\n    }\n  "],["\n    void applyPBRFactors() {\n      reflectance = reflectanceFactor;\n      roughness = roughnessFactor;\n      metalness = metalnessFactor;\n      emission = emissionFactor;\n      occlusion = 1.0;\n      ","\n      ","\n      ","\n      ","\n    }\n  "])),p?"vtc.uv = vuv0;":"",t.hasMetalnessAndRoughnessTexture?t.supportsTextureAtlas?"vtc.size = texMetallicRoughnessSize; applyMetallnessAndRoughness(vtc);":"applyMetallnessAndRoughness(vtc);":"",t.hasEmissionTexture?t.supportsTextureAtlas?"vtc.size = texEmissionSize; applyEmission(vtc);":"applyEmission(vtc);":"",t.hasOcclusionTexture?t.supportsTextureAtlas?"vtc.size = texOcclusionSize; applyOcclusion(vtc);":"applyOcclusion(vtc);":""))}var o,s,l,c,u,d;Object.defineProperty(t,"__esModule",{value:!0}),t.PhysicallyBasedRenderingParameters=a,function(e){e.bindUniforms=function(e,t){e.setUniform1f("metalnessFactor",t.metallicFactor),e.setUniform1f("roughnessFactor",t.roughnessFactor),e.setUniform3fv("emissionFactor",t.emissiveFactor),e.setUniform1f("reflectanceFactor",t.reflectanceFactor)}}(a=t.PhysicallyBasedRenderingParameters||(t.PhysicallyBasedRenderingParameters={}))}).apply(null,i))||(e.exports=r)}}]);