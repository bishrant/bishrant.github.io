(function(){var e={"esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl":"+5nk","esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl":"1pwa","esri/views/3d/webgl-engine/core/shaderLibrary/util/DecodeNormal.glsl":"3iei","esri/views/3d/glTF/DefaultLoadingContext":"5PWn","esri/views/3d/glTF/internal/pathUtils":"7eim","esri/views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl":"8TPw","esri/views/3d/webgl-engine/shaders/DefaultMaterial.glsl":"9dVJ","esri/views/3d/support/buffer/utils/vec2":"9o4r","esri/views/3d/webgl-engine/shaders/DefaultMaterialTechnique":"CsnI","esri/views/3d/webgl-engine/shaders/RealisticTreeTechnique":"FN5H","esri/views/3d/support/buffer/utils/vec4":"Gz8v","esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl":"HkM8","esri/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl":"JvNb","esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateMainLighting.glsl":"KT2k","esri/views/3d/glTF/internal/Resource":"OIWm","esri/views/3d/glTF/internal/fillDefaults":"PT+s","esri/views/3d/support/buffer/math":"Q39H","esri/views/3d/support/buffer/math/vec4":"QTYv","esri/views/3d/layers/graphics/wosrLoader":"Rqxa","esri/views/3d/webgl-engine/core/shaderLibrary/default/RealisticTree.glsl":"T07b","esri/views/3d/webgl-engine/materials/DefaultMaterial":"TP2F","esri/views/3d/support/buffer/math/common":"TUJR","esri/views/3d/support/buffer/utils":"TqPN","esri/views/3d/glTF/LoaderResult":"TqrP","esri/views/3d/support/buffer/utils/vec3":"W5Zm","esri/views/3d/webgl-engine/collections/Component/Material/shader/DecodeSymbolColor.glsl":"WMxK","esri/views/3d/glTF/internal/indexUtils":"ZuXA","esri/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl":"aluc","esri/views/3d/glTF/DefaultErrorContext":"cE5x","esri/views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl":"cGZG","esri/views/3d/layers/graphics/objectResourceUtils":"cMCQ","esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl":"cqYc","esri/views/3d/support/buffer/utils/scalar":"cza4","esri/views/3d/support/buffer/utils/mat4":"dB/a","esri/views/3d/webgl-engine/core/shaderLibrary/util/HeaderComment.glsl":"eFLy","esri/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl":"eYHx","esri/views/3d/support/buffer/utils/mat3":"f3AO","esri/views/3d/support/buffer/math/vec3":"fV0t","esri/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl":"gS4P","esri/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl":"hIiW","esri/views/3d/glTF/loader":"jj3b","esri/views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl":"lF8C","esri/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl":"m7Ki","esri/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl":"mOGR","esri/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl":"nJqw","esri/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl":"nobt","esri/views/3d/webgl-engine/core/shaderLibrary/util/DoublePrecision.glsl":"r0i9","esri/views/3d/webgl-engine/lib/WebGLDriverTest":"rxbe","esri/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl":"uEh2","esri/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl":"uci5","esri/core/Version":"w00x","esri/views/3d/glTF/internal/BinaryStreamReader":"wR99","esri/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl":"zdOl"},t=this||window,n=t.webpackJsonp=t.webpackJsonp||[];n.registerAbsMids?n.registerAbsMids(e):(n.absMidsWaiting=n.absMidsWaiting||[]).push(e)})(),(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{"+5nk":function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("HkM8"),n("eYHx"),n("KT2k"),n("piY7"),n("quQL"),n("cj3m"),n("7Aei")],void 0===(o=(function(e,t,n,r,o,a,i,s,l,c){"use strict";var d,u,m,v,p,f,h,g,b,x,y,_,w;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateSceneLighting=void 0,t.EvaluateSceneLighting=function(e,t){var T=e.fragment;e.include(a.EvaluateMainLighting),e.include(o.EvaluateAmbientOcclusion,t),0!==t.pbrMode&&e.include(i.PhysicallyBasedRendering,t),e.include(r.EvaluateAmbientLighting,t),t.receiveShadows&&e.include(l.ReadShadowMap,t),T.uniforms.add("lightingGlobalFactor","float"),T.uniforms.add("ambientBoostFactor","float"),e.include(s.PiUtils),T.code.add(c.glsl(d||(d=n.__makeTemplateObject(["\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ","\n  "],["\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ","\n  "])),0===t.pbrMode?"":"const vec3 GROUND_REFLECTANCE = vec3(0.2);")),t.useOldSceneLightInterface?T.code.add(c.glsl(u||(u=n.__makeTemplateObject(["\n    vec3 evaluateSceneLightingExt(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\n      // evaluate the main light\n      #if defined(TREE_RENDERING)\n        // Special case for tree rendering:\n        // We shift the Lambert lobe to the back, allowing it to reach part of the hemisphere\n        // facing away from the light. The idea is to get an effect where light is transmitted\n        // through the tree.\n        float minDot = -0.5;\n        float dotRange = 1.0 - minDot;\n        float dotNormalization = 0.66; // guessed & hand tweaked value, for an exact value we could precompute an integral over the sphere\n\n        float dotVal = dotNormalization * (clamp(-dot(normal, lightingMainDirection), 1.0 - dotRange, 1.0) - minDot) * (1.0 / dotRange);\n      #else\n        float dotVal = clamp(-dot(normal, lightingMainDirection), 0.0, 1.0);\n      #endif\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      vec3 mainLight = (1.0 - shadow) * lightingMainIntensity * dotVal;\n      vec3 ambientLight = calculateAmbientIrradiance(normal, ssao);\n\n      // inverse gamma correction on the albedo color\n      vec3 albedoGammaC = pow(albedo, vec3(GAMMA_SRGB));\n\n      // physically correct BRDF normalizes by PI\n      vec3 totalLight = mainLight + ambientLight + additionalLight;\n      totalLight = min(totalLight, vec3(PI));\n      vec3 outColor = vec3((albedoGammaC / PI) * (totalLight));\n\n      // apply gamma correction to the computed color\n      outColor = pow(outColor, vec3(INV_GAMMA_SRGB));\n\n      return outColor;\n    }\n  "],["\n    vec3 evaluateSceneLightingExt(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\n      // evaluate the main light\n      #if defined(TREE_RENDERING)\n        // Special case for tree rendering:\n        // We shift the Lambert lobe to the back, allowing it to reach part of the hemisphere\n        // facing away from the light. The idea is to get an effect where light is transmitted\n        // through the tree.\n        float minDot = -0.5;\n        float dotRange = 1.0 - minDot;\n        float dotNormalization = 0.66; // guessed & hand tweaked value, for an exact value we could precompute an integral over the sphere\n\n        float dotVal = dotNormalization * (clamp(-dot(normal, lightingMainDirection), 1.0 - dotRange, 1.0) - minDot) * (1.0 / dotRange);\n      #else\n        float dotVal = clamp(-dot(normal, lightingMainDirection), 0.0, 1.0);\n      #endif\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      vec3 mainLight = (1.0 - shadow) * lightingMainIntensity * dotVal;\n      vec3 ambientLight = calculateAmbientIrradiance(normal, ssao);\n\n      // inverse gamma correction on the albedo color\n      vec3 albedoGammaC = pow(albedo, vec3(GAMMA_SRGB));\n\n      // physically correct BRDF normalizes by PI\n      vec3 totalLight = mainLight + ambientLight + additionalLight;\n      totalLight = min(totalLight, vec3(PI));\n      vec3 outColor = vec3((albedoGammaC / PI) * (totalLight));\n\n      // apply gamma correction to the computed color\n      outColor = pow(outColor, vec3(INV_GAMMA_SRGB));\n\n      return outColor;\n    }\n  "])))):(T.code.add(c.glsl(1===t.viewingMode?m||(m=n.__makeTemplateObject(["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        vec3 shadingNormalWorld = normalize(vPosWorld);\n        float vndl = -dot(shadingNormalWorld, lightingMainDirection);\n\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "],["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        vec3 shadingNormalWorld = normalize(vPosWorld);\n        float vndl = -dot(shadingNormalWorld, lightingMainDirection);\n\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "])):v||(v=n.__makeTemplateObject(["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        float vndl = -dot(vec3(0.0, 0.0, 1.0), lightingMainDirection);\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "],["\n      float _oldHeuristicLighting(vec3 vPosWorld) {\n        float vndl = -dot(vec3(0.0, 0.0, 1.0), lightingMainDirection);\n        return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n      }\n    "])))),T.code.add(c.glsl(p||(p=n.__makeTemplateObject(["\n      vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\n        float additionalAmbientScale = _oldHeuristicLighting(vPosWorld);\n        return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n      }\n    "],["\n      vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\n        float additionalAmbientScale = _oldHeuristicLighting(vPosWorld);\n        return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n      }\n    "])))),0===t.pbrMode||4===t.pbrMode?T.code.add(c.glsl(f||(f=n.__makeTemplateObject(["\n      vec3 evaluateSceneLighting(vec3 normalWorld, vec3 baseColor, float mainLightShadow, float ambientOcclusion, vec3 additionalLight)\n      {\n        vec3 mainLighting = evaluateMainLighting(normalWorld, mainLightShadow);\n        vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ambientOcclusion);\n        // inverse gamma correction on the base color\n        vec3 baseColorLinear = pow(baseColor, vec3(GAMMA_SRGB));\n\n        // physically correct BRDF normalizes by PI\n        vec3 totalLight = mainLighting + ambientLighting + additionalLight;\n        totalLight = min(totalLight, vec3(PI));\n        vec3 outColor = vec3((baseColorLinear / PI) * totalLight);\n\n        // apply gamma correction to the computed color\n        outColor = pow(outColor, vec3(INV_GAMMA_SRGB));\n\n        return outColor;\n      }\n      "],["\n      vec3 evaluateSceneLighting(vec3 normalWorld, vec3 baseColor, float mainLightShadow, float ambientOcclusion, vec3 additionalLight)\n      {\n        vec3 mainLighting = evaluateMainLighting(normalWorld, mainLightShadow);\n        vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ambientOcclusion);\n        // inverse gamma correction on the base color\n        vec3 baseColorLinear = pow(baseColor, vec3(GAMMA_SRGB));\n\n        // physically correct BRDF normalizes by PI\n        vec3 totalLight = mainLighting + ambientLighting + additionalLight;\n        totalLight = min(totalLight, vec3(PI));\n        vec3 outColor = vec3((baseColorLinear / PI) * totalLight);\n\n        // apply gamma correction to the computed color\n        outColor = pow(outColor, vec3(INV_GAMMA_SRGB));\n\n        return outColor;\n      }\n      "])))):1!==t.pbrMode&&2!==t.pbrMode||(T.code.add(c.glsl(h||(h=n.__makeTemplateObject(["\n      const float fillLightIntensity = 0.25;\n      const float horizonLightDiffusion = 0.4;\n      const float additionalAmbientIrradianceFactor = 0.02;\n\n      vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n      {\n        // Calculate half vector between view and light direction\n        vec3 viewDirection = -viewDir;\n        vec3 mainLightDirection = -lightingMainDirection;\n        vec3 h = normalize(viewDirection + mainLightDirection);\n\n        PBRShadingInfo inputs;\n        inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\n        inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\n        inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\n        inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\n        inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\n        vec3 reflectedView = normalize(reflect(viewDirection, normal));\n        inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\n\n        inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\n        inputs.ssao = ssao;\n\n        inputs.metalness = mrr[0];\n        inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);\n      "],["\n      const float fillLightIntensity = 0.25;\n      const float horizonLightDiffusion = 0.4;\n      const float additionalAmbientIrradianceFactor = 0.02;\n\n      vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n      {\n        // Calculate half vector between view and light direction\n        vec3 viewDirection = -viewDir;\n        vec3 mainLightDirection = -lightingMainDirection;\n        vec3 h = normalize(viewDirection + mainLightDirection);\n\n        PBRShadingInfo inputs;\n        inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\n        inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\n        inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\n        inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\n        inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\n        vec3 reflectedView = normalize(reflect(viewDirection, normal));\n        inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\n\n        inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\n        inputs.ssao = ssao;\n\n        inputs.metalness = mrr[0];\n        inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);\n      "])))),T.code.add(c.glsl(g||(g=n.__makeTemplateObject(["\n        inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\n        inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0)); // more accurate then using  f90 = 1.0\n        inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);\n      "],["\n        inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\n        inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0)); // more accurate then using  f90 = 1.0\n        inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);\n      "])))),T.code.add(c.glsl(b||(b=n.__makeTemplateObject(["\n        vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\n        ambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\n\n        inputs.NdotAmbDir = abs(dot(normal, ambientDir));\n\n        // Calculate the irradiance components: sun, fill lights and the sky.\n        vec3 mainLightIrradianceComponent  = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\n        vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\n        // calculateAmbientIrradiance for localView and additionalLight for gloabalView\n        vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\n\n        // Assemble the overall irradiance of the sky that illuminates the surface\n        inputs.skyIrradianceToSurface    = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n        // Assemble the overall irradiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky irradiance by the groundReflectance\n        inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n      "],["\n        vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\n        ambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\n\n        inputs.NdotAmbDir = abs(dot(normal, ambientDir));\n\n        // Calculate the irradiance components: sun, fill lights and the sky.\n        vec3 mainLightIrradianceComponent  = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\n        vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\n        // calculateAmbientIrradiance for localView and additionalLight for gloabalView\n        vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\n\n        // Assemble the overall irradiance of the sky that illuminates the surface\n        inputs.skyIrradianceToSurface    = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n        // Assemble the overall irradiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky irradiance by the groundReflectance\n        inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\n      "])))),T.code.add(c.glsl(x||(x=n.__makeTemplateObject(["\n        vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\n        vec3 horizonRingH = normalize(viewDirection + horizonRingDir);\n        inputs.NdotH_Horizon = dot(normal, horizonRingH);\n\n        vec3 mainLightRadianceComponent  = normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\n        vec3 horizonLightRadianceComponent = normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\n        vec3 ambientLightRadianceComponent = calculateAmbientRadiance(ssao) + additionalLight; // calculateAmbientRadiance for localView and additionalLight for gloabalView\n\n        // Assemble the overall radiance of the sky that illuminates the surface\n        inputs.skyRadianceToSurface    =  ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\n        // Assemble the overall radiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky radince by the groundReflectance\n        inputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\n\n        // Calculate average ambient radiance - this is used int the gamut mapping part to deduce the black level that is soft compressed\n        inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);\n        "],["\n        vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\n        vec3 horizonRingH = normalize(viewDirection + horizonRingDir);\n        inputs.NdotH_Horizon = dot(normal, horizonRingH);\n\n        vec3 mainLightRadianceComponent  = normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\n        vec3 horizonLightRadianceComponent = normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\n        vec3 ambientLightRadianceComponent = calculateAmbientRadiance(ssao) + additionalLight; // calculateAmbientRadiance for localView and additionalLight for gloabalView\n\n        // Assemble the overall radiance of the sky that illuminates the surface\n        inputs.skyRadianceToSurface    =  ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\n        // Assemble the overall radiance of the ground that illuminates the surface. for this we use the simple model that changes only the sky radince by the groundReflectance\n        inputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\n\n        // Calculate average ambient radiance - this is used int the gamut mapping part to deduce the black level that is soft compressed\n        inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);\n        "])))),T.code.add(c.glsl(w||(w=n.__makeTemplateObject(["\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ","\n        return outColor;\n      }\n    "],["\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ","\n        return outColor;\n      }\n    "])),c.glsl(2===t.pbrMode?y||(y=n.__makeTemplateObject(["vec3 outColor = pow(outColorLinear - 0.005 * inputs.averageAmbientRadiance, vec3(INV_GAMMA_SRGB));"],["vec3 outColor = pow(outColorLinear - 0.005 * inputs.averageAmbientRadiance, vec3(INV_GAMMA_SRGB));"])):_||(_=n.__makeTemplateObject(["vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));"],["vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));"])))))))}}).apply(null,r))||(e.exports=o)},"1pwa":function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("51bw"),n("1m5D"),n("Rdxj"),n("uci5"),n("r0i9"),n("7Aei")],void 0===(o=(function(e,t,n,r,o,a,i,s,l){"use strict";function c(e,t){e.include(i.PositionAttribute),e.vertex.include(s.DoublePrecision,t),e.varyings.add("vPositionWorldCameraRelative","vec3"),e.varyings.add("vPosition_view","vec3"),e.vertex.uniforms.add("uTransform_WorldFromModel_RS","mat3"),e.vertex.uniforms.add("uTransform_WorldFromModel_TH","vec3"),e.vertex.uniforms.add("uTransform_WorldFromModel_TL","vec3"),e.vertex.uniforms.add("uTransform_WorldFromView_TH","vec3"),e.vertex.uniforms.add("uTransform_WorldFromView_TL","vec3"),e.vertex.uniforms.add("uTransform_ViewFromCameraRelative_RS","mat3"),e.vertex.uniforms.add("uTransform_ProjFromView","mat4"),e.vertex.code.add(l.glsl(d||(d=n.__makeTemplateObject(["\n    // compute position in world space orientation, but relative to the camera position\n    vec3 positionWorldCameraRelative() {\n      vec3 rotatedModelPosition = uTransform_WorldFromModel_RS * positionModel();\n\n      vec3 transform_CameraRelativeFromModel = dpAdd(\n        uTransform_WorldFromModel_TL,\n        uTransform_WorldFromModel_TH,\n        -uTransform_WorldFromView_TL,\n        -uTransform_WorldFromView_TH\n      );\n\n      return transform_CameraRelativeFromModel + rotatedModelPosition;\n    }\n\n    // position in view space, that is relative to the camera position and orientation\n    vec3 position_view() {\n      return uTransform_ViewFromCameraRelative_RS * positionWorldCameraRelative();\n    }\n\n    // compute gl_Position and forward related varyings to fragment shader\n    void forwardPosition() {\n      vPositionWorldCameraRelative = positionWorldCameraRelative();\n      vPosition_view = position_view();\n      gl_Position = uTransform_ProjFromView * vec4(vPosition_view, 1.0);\n    }\n\n    vec3 positionWorld() {\n      return uTransform_WorldFromView_TL + vPositionWorldCameraRelative;\n    }\n  "],["\n    // compute position in world space orientation, but relative to the camera position\n    vec3 positionWorldCameraRelative() {\n      vec3 rotatedModelPosition = uTransform_WorldFromModel_RS * positionModel();\n\n      vec3 transform_CameraRelativeFromModel = dpAdd(\n        uTransform_WorldFromModel_TL,\n        uTransform_WorldFromModel_TH,\n        -uTransform_WorldFromView_TL,\n        -uTransform_WorldFromView_TH\n      );\n\n      return transform_CameraRelativeFromModel + rotatedModelPosition;\n    }\n\n    // position in view space, that is relative to the camera position and orientation\n    vec3 position_view() {\n      return uTransform_ViewFromCameraRelative_RS * positionWorldCameraRelative();\n    }\n\n    // compute gl_Position and forward related varyings to fragment shader\n    void forwardPosition() {\n      vPositionWorldCameraRelative = positionWorldCameraRelative();\n      vPosition_view = position_view();\n      gl_Position = uTransform_ProjFromView * vec4(vPosition_view, 1.0);\n    }\n\n    vec3 positionWorld() {\n      return uTransform_WorldFromView_TL + vPositionWorldCameraRelative;\n    }\n  "])))),e.fragment.uniforms.add("uTransform_WorldFromView_TL","vec3"),e.fragment.code.add(l.glsl(u||(u=n.__makeTemplateObject(["\n    vec3 positionWorld() {\n      return uTransform_WorldFromView_TL + vPositionWorldCameraRelative;\n    }\n  "],["\n    vec3 positionWorld() {\n      return uTransform_WorldFromView_TL + vPositionWorldCameraRelative;\n    }\n  "]))))}var d,u;Object.defineProperty(t,"__esModule",{value:!0}),t.VertexPosition=void 0,t.VertexPosition=c,function(e){e.ModelTransform=function(){this.worldFromModel_RS=r.mat3f64.create(),this.worldFromModel_TH=a.vec3f64.create(),this.worldFromModel_TL=a.vec3f64.create()},e.ViewProjectionTransform=function(){this.worldFromView_TH=a.vec3f64.create(),this.worldFromView_TL=a.vec3f64.create(),this.viewFromCameraRelative_RS=r.mat3f64.create(),this.projFromView=o.mat4f64.create()},e.bindModelTransform=function(e,t){e.setUniformMatrix3fv("uTransform_WorldFromModel_RS",t.worldFromModel_RS),e.setUniform3fv("uTransform_WorldFromModel_TH",t.worldFromModel_TH),e.setUniform3fv("uTransform_WorldFromModel_TL",t.worldFromModel_TL)},e.bindViewProjTransform=function(e,t){e.setUniform3fv("uTransform_WorldFromView_TH",t.worldFromView_TH),e.setUniform3fv("uTransform_WorldFromView_TL",t.worldFromView_TL),e.setUniformMatrix4fv("uTransform_ProjFromView",t.projFromView),e.setUniformMatrix3fv("uTransform_ViewFromCameraRelative_RS",t.viewFromCameraRelative_RS)}}(c=t.VertexPosition||(t.VertexPosition={}))}).apply(null,r))||(e.exports=o)},"3iei":function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o;Object.defineProperty(t,"__esModule",{value:!0}),t.DecodeNormal=void 0,t.DecodeNormal=function(e){var t=r.glsl(o||(o=n.__makeTemplateObject(["\n    vec3 decodeNormal(vec2 f) {\n      float z = 1.0 - abs(f.x) - abs(f.y);\n      return vec3(f + sign(f) * min(z, 0.0), z);\n    }\n  "],["\n    vec3 decodeNormal(vec2 f) {\n      float z = 1.0 - abs(f.x) - abs(f.y);\n      return vec3(f + sign(f) * min(z, 0.0), z);\n    }\n  "])));e.fragment.code.add(t),e.vertex.code.add(t)}}).apply(null,r))||(e.exports=o)},"5PWn":function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("zp6E"),n("WYKK"),n("ma1f"),n("LxLY"),n("qMld"),n("jfWY")],void 0===(o=(function(e,t,n,r,o,a,i,s,l){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultLoadingContext=void 0;var c=function(){function e(e){this.streamDataRequester=e}return e.prototype.loadJSON=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){return n.__generator(this,(function(n){return[2,this.load("json",e,t)]}))}))},e.prototype.loadBinary=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){return n.__generator(this,(function(n){return l.isDataProtocol(e)?(s.throwIfAborted(t),[2,l.dataToArrayBuffer(e)]):[2,this.load("binary",e,t)]}))}))},e.prototype.loadImage=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){return n.__generator(this,(function(n){return[2,this.load("image",e,t)]}))}))},e.prototype.load=function(e,t,l){return n.__awaiter(this,void 0,void 0,(function(){var c;return n.__generator(this,(function(n){switch(n.label){case 0:return i.isNone(this.streamDataRequester)?[4,r(t,{responseType:d[e]})]:[3,2];case 1:return[2,n.sent().data];case 2:return[4,o.result(this.streamDataRequester.request(t,e,l))];case 3:if(!0===(c=n.sent()).ok)return[2,c.value];throw s.throwIfAbortError(c.error),new a("","Request for resource failed: "+c.error)}}))}))},e}();t.DefaultLoadingContext=c;var d={image:"image",binary:"array-buffer",json:"json"}}).apply(null,r))||(e.exports=o)},"7eim":function(e,t,n){var r,o;r=[n.dj.c(e.i),t],void 0===(o=(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.splitURI=void 0,t.splitURI=function(e){var t,n;return e.replace(/^(.*\/)?([^/]*)$/,(function(e,r,o){return t=r||"",n=o||"",""})),{dirPart:t,filePart:n}}}).apply(null,r))||(e.exports=o)},"8TPw":function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("3iei"),n("7Aei")],void 0===(o=(function(e,t,n,r,o){"use strict";var a,i,s;Object.defineProperty(t,"__esModule",{value:!0}),t.NormalAttribute=void 0,t.NormalAttribute=function(e,t){0===t.normalType&&(e.attributes.add("normal","vec3"),e.vertex.code.add(o.glsl(a||(a=n.__makeTemplateObject(["\n      vec3 normalModel() {\n        return normal;\n      }\n    "],["\n      vec3 normalModel() {\n        return normal;\n      }\n    "]))))),1===t.normalType&&(e.include(r.DecodeNormal),e.attributes.add("normalCompressed","vec2"),e.vertex.code.add(o.glsl(i||(i=n.__makeTemplateObject(["\n      vec3 normalModel() {\n        return decodeNormal(normalCompressed);\n      }\n    "],["\n      vec3 normalModel() {\n        return decodeNormal(normalCompressed);\n      }\n    "]))))),3===t.normalType&&(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(o.glsl(s||(s=n.__makeTemplateObject(["\n      vec3 screenDerivativeNormal(vec3 positionView) {\n        return normalize(cross(dFdx(positionView), dFdy(positionView)));\n      }\n    "],["\n      vec3 screenDerivativeNormal(vec3 positionView) {\n        return normalize(cross(dFdx(positionView), dFdy(positionView)));\n      }\n    "])))))}}).apply(null,r))||(e.exports=o)},"9dVJ":function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("cmSR"),n("nobt"),n("fese"),n("3kdR"),n("m7Ki"),n("8TPw"),n("uci5"),n("hIiW"),n("lF8C"),n("6t3m"),n("cqYc"),n("xDGw"),n("gS4P"),n("aluc"),n("eYHx"),n("+5nk"),n("cGZG"),n("piY7"),n("zdOl"),n("cj3m"),n("3PFg"),n("IwVr"),n("eFLy"),n("JvNb"),n("7Aei"),n("aExC")],void 0===(o=(function(e,t,n,r,o,a,i,s,l,c,d,u,m,v,p,f,h,g,b,x,y,_,w,T,C,O,M,A,S){"use strict";var P,L,R,B,D,I,F,V,j,E,N,z,k,G;Object.defineProperty(t,"__esModule",{value:!0}),t.build=void 0,t.build=function(e){var t=new S.ShaderBuilder,U=t.vertex.code,W=t.fragment.code;return t.include(O.HeaderComment,{name:"Default Material Shader",output:e.output}),t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3"),t.include(c.PositionAttribute),t.varyings.add("vpos","vec3"),t.include(T.VisualVariables,e),t.include(s.InstancedDoublePrecision,e),t.include(p.VerticalOffset,e),0===e.output&&(t.include(l.NormalAttribute,e),t.include(i.Transform,{linearDepth:!1}),0===e.normalType&&e.offsetBackfaces&&t.include(o.Offset),t.include(h.ComputeNormalTexture,e),t.include(v.VertexNormal,e),e.instancedColor&&t.attributes.add("instanceColor","vec4"),t.varyings.add("localvpos","vec3"),t.include(u.TextureCoordinateAttribute,e),t.include(r.ForwardLinearDepth,e),t.include(d.SymbolColor,e),t.include(m.VertexColor,e),t.vertex.uniforms.add("externalColor","vec4"),t.varyings.add("vcolorExt","vec4"),U.add(A.glsl(L||(L=n.__makeTemplateObject(["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n        vcolorExt *= getSymbolColor();\n        forwardColorMixMode();\n\n        if (vcolorExt.a < ",") {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n          vpos = subtractOrigin(vpos);\n          ","\n          vpos = addVerticalOffset(vpos, localOrigin);\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "],["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n        vcolorExt *= getSymbolColor();\n        forwardColorMixMode();\n\n        if (vcolorExt.a < ",") {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n          vpos = subtractOrigin(vpos);\n          ","\n          vpos = addVerticalOffset(vpos, localOrigin);\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "])),e.instancedColor?"vcolorExt *= instanceColor;":"",A.glsl.float(C.symbolAlphaCutoff),0===e.normalType?A.glsl(P||(P=n.__makeTemplateObject(["\n          vNormalWorld = dpNormal(vvLocalNormal(normalModel()));"],["\n          vNormalWorld = dpNormal(vvLocalNormal(normalModel()));"]))):"",e.vertexTangets?"vTangent = dpTransformVertexTangent(tangent);":"",0===e.normalType&&e.offsetBackfaces?"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);":"")),t.include(a.Slice,e),t.include(b.EvaluateSceneLighting,e),t.include(g.EvaluateAmbientOcclusion,e),t.include(C.DiscardOrAdjustAlpha,e),e.receiveShadows&&t.include(w.ReadShadowMap,e),t.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("opacity","float").add("layerOpacity","float"),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),t.include(_.PhysicallyBasedRenderingParameters,e),t.include(y.PhysicallyBasedRendering,e),t.fragment.include(M.MixExternalColor),t.include(x.Normals,e),W.add(A.glsl(G||(G=n.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        ","\n        ","\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ","\n        vec3 matColor = max(ambient, diffuse);\n        ","\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        ","\n        ","\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ","\n        vec3 matColor = max(ambient, diffuse);\n        ","\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "])),e.hasColorTexture?A.glsl(R||(R=n.__makeTemplateObject(["\n        vec4 texColor = texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"],["\n        vec4 texColor = texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"])),e.textureAlphaPremultiplied?"texColor.rgb /= texColor.a;":""):A.glsl(B||(B=n.__makeTemplateObject(["vec4 texColor = vec4(1.0);"],["vec4 texColor = vec4(1.0);"]))),A.glsl(3===e.normalType?D||(D=n.__makeTemplateObject(["\n        vec3 normal = screenDerivativeNormal(localvpos);"],["\n        vec3 normal = screenDerivativeNormal(localvpos);"])):I||(I=n.__makeTemplateObject(["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);"],["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);"]))),1===e.pbrMode?"applyPBRFactors();":"",e.receiveShadows?"float shadow = readShadowMap(vpos, linearDepth);":1===e.viewingMode?"float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);":"float shadow = 0.0;",A.glsl(e.attributeColor?F||(F=n.__makeTemplateObject(["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"],["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"])):V||(V=n.__makeTemplateObject(["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n        "],["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n        "]))),e.hasNormalTexture?A.glsl(j||(j=n.__makeTemplateObject(["\n              mat3 tangentSpace = ","\n              vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);"],["\n              mat3 tangentSpace = ","\n              vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);"])),e.vertexTangets?"computeTangentSpace(normal);":"computeTangentSpace(normal, vpos, vuv0);"):"vec3 shadedNormal = normal;",A.glsl(1===e.pbrMode||2===e.pbrMode?1===e.viewingMode?E||(E=n.__makeTemplateObject(["vec3 normalGround = normalize(vpos + localOrigin);"],["vec3 normalGround = normalize(vpos + localOrigin);"])):N||(N=n.__makeTemplateObject(["vec3 normalGround = vec3(0.0, 0.0, 1.0);"],["vec3 normalGround = vec3(0.0, 0.0, 1.0);"])):z||(z=n.__makeTemplateObject([""],[""]))),1===e.pbrMode||2===e.pbrMode?A.glsl(k||(k=n.__makeTemplateObject(["\n            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);"],["\n            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);"]))):"vec3 shadedColor = evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);"))),t.include(f.DefaultMaterialAuxiliaryPasses,e),t}}).apply(null,r))||(e.exports=o)},"9o4r":function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("GntT")],void 0===(o=(function(e,t,n){"use strict";function r(e,t,n){for(var r=e.typedBuffer,o=e.typedBufferStride,a=t.typedBuffer,i=t.typedBufferStride,s=n?n.count:t.count,l=(n&&n.dstIndex?n.dstIndex:0)*o,c=(n&&n.srcIndex?n.srcIndex:0)*i,d=0;d<s;++d)r[l]=a[c],r[l+1]=a[c+1],l+=o,c+=i}Object.defineProperty(t,"__esModule",{value:!0}),t.normalizeIntegerBuffer=t.copy=void 0,t.copy=r,t.normalizeIntegerBuffer=function(e,t,o){var a=e.typedBuffer,i=e.typedBufferStride,s=t.typedBuffer,l=t.typedBufferStride,c=o?o.count:t.count,d=(o&&o.dstIndex?o.dstIndex:0)*i,u=(o&&o.srcIndex?o.srcIndex:0)*l;if(n.isInteger(t.elementType)){var m=n.maximumValue(t.elementType);if(n.isSigned(t.elementType))for(var v=0;v<c;++v)a[d]=Math.max(s[u]/m,-1),a[d+1]=Math.max(s[u+1]/m,-1),d+=i,u+=l;else for(v=0;v<c;++v)a[d]=s[u]/m,a[d+1]=s[u+1]/m,d+=i,u+=l}else r(e,t,o);return e}}).apply(null,r))||(e.exports=o)},CsnI:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("Rdxj"),n("fese"),n("m7Ki"),n("xDGw"),n("PaEL"),n("zdOl"),n("cj3m"),n("3PFg"),n("r0i9"),n("2NOe"),n("W/V4"),n("FQ4r"),n("lBa0"),n("ff/U"),n("s6rJ"),n("9dVJ"),n("G0ER"),n("2Kdy")],void 0===(o=(function(e,t,r,o,a,i,s,l,c,d,u,m,v,p,f,h,g,b,x,y){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultMaterialTechniqueConfiguration=t.DefaultMaterialTechnique=void 0;var _=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return r.__extends(t,e),t.prototype.initializeProgram=function(e){var n=t.shader.get(),r=this.configuration,o=n.build({output:r.output,viewingMode:e.viewingMode,receiveShadows:r.receiveShadows,slicePlaneEnabled:r.slicePlaneEnabled,sliceHighlightDisabled:r.sliceHighlightDisabled,sliceEnabledForVertexPrograms:!1,symbolColor:r.symbolColors,vvSize:r.vvSize,vvColor:r.vvColor,vvInstancingEnabled:!0,instanced:r.instanced,instancedColor:r.instancedColor,instancedDoublePrecision:r.instancedDoublePrecision,useOldSceneLightInterface:!1,pbrMode:r.usePBR?r.isSchematic?2:1:0,hasMetalnessAndRoughnessTexture:r.hasMetalnessAndRoughnessTexture,hasEmissionTexture:r.hasEmissionTexture,hasOcclusionTexture:r.hasOcclusionTexture,hasNormalTexture:r.hasNormalTexture,hasColorTexture:r.hasColorTexture,receiveAmbientOcclusion:r.receiveAmbientOcclusion,useCustomDTRExponentForWater:!1,normalType:r.normalsTypeDerivate?3:0,doubleSidedMode:r.doubleSidedMode,vertexTangets:r.vertexTangents,attributeTextureCoordinates:r.hasMetalnessAndRoughnessTexture||r.hasEmissionTexture||r.hasOcclusionTexture||r.hasNormalTexture||r.hasColorTexture?1:0,textureAlphaPremultiplied:r.textureAlphaPremultiplied,attributeColor:r.vertexColors,screenSizePerspectiveEnabled:r.screenSizePerspective,verticalOffsetEnabled:r.verticalOffset,offsetBackfaces:r.offsetBackfaces,doublePrecisionRequiresObfuscation:m.doublePrecisionRequiresObfuscation(e.rctx),alphaDiscardMode:r.alphaDiscardMode,supportsTextureAtlas:!1});return new y(e.rctx,o.generateSource("vertex"),o.generateSource("fragment"),g.Default3D)},t.prototype.bindPass=function(e,t,n){v.View.bindProjectionMatrix(this.program,n.camera.projectionMatrix);var r=this.configuration.output;0===r?(n.lighting.setUniforms(this.program,!1),this.program.setUniform3fv("ambient",t.ambient),this.program.setUniform3fv("diffuse",t.diffuse),this.program.setUniform4fv("externalColor",t.externalColor),this.program.setUniform1i("colorMixMode",b.colorMixModes[t.colorMixMode]),this.program.setUniform1f("opacity",t.opacity),this.program.setUniform1f("layerOpacity",t.layerOpacity),this.configuration.usePBR&&c.PhysicallyBasedRenderingParameters.bindUniforms(this.program,t,this.configuration.isSchematic)):1===r||3===r?this.program.setUniform2fv("nearFar",n.camera.nearFar):4===r&&l.OutputHighlight.bindOutputHighlight(e,this.program,n),u.VisualVariables.bindUniformsForSymbols(this.program,t),s.VerticalOffset.bindUniforms(this.program,t,n),b.bindScreenSizePerspective(t.screenSizePerspective,this.program,"screenSizePerspectiveAlignment"),2!==t.textureAlphaMode&&3!==t.textureAlphaMode||this.program.setUniform1f("textureAlphaCutoff",t.textureAlphaCutoff)},t.prototype.bindDraw=function(e){var t=this.configuration.instancedDoublePrecision?o.vec3f64.fromValues(e.camera.viewInverseTransposeMatrix[3],e.camera.viewInverseTransposeMatrix[7],e.camera.viewInverseTransposeMatrix[11]):e.origin;v.View.bindViewCustomOrigin(this.program,t,e.camera.viewMatrix),(0===this.configuration.output||1===this.configuration.output&&this.configuration.screenSizePerspective||2===this.configuration.output&&this.configuration.screenSizePerspective||4===this.configuration.output&&this.configuration.screenSizePerspective)&&v.View.bindCamPosition(this.program,t,e.camera.viewInverseTransposeMatrix),2===this.configuration.output&&this.program.setUniformMatrix4fv("viewNormal",e.camera.viewInverseTransposeMatrix),this.configuration.instancedDoublePrecision&&i.InstancedDoublePrecision.bindCustomOrigin(this.program,t),a.Slice.bindUniforms(this.program,this.configuration,e.slicePlane,t),0===this.configuration.output&&d.ReadShadowMap.bindViewCustomOrigin(this.program,e,t)},t.prototype.initializePipeline=function(){return null},t.shader=new p.ReloadableShaderModule(x,(function(){return new Promise((function(e,t){Promise.resolve().then((function(){var t=[n("9dVJ")];e.apply(null,t)}).bind(this)).catch(t.bind(this))}))})),t}(f.ShaderTechnique);t.DefaultMaterialTechnique=_;var w=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.output=0,t.alphaDiscardMode=1,t.doubleSidedMode=0,t.isSchematic=!1,t.vertexColors=!1,t.offsetBackfaces=!1,t.symbolColors=!1,t.vvSize=!1,t.vvColor=!1,t.verticalOffset=!1,t.receiveShadows=!1,t.slicePlaneEnabled=!1,t.sliceHighlightDisabled=!1,t.receiveAmbientOcclusion=!1,t.screenSizePerspective=!1,t.textureAlphaPremultiplied=!1,t.hasColorTexture=!1,t.usePBR=!1,t.hasMetalnessAndRoughnessTexture=!1,t.hasEmissionTexture=!1,t.hasOcclusionTexture=!1,t.hasNormalTexture=!1,t.instanced=!1,t.instancedColor=!1,t.instancedDoublePrecision=!1,t.vertexTangents=!1,t.normalsTypeDerivate=!1,t}return r.__extends(t,e),r.__decorate([h.parameter({count:7})],t.prototype,"output",void 0),r.__decorate([h.parameter({count:4})],t.prototype,"alphaDiscardMode",void 0),r.__decorate([h.parameter({count:3})],t.prototype,"doubleSidedMode",void 0),r.__decorate([h.parameter()],t.prototype,"isSchematic",void 0),r.__decorate([h.parameter()],t.prototype,"vertexColors",void 0),r.__decorate([h.parameter()],t.prototype,"offsetBackfaces",void 0),r.__decorate([h.parameter()],t.prototype,"symbolColors",void 0),r.__decorate([h.parameter()],t.prototype,"vvSize",void 0),r.__decorate([h.parameter()],t.prototype,"vvColor",void 0),r.__decorate([h.parameter()],t.prototype,"verticalOffset",void 0),r.__decorate([h.parameter()],t.prototype,"receiveShadows",void 0),r.__decorate([h.parameter()],t.prototype,"slicePlaneEnabled",void 0),r.__decorate([h.parameter()],t.prototype,"sliceHighlightDisabled",void 0),r.__decorate([h.parameter()],t.prototype,"receiveAmbientOcclusion",void 0),r.__decorate([h.parameter()],t.prototype,"screenSizePerspective",void 0),r.__decorate([h.parameter()],t.prototype,"textureAlphaPremultiplied",void 0),r.__decorate([h.parameter()],t.prototype,"hasColorTexture",void 0),r.__decorate([h.parameter()],t.prototype,"usePBR",void 0),r.__decorate([h.parameter()],t.prototype,"hasMetalnessAndRoughnessTexture",void 0),r.__decorate([h.parameter()],t.prototype,"hasEmissionTexture",void 0),r.__decorate([h.parameter()],t.prototype,"hasOcclusionTexture",void 0),r.__decorate([h.parameter()],t.prototype,"hasNormalTexture",void 0),r.__decorate([h.parameter()],t.prototype,"instanced",void 0),r.__decorate([h.parameter()],t.prototype,"instancedColor",void 0),r.__decorate([h.parameter()],t.prototype,"instancedDoublePrecision",void 0),r.__decorate([h.parameter()],t.prototype,"vertexTangents",void 0),r.__decorate([h.parameter()],t.prototype,"normalsTypeDerivate",void 0),t}(h.ShaderTechniqueConfiguration);t.DefaultMaterialTechniqueConfiguration=w}).apply(null,r))||(e.exports=o)},FN5H:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("T07b"),n("r0i9"),n("W/V4"),n("ff/U"),n("CsnI"),n("G0ER"),n("2Kdy")],void 0===(o=(function(e,t,r,o,a,i,s,l,c){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RealisticTreeTechnique=void 0;var d=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return r.__extends(t,e),t.prototype.initializeProgram=function(e){var n=t.shader.get(),r=this.configuration,o=n.build({output:r.output,viewingMode:e.viewingMode,receiveShadows:r.receiveShadows,slicePlaneEnabled:r.slicePlaneEnabled,sliceHighlightDisabled:r.sliceHighlightDisabled,sliceEnabledForVertexPrograms:!1,symbolColor:r.symbolColors,vvSize:r.vvSize,vvColor:r.vvColor,vvInstancingEnabled:!0,instanced:r.instanced,instancedColor:r.instancedColor,instancedDoublePrecision:r.instancedDoublePrecision,useOldSceneLightInterface:!1,pbrMode:r.usePBR?1:0,hasMetalnessAndRoughnessTexture:!1,hasEmissionTexture:!1,hasOcclusionTexture:!1,hasNormalTexture:!1,hasColorTexture:r.hasColorTexture,receiveAmbientOcclusion:r.receiveAmbientOcclusion,useCustomDTRExponentForWater:!1,normalType:0,doubleSidedMode:2,vertexTangets:!1,attributeTextureCoordinates:r.hasColorTexture?1:0,textureAlphaPremultiplied:r.textureAlphaPremultiplied,attributeColor:r.vertexColors,screenSizePerspectiveEnabled:r.screenSizePerspective,verticalOffsetEnabled:r.verticalOffset,offsetBackfaces:r.offsetBackfaces,doublePrecisionRequiresObfuscation:a.doublePrecisionRequiresObfuscation(e.rctx),alphaDiscardMode:r.alphaDiscardMode,supportsTextureAtlas:!1});return new c(e.rctx,o.generateSource("vertex"),o.generateSource("fragment"),s.Default3D)},t.shader=new i.ReloadableShaderModule(o,(function(){return new Promise((function(e,t){Promise.resolve().then((function(){var t=[n("T07b")];e.apply(null,t)}).bind(this)).catch(t.bind(this))}))})),t}(l.DefaultMaterialTechnique);t.RealisticTreeTechnique=d}).apply(null,r))||(e.exports=o)},Gz8v:function(e,t,n){var r,o;r=[n.dj.c(e.i),t],void 0===(o=(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.fill=t.copy=void 0,t.copy=function(e,t,n){for(var r=e.typedBuffer,o=e.typedBufferStride,a=t.typedBuffer,i=t.typedBufferStride,s=n?n.count:t.count,l=(n&&n.dstIndex?n.dstIndex:0)*o,c=(n&&n.srcIndex?n.srcIndex:0)*i,d=0;d<s;++d)r[l]=a[c],r[l+1]=a[c+1],r[l+2]=a[c+2],r[l+3]=a[c+3],l+=o,c+=i},t.fill=function(e,t,n,r,o,a){for(var i=e.typedBuffer,s=e.typedBufferStride,l=a?a.count:e.count,c=(a&&a.dstIndex?a.dstIndex:0)*s,d=0;d<l;++d)i[c]=t,i[c+1]=n,i[c+2]=r,i[c+3]=o,c+=s}}).apply(null,r))||(e.exports=o)},HkM8:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o,a,i,s;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateAmbientLighting=void 0,t.EvaluateAmbientLighting=function(e,t){var l=e.fragment,c=void 0!==t.lightingSphericalHarmonicsOrder?t.lightingSphericalHarmonicsOrder:2;0===c?(l.uniforms.add("lightingAmbientSH0","vec3"),l.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "]))))):1===c?(l.uniforms.add("lightingAmbientSH_R","vec4"),l.uniforms.add("lightingAmbientSH_G","vec4"),l.uniforms.add("lightingAmbientSH_B","vec4"),l.code.add(r.glsl(a||(a=n.__makeTemplateObject(["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec4 sh0 = vec4(\n          0.282095,\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y\n        );\n        vec3 ambientLight = vec3(\n          dot(lightingAmbientSH_R, sh0),\n          dot(lightingAmbientSH_G, sh0),\n          dot(lightingAmbientSH_B, sh0)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec4 sh0 = vec4(\n          0.282095,\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y\n        );\n        vec3 ambientLight = vec3(\n          dot(lightingAmbientSH_R, sh0),\n          dot(lightingAmbientSH_G, sh0),\n          dot(lightingAmbientSH_B, sh0)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "]))))):2===c&&(l.uniforms.add("lightingAmbientSH0","vec3"),l.uniforms.add("lightingAmbientSH_R1","vec4"),l.uniforms.add("lightingAmbientSH_G1","vec4"),l.uniforms.add("lightingAmbientSH_B1","vec4"),l.uniforms.add("lightingAmbientSH_R2","vec4"),l.uniforms.add("lightingAmbientSH_G2","vec4"),l.uniforms.add("lightingAmbientSH_B2","vec4"),l.code.add(r.glsl(i||(i=n.__makeTemplateObject(["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n\n        vec4 sh1 = vec4(\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y,\n          1.092548 * normal.x * normal.y\n        );\n        vec4 sh2 = vec4(\n          1.092548 * normal.y * normal.z,\n          0.315392 * (3.0 * normal.z * normal.z - 1.0),\n          1.092548 * normal.x * normal.z,\n          0.546274 * (normal.x * normal.x - normal.y * normal.y)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R1, sh1),\n          dot(lightingAmbientSH_G1, sh1),\n          dot(lightingAmbientSH_B1, sh1)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R2, sh2),\n          dot(lightingAmbientSH_G2, sh2),\n          dot(lightingAmbientSH_B2, sh2)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n\n        vec4 sh1 = vec4(\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y,\n          1.092548 * normal.x * normal.y\n        );\n        vec4 sh2 = vec4(\n          1.092548 * normal.y * normal.z,\n          0.315392 * (3.0 * normal.z * normal.z - 1.0),\n          1.092548 * normal.x * normal.z,\n          0.546274 * (normal.x * normal.x - normal.y * normal.y)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R1, sh1),\n          dot(lightingAmbientSH_G1, sh1),\n          dot(lightingAmbientSH_B1, sh1)\n        );\n        ambientLight += vec3(\n          dot(lightingAmbientSH_R2, sh2),\n          dot(lightingAmbientSH_G2, sh2),\n          dot(lightingAmbientSH_B2, sh2)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "])))),1!==t.pbrMode&&2!==t.pbrMode||l.code.add(r.glsl(s||(s=n.__makeTemplateObject(["\n        const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);\n\n        vec3 calculateAmbientRadiance(float ambientOcclusion)\n        {\n          vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;\n          return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;\n        }\n      "],["\n        const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);\n\n        vec3 calculateAmbientRadiance(float ambientOcclusion)\n        {\n          vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;\n          return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;\n        }\n      "])))))}}).apply(null,r))||(e.exports=o)},JvNb:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("rCq5"),n("7Aei")],void 0===(o=(function(e,t,n,r,o){"use strict";var a;Object.defineProperty(t,"__esModule",{value:!0}),t.MixExternalColor=void 0,t.MixExternalColor=function(e){e.include(r.ColorConversion),e.code.add(o.glsl(a||(a=n.__makeTemplateObject(["\n    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      vec3 internalMixed = internalColor * textureColor;\n      vec3 allMixed = internalMixed * externalColor;\n\n      if (mode == ",") {\n        return allMixed;\n      }\n      else if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalColor;\n      }\n      else {\n        // tint (or something invalid)\n        float vIn = rgb2v(internalMixed);\n        vec3 hsvTint = rgb2hsv(externalColor);\n        vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);\n        return hsv2rgb(hsvOut);\n      }\n    }\n\n    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      float internalMixed = internalOpacity * textureOpacity;\n      float allMixed = internalMixed * externalOpacity;\n\n      if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalOpacity;\n      }\n      else {\n        // multiply or tint (or something invalid)\n        return allMixed;\n      }\n    }\n  "],["\n    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      vec3 internalMixed = internalColor * textureColor;\n      vec3 allMixed = internalMixed * externalColor;\n\n      if (mode == ",") {\n        return allMixed;\n      }\n      else if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalColor;\n      }\n      else {\n        // tint (or something invalid)\n        float vIn = rgb2v(internalMixed);\n        vec3 hsvTint = rgb2hsv(externalColor);\n        vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);\n        return hsv2rgb(hsvOut);\n      }\n    }\n\n    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n      // workaround for artifacts in OSX using Intel Iris Pro\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\n      float internalMixed = internalOpacity * textureOpacity;\n      float allMixed = internalMixed * externalOpacity;\n\n      if (mode == ",") {\n        return internalMixed;\n      }\n      else if (mode == ",") {\n        return externalOpacity;\n      }\n      else {\n        // multiply or tint (or something invalid)\n        return allMixed;\n      }\n    }\n  "])),o.glsl.int(1),o.glsl.int(2),o.glsl.int(3),o.glsl.int(2),o.glsl.int(3)))}}).apply(null,r))||(e.exports=o)},KT2k:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateMainLighting=void 0,t.EvaluateMainLighting=function(e){var t=e.fragment;t.uniforms.add("lightingMainDirection","vec3"),t.uniforms.add("lightingMainIntensity","vec3"),t.uniforms.add("lightingFixedFactor","float"),t.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n    vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {\n      float dotVal = clamp(-dot(normal_global, lightingMainDirection), 0.0, 1.0);\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      return lightingMainIntensity * ((1.0 - shadowing) * dotVal);\n    }\n  "],["\n    vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {\n      float dotVal = clamp(-dot(normal_global, lightingMainDirection), 0.0, 1.0);\n\n      // move lighting towards (1.0, 1.0, 1.0) if requested\n      dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n\n      return lightingMainIntensity * ((1.0 - shadowing) * dotVal);\n    }\n  "]))))}}).apply(null,r))||(e.exports=o)},OIWm:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("pcDC"),n("qMld"),n("nRUF"),n("jfWY"),n("jfWY"),n("w00x"),n("FXVB"),n("1m5D"),n("EuvN"),n("lLWD"),n("wR99"),n("PT+s"),n("7eim"),n("VfPl"),n("TqPN")],void 0===(o=(function(e,t,n,r,o,a,i,s,l,c,d,u,m,v,p,f,h,g){"use strict";var b;Object.defineProperty(t,"__esModule",{value:!0}),t.Resource=void 0;var x=1179937895,y=function(){function e(e,t,n,r,o){this.context=e,this.errorContext=t,this.uri=n,this.json=r,this.glbBuffer=o,this.bufferCache=new Map,this.textureCache=new Map,this.materialCache=new Map,this.nodeParentMap=new Map,this.nodeTransformCache=new Map,this.baseUri=f.splitURI(this.uri).dirPart,this.checkVersionSupported(),this.checkRequiredExtensionsSupported(),t.errorUnsupportedIf(null==r.scenes,"Scenes must be defined."),t.errorUnsupportedIf(null==r.meshes,"Meshes must be defined"),t.errorUnsupportedIf(null==r.nodes,"Nodes must be defined."),this.computeNodeParents()}return e.load=function(t,r,o,i){return n.__awaiter(this,void 0,void 0,(function(){var l,c,d,u,m,v;return n.__generator(this,(function(n){switch(n.label){case 0:if(s.isDataProtocol(o)){if("model/gltf-binary"!==(l=s.dataComponents(o)).mediaType)try{return c=JSON.parse(l.isBase64?atob(l.data):l.data),[2,new e(t,r,o,c)]}catch(e){}if(d=s.dataToArrayBuffer(o),e.isGLBData(d))return[2,this.fromGLBData(t,r,o,d)]}return a.endsWith(o,".gltf")?[4,t.loadJSON(o,i)]:[3,2];case 1:return u=n.sent(),[2,new e(t,r,o,u)];case 2:return[4,t.loadBinary(o,i)];case 3:return m=n.sent(),e.isGLBData(m)?[2,this.fromGLBData(t,r,o,m)]:[4,t.loadJSON(o,i)];case 4:return v=n.sent(),[2,new e(t,r,o,v)]}}))}))},e.isGLBData=function(e){var t=new v.BinaryStreamReader(e);return t.remainingBytes()>=4&&t.readUint32()===x},e.fromGLBData=function(t,r,o,a){return n.__awaiter(this,void 0,void 0,(function(){var i;return n.__generator(this,(function(n){switch(n.label){case 0:return[4,e.parseGLBData(r,a)];case 1:return i=n.sent(),[2,new e(t,r,o,i.json,i.binaryData)]}}))}))},e.parseGLBData=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o,a,i,s,l,c,d,u;return n.__generator(this,(function(n){switch(n.label){case 0:r=new v.BinaryStreamReader(t),e.assert(r.remainingBytes()>=12,"GLB binary data is insufficiently large."),o=r.readUint32(),a=r.readUint32(),i=r.readUint32(),e.assert(o===x,"Magic first 4 bytes do not fit to expected GLB value."),e.assert(t.byteLength>=i,"GLB binary data is smaller than header specifies."),e.errorUnsupportedIf(2!==a,"An unsupported GLB container version was detected. Only version 2 is supported."),s=0,n.label=1;case 1:return r.remainingBytes()>=8?(d=r.readUint32(),u=r.readUint32(),0!==s?[3,3]:(e.assert(1313821514===u,"First GLB chunk must be JSON."),e.assert(d>=0,"No JSON data found."),[4,A(r.readUint8Array(d))])):[3,5];case 2:return l=n.sent(),[3,4];case 3:1===s?(e.errorUnsupportedIf(5130562!==u,"Second GLB chunk expected to be BIN."),c=r.readUint8Array(d)):e.warnUnsupported("More than 2 GLB chunks detected. Skipping."),n.label=4;case 4:return s+=1,[3,1];case 5:return l||e.error("No GLB JSON chunk detected."),[2,{json:l,binaryData:c}]}}))}))},e.prototype.getBuffer=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o,a,i;return n.__generator(this,(function(n){switch(n.label){case 0:return o=this.errorContext,null==(r=this.json.buffers[e]).uri?(o.assert(null!=this.glbBuffer,"GLB buffer not present"),[2,this.glbBuffer]):(a=this.bufferCache.get(e))?[3,2]:[4,this.context.loadBinary(this.resolveUri(r.uri),t)];case 1:i=n.sent(),a=new Uint8Array(i),this.bufferCache.set(e,a),o.assert(a.byteLength===r.byteLength,"Buffer byte lengths should match."),n.label=2;case 2:return[2,a]}}))}))},e.prototype.getAccessor=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o,a,i,s,l,c,d;return n.__generator(this,(function(n){switch(n.label){case 0:return(o=this.errorContext).errorUnsupportedIf(null==(r=this.json.accessors[e]).bufferView,"Some accessor does not specify a bufferView."),o.errorUnsupportedIf(r.type in["MAT2","MAT3","MAT4"],"AttributeType "+r.type+" is not supported"),[4,this.getBuffer((a=this.json.bufferViews[r.bufferView]).buffer,t)];case 1:return i=n.sent(),c=(s=C[r.type])*(l=O[r.componentType]),[2,{raw:i.buffer,byteStride:d=a.byteStride||c,byteOffset:i.byteOffset+(a.byteOffset||0)+(r.byteOffset||0),entryCount:r.count,isDenselyPacked:d===c,componentCount:s,componentByteSize:l,componentType:r.componentType,min:r.min,max:r.max,normalized:!!r.normalized}]}}))}))},e.prototype.getIndexData=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r;return n.__generator(this,(function(n){switch(n.label){case 0:return null==e.indices?[2,null]:[4,this.getAccessor(e.indices,t)];case 1:if((r=n.sent()).isDenselyPacked)switch(r.componentType){case 5121:return[2,new Uint8Array(r.raw,r.byteOffset,r.entryCount)];case 5123:return[2,new Uint16Array(r.raw,r.byteOffset,r.entryCount)];case 5125:return[2,new Uint32Array(r.raw,r.byteOffset,r.entryCount)]}else switch(r.componentType){case 5121:return[2,g.scalar.makeDense(this.wrapAccessor(h.BufferViewUint8,r))];case 5123:return[2,g.scalar.makeDense(this.wrapAccessor(h.BufferViewUint16,r))];case 5125:return[2,g.scalar.makeDense(this.wrapAccessor(h.BufferViewUint32,r))]}return[2,void 0]}}))}))},e.prototype.getPositionData=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o;return n.__generator(this,(function(n){switch(n.label){case 0:return(r=this.errorContext).errorUnsupportedIf(null==e.attributes.POSITION,"No POSITION vertex data found."),[4,this.getAccessor(e.attributes.POSITION,t)];case 1:return o=n.sent(),r.errorUnsupportedIf(5126!==o.componentType,"Expected type FLOAT for POSITION vertex attribute, but found "+P[o.componentType]),r.errorUnsupportedIf(3!==o.componentCount,"POSITION vertex attribute must have 3 components, but found "+o.componentCount.toFixed()),[2,this.wrapAccessor(h.BufferViewVec3f,o)]}}))}))},e.prototype.getNormalData=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o;return n.__generator(this,(function(n){switch(n.label){case 0:return(r=this.errorContext).assert(null!=e.attributes.NORMAL,"No NORMAL vertex data found."),[4,this.getAccessor(e.attributes.NORMAL,t)];case 1:return o=n.sent(),r.errorUnsupportedIf(5126!==o.componentType,"Expected type FLOAT for NORMAL vertex attribute, but found "+P[o.componentType]),r.errorUnsupportedIf(3!==o.componentCount,"NORMAL vertex attribute must have 3 components, but found "+o.componentCount.toFixed()),[2,this.wrapAccessor(h.BufferViewVec3f,o)]}}))}))},e.prototype.getTangentData=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o;return n.__generator(this,(function(n){switch(n.label){case 0:return(r=this.errorContext).assert(null!=e.attributes.TANGENT,"No TANGENT vertex data found."),[4,this.getAccessor(e.attributes.TANGENT,t)];case 1:return o=n.sent(),r.errorUnsupportedIf(5126!==o.componentType,"Expected type FLOAT for TANGENT vertex attribute, but found "+P[o.componentType]),r.errorUnsupportedIf(4!==o.componentCount,"TANGENT vertex attribute must have 4 components, but found "+o.componentCount.toFixed()),[2,new h.BufferViewVec4f(o.raw,o.byteOffset,o.byteStride,o.byteOffset+o.byteStride*o.entryCount)]}}))}))},e.prototype.getTextureCoordinates=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o;return n.__generator(this,(function(n){switch(n.label){case 0:return(r=this.errorContext).assert(null!=e.attributes.TEXCOORD_0,"No TEXCOORD_0 vertex data found."),[4,this.getAccessor(e.attributes.TEXCOORD_0,t)];case 1:return o=n.sent(),r.errorUnsupportedIf(2!==o.componentCount,"TEXCOORD_0 vertex attribute must have 2 components, but found "+o.componentCount.toFixed()),5126===o.componentType?[2,this.wrapAccessor(h.BufferViewVec2f,o)]:(r.errorUnsupportedIf(!o.normalized,"Integer component types are only supported for a normalized accessor for TEXCOORD_0."),[2,M(o)])}}))}))},e.prototype.getVertexColors=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o;return n.__generator(this,(function(n){switch(n.label){case 0:return(r=this.errorContext).assert(null!=e.attributes.COLOR_0,"No COLOR_0 vertex data found."),[4,this.getAccessor(e.attributes.COLOR_0,t)];case 1:if(o=n.sent(),r.errorUnsupportedIf(4!==o.componentCount&&3!==o.componentCount,"COLOR_0 attribute must have 3 or 4 components, but found "+o.componentCount.toFixed()),4===o.componentCount){if(5126===o.componentType)return[2,this.wrapAccessor(h.BufferViewVec4f,o)];if(5121===o.componentType)return[2,this.wrapAccessor(h.BufferViewVec4u8,o)];if(5123===o.componentType)return[2,this.wrapAccessor(h.BufferViewVec4u16,o)]}else if(3===o.componentCount){if(5126===o.componentType)return[2,this.wrapAccessor(h.BufferViewVec3f,o)];if(5121===o.componentType)return[2,this.wrapAccessor(h.BufferViewVec3u8,o)];if(5123===o.componentType)return[2,this.wrapAccessor(h.BufferViewVec3u16,o)]}return r.errorUnsupported("Unsupported component type for COLOR_0 attribute: "+P[o.componentType]),[2,void 0]}}))}))},e.prototype.hasPositions=function(e){return void 0!==e.attributes.POSITION},e.prototype.hasNormals=function(e){return void 0!==e.attributes.NORMAL},e.prototype.hasVertexColors=function(e){return void 0!==e.attributes.COLOR_0},e.prototype.hasTextureCoordinates=function(e){return void 0!==e.attributes.TEXCOORD_0},e.prototype.hasTangents=function(e){return void 0!==e.attributes.TANGENT},e.prototype.getMaterial=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o,a,i,s,l,c,d,u,m;return n.__generator(this,(function(n){switch(n.label){case 0:return r=this.errorContext,(o=this.materialCache.get(e.material))?[3,15]:(a=null!=e.material?p.material(this.json.materials[e.material]):p.material(),i=a.pbrMetallicRoughness,s=this.hasVertexColors(e),l=void 0,i.baseColorTexture?(r.errorUnsupportedIf(0!==(i.baseColorTexture.texCoord||0),"Only TEXCOORD with index 0 is supported."),[4,this.getTexture(i.baseColorTexture.index,t)]):[3,2]);case 1:l=n.sent(),n.label=2;case 2:return c=void 0,a.normalTexture?0===(a.normalTexture.texCoord||0)?[3,3]:(r.warnUnsupported("Only TEXCOORD with index 0 is supported for the normal map texture."),[3,5]):[3,5];case 3:return[4,this.getTexture(a.normalTexture.index,t)];case 4:c=n.sent(),n.label=5;case 5:return d=void 0,a.occlusionTexture?0===(a.occlusionTexture.texCoord||0)?[3,6]:(r.warnUnsupported("Only TEXCOORD with index 0 is supported for the occlusion texture."),[3,8]):[3,8];case 6:return[4,this.getTexture(a.occlusionTexture.index,t)];case 7:d=n.sent(),n.label=8;case 8:return u=void 0,a.emissiveTexture?0===(a.emissiveTexture.texCoord||0)?[3,9]:(r.warnUnsupported("Only TEXCOORD with index 0 is supported for the emissive texture."),[3,11]):[3,11];case 9:return[4,this.getTexture(a.emissiveTexture.index,t)];case 10:u=n.sent(),n.label=11;case 11:return m=void 0,i.metallicRoughnessTexture?0===(i.metallicRoughnessTexture.texCoord||0)?[3,12]:(r.warnUnsupported("Only TEXCOORD with index 0 is supported for the metallicRoughness texture."),[3,14]):[3,14];case 12:return[4,this.getTexture(i.metallicRoughnessTexture.index,t)];case 13:m=n.sent(),n.label=14;case 14:o={alphaMode:a.alphaMode,alphaCutoff:a.alphaCutoff,color:i.baseColorFactor,doubleSided:!!a.doubleSided,colorTexture:l,normalTexture:c,name:a.name,id:null!=e.material?e.material:-1,occlusionTexture:d,emissiveTexture:u,emissiveFactor:a.emissiveFactor,metallicFactor:i.metallicFactor,roughnessFactor:i.roughnessFactor,metallicRoughnessTexture:m,vertexColors:s,ESRI_externalColorMixMode:a.extras.ESRI_externalColorMixMode},n.label=15;case 15:return[2,o]}}))}))},e.prototype.getTexture=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o,a,i,s,l,c,d;return n.__generator(this,(function(n){switch(n.label){case 0:return r=this.errorContext,a=p.textureSampler(null!=(o=this.json.textures[e]).sampler?this.json.samplers[o.sampler]:{}),r.errorUnsupportedIf(null==o.source,"Source is expected to be defined for a texture."),i=this.json.images[o.source],(s=this.textureCache.get(e))?[3,6]:(l=void 0,i.uri?[4,this.context.loadImage(this.resolveUri(i.uri),t)]:[3,2]);case 1:return l=n.sent(),[3,5];case 2:return r.errorUnsupportedIf(null==i.bufferView,"Image bufferView must be defined."),r.errorUnsupportedIf(null==i.mimeType,"Image mimeType must be defined."),[4,this.getBuffer((c=this.json.bufferViews[i.bufferView]).buffer,t)];case 3:return d=n.sent(),r.errorUnsupportedIf(null!=c.byteStride,"byteStride not supported for image buffer"),[4,S(new Uint8Array(d.buffer,d.byteOffset+(c.byteOffset||0),c.byteLength),i.mimeType)];case 4:l=n.sent(),n.label=5;case 5:this.textureCache.set(e,s={data:l,wrapS:a.wrapS,wrapT:a.wrapT,minFilter:a.minFilter,name:i.name,id:e}),n.label=6;case 6:return[2,s]}}))}))},e.prototype.getNodeTransform=function(e){if(void 0===e)return w;var t=this.nodeTransformCache.get(e);if(!t){var n=this.getNodeTransform(this.getNodeParent(e)),r=this.json.nodes[e];r.matrix?t=c.mat4.multiply(d.mat4f64.create(),n,r.matrix):r.translation||r.rotation||r.scale?(t=d.mat4f64.clone(n),r.translation&&c.mat4.translate(t,t,r.translation),r.rotation&&(T[3]=u.quat.getAxisAngle(T,r.rotation),c.mat4.rotate(t,t,T[3],T)),r.scale&&c.mat4.scale(t,t,r.scale)):t=n,this.nodeTransformCache.set(e,t)}return t},e.prototype.wrapAccessor=function(e,t){return new e(t.raw,t.byteOffset,t.byteStride,t.byteOffset+t.byteStride*(t.entryCount-1)+t.componentByteSize*t.componentCount)},e.prototype.resolveUri=function(e){return i.makeAbsolute(e,this.baseUri)},e.prototype.getNodeParent=function(e){return this.nodeParentMap.get(e)},e.prototype.checkVersionSupported=function(){var e=l.Version.parse(this.json.asset.version,"glTF");_.validate(e)},e.prototype.checkRequiredExtensionsSupported=function(){var e=this.json;e.extensionsRequired&&0!==e.extensionsRequired.length&&this.errorContext.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: "+e.extensionsRequired.join(", "))},e.prototype.computeNodeParents=function(){var e=this;this.json.nodes.forEach((function(t,n){t.children&&t.children.forEach((function(t){e.nodeParentMap.set(t,n)}))}))},e}();t.Resource=y;var _=new l.Version(2,0,"glTF"),w=c.mat4.fromXRotation(d.mat4f64.create(),Math.PI/2),T=m.quatf64.create(),C={SCALAR:1,VEC2:2,VEC3:3,VEC4:4},O=((b={})[5120]=1,b[5121]=1,b[5122]=2,b[5123]=2,b[5126]=4,b[5125]=4,b);function M(e){switch(e.componentType){case 5120:return new h.BufferViewVec2i8(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5121:return new h.BufferViewVec2u8(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5122:return new h.BufferViewVec2i16(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5123:return new h.BufferViewVec2u16(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5125:return new h.BufferViewVec2u32(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5126:return new h.BufferViewVec2f(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);default:return void r.neverReached(e.componentType)}}function A(e){return n.__awaiter(this,void 0,void 0,(function(){return n.__generator(this,(function(t){return[2,o.create((function(t,n){var r=new Blob([e]),o=new FileReader;o.onload=function(){t(JSON.parse(o.result))},o.onerror=function(e){n(e)},o.readAsText(r)}))]}))}))}function S(e,t){return n.__awaiter(this,void 0,void 0,(function(){return n.__generator(this,(function(n){return[2,o.create((function(n,r){var o=new Blob([e],{type:t}),a=URL.createObjectURL(o),i=new Image;i.addEventListener("load",(function(){URL.revokeObjectURL(a),"decode"in i?i.decode().then((function(){return n(i)}),(function(){return n(i)})):n(i)})),i.addEventListener("error",(function(e){URL.revokeObjectURL(a),r(e)})),i.src=a}))]}))}))}var P={5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5125:"UNSIGNED_INT",5126:"FLOAT"}}).apply(null,r))||(e.exports=o)},"PT+s":function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("pcDC")],void 0===(o=(function(e,t,n,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.textureSampler=t.material=void 0;var o={baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1},a={pbrMetallicRoughness:o,emissiveFactor:[0,0,0],alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1},i={ESRI_externalColorMixMode:"tint"};t.material=function(e){void 0===e&&(e={});var t=n.__assign(n.__assign({},o),e.pbrMetallicRoughness),s=function(e){switch(e.ESRI_externalColorMixMode){case"multiply":case"tint":case"ignore":case"replace":break;default:r.neverReached(e.ESRI_externalColorMixMode),e.ESRI_externalColorMixMode="tint"}return e}(n.__assign(n.__assign({},i),e.extras));return n.__assign(n.__assign(n.__assign({},a),e),{pbrMetallicRoughness:t,extras:s})};var s={magFilter:9729,minFilter:9987,wrapS:10497,wrapT:10497};t.textureSampler=function(e){return n.__assign(n.__assign({},s),e)}}).apply(null,r))||(e.exports=o)},Q39H:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("fV0t"),n("QTYv")],void 0===(o=(function(e,t,n,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.vec4=t.vec3=void 0,t.vec3=n,t.vec4=r}).apply(null,r))||(e.exports=o)},QTYv:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("TUJR")],void 0===(o=(function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.shiftRight=t.scale=t.transformMat3=t.transformMat4=void 0,t.transformMat4=function(e,t,r){if(e.count===t.count)for(var o=e.count,a=r[0],i=r[1],s=r[2],l=r[3],c=r[4],d=r[5],u=r[6],m=r[7],v=r[8],p=r[9],f=r[10],h=r[11],g=r[12],b=r[13],x=r[14],y=r[15],_=e.typedBuffer,w=e.typedBufferStride,T=t.typedBuffer,C=t.typedBufferStride,O=0;O<o;O++){var M=O*w,A=O*C,S=T[A],P=T[A+1],L=T[A+2],R=T[A+3];_[M]=a*S+c*P+v*L+g*R,_[M+1]=i*S+d*P+p*L+b*R,_[M+2]=s*S+u*P+f*L+x*R,_[M+3]=l*S+m*P+h*L+y*R}else n.logger.error("source and destination buffers need to have the same number of elements")},t.transformMat3=function(e,t,r){if(e.count===t.count)for(var o=e.count,a=r[0],i=r[1],s=r[2],l=r[3],c=r[4],d=r[5],u=r[6],m=r[7],v=r[8],p=e.typedBuffer,f=e.typedBufferStride,h=t.typedBuffer,g=t.typedBufferStride,b=0;b<o;b++){var x=b*f,y=b*g,_=h[y],w=h[y+1],T=h[y+2],C=h[y+3];p[x]=a*_+l*w+u*T,p[x+1]=i*_+c*w+m*T,p[x+2]=s*_+d*w+v*T,p[x+3]=C}else n.logger.error("source and destination buffers need to have the same number of elements")},t.scale=function(e,t,n){for(var r=Math.min(e.count,t.count),o=e.typedBuffer,a=e.typedBufferStride,i=t.typedBuffer,s=t.typedBufferStride,l=0;l<r;l++){var c=l*a,d=l*s;o[c]=n*i[d],o[c+1]=n*i[d+1],o[c+2]=n*i[d+2],o[c+3]=n*i[d+3]}},t.shiftRight=function(e,t,n){for(var r=Math.min(e.count,t.count),o=e.typedBuffer,a=e.typedBufferStride,i=t.typedBuffer,s=t.typedBufferStride,l=0;l<r;l++){var c=l*a,d=l*s;o[c]=i[d]>>n,o[c+1]=i[d+1]>>n,o[c+2]=i[d+2]>>n,o[c+3]=i[d+3]>>n}}}).apply(null,r))||(e.exports=o)},Rqxa:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("zp6E"),n("WYKK"),n("ma1f"),n("rg9i"),n("qsST"),n("LxLY"),n("qMld"),n("w00x"),n("Rdxj"),n("WRgd"),n("weRx"),n("ys4y"),n("AgDx"),n("yqrJ"),n("TP2F")],void 0===(o=(function(e,t,n,r,o,a,i,s,l,c,d,u,m,v,p,f,h,g){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createTextureResources=t.processLoadResult=t.load=void 0;var b=s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");function x(e,t){return n.__awaiter(this,void 0,void 0,(function(){var a,i;return n.__generator(this,(function(n){switch(n.label){case 0:return(a=l.isSome(t)&&t.streamDataRequester)?[2,y(e,a,t)]:[4,o.result(r(e,l.unwrap(t)))];case 1:return!0===(i=n.sent()).ok?[2,i.value.data]:(c.throwIfAbortError(i.error),_(i.error),[2,void 0])}}))}))}function y(e,t,r){return n.__awaiter(this,void 0,void 0,(function(){var a;return n.__generator(this,(function(n){switch(n.label){case 0:return[4,o.result(t.request(e,"json",r))];case 1:return!0===(a=n.sent()).ok?[2,a.value]:(c.throwIfAbortError(a.error),_(a.error.details.url),[2,void 0])}}))}))}function _(e){throw new a("","Request for object resource failed: "+e)}function w(e){var t=e.params,n=t.topology,r=!0;switch(t.vertexAttributes||(b.warn("Geometry must specify vertex attributes"),r=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:var o=t.faces;if(o){if(t.vertexAttributes)for(var a in t.vertexAttributes){var i=o[a];i&&i.values?(null!=i.valueType&&"UInt32"!==i.valueType&&(b.warn("Unsupported indexed geometry indices type '"+i.valueType+"', only UInt32 is currently supported"),r=!1),null!=i.valuesPerElement&&1!==i.valuesPerElement&&(b.warn("Unsupported indexed geometry values per element '"+i.valuesPerElement+"', only 1 is currently supported"),r=!1)):(b.warn("Indexed geometry does not specify face indices for '"+a+"' attribute"),r=!1)}}else b.warn("Indexed geometries must specify faces"),r=!1;break;default:b.warn("Unsupported topology '"+n+"'"),r=!1}e.params.material||(b.warn("Geometry requires material"),r=!1);var s=e.params.vertexAttributes;for(var l in s)s[l].values||(b.warn("Geometries with externally defined attributes are not yet supported"),r=!1);return r}function T(e){var t=m.empty();return e.forEach((function(e){var n=e.boundingInfo;m.expand(t,n.getBBMin()),m.expand(t,n.getBBMax())})),t}function C(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o,a,i,s,d,u,m;return n.__generator(this,(function(n){switch(n.label){case 0:for(a in r=[],o=function(n){var o=e[n],a=o.images[0].data;if(!a)return b.warn("Externally referenced texture data is not yet supported"),"continue";var i=o.encoding+";base64,"+a,s="/textureDefinitions/"+n,d={noUnpackFlip:!0,wrap:{s:10497,t:10497},preMultiplyAlpha:!0},u=l.isSome(t)&&t.disableTextures?c.resolve(null):v.requestImage(i,t);r.push(u.then((function(e){return{refId:s,image:e,params:d,alphaChannelUsage:"rgba"===o.channels?o.alphaChannelUsage||"transparency":"none"}})))},e)o(a);return[4,c.all(r)];case 1:for(i=n.sent(),s={},d=0,u=i;d<u.length;d++)s[(m=u[d]).refId]=m;return[2,s]}}))}))}function O(e){switch(e){case"mask":return 2;case"maskAndTransparency":return 3;case"none":return 1;case"transparency":default:return 0}}function M(e){var t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}function A(e){for(var t=new Uint32Array(e),n=0;n<e;n++)t[n]=n;return t}t.load=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var r,o;return n.__generator(this,(function(n){switch(n.label){case 0:return[4,x(e,t)];case 1:return[4,C((r=n.sent()).textureDefinitions,t)];case 2:return o=n.sent(),[2,{resource:r,textures:o}]}}))}))},t.processLoadResult=function(e,t){var n=[],r=[],o=[],a=[],s=e.resource,c=d.Version.parse(s.version||"1.0","wosr");S.validate(c);for(var m=s.model.name,v=s.model.geometries,b=s.materialDefinitions,x=e.textures,y=0,_=new Map,C=0;C<v.length;C++){var P=v[C];if(w(P)){var L=M(P),R=P.params.vertexAttributes,B={};for(var D in R){var I=R[D];B[D]={data:I.values,size:I.valuesPerElement}}var F={};if("PerAttributeArray"===P.params.topology){var V=A(B.position.data.length/B.position.size);for(var j in B)F[j]=V}else{var E=P.params.faces;for(var N in E)F[N]=new Uint32Array(E[N].values)}var z=x&&x[L.texture];if(z&&!_.has(L.texture)){var k=new h(z.image,m,z.params);a.push(k),_.set(L.texture,k)}var G=_.get(L.texture),U=G?G.id:void 0,W=o[L.material]?o[L.material][L.texture]:null;if(!W){var H=b[L.material.substring(L.material.lastIndexOf("/")+1)].params;1===H.transparency&&(H.transparency=0);var q=z&&z.alphaChannelUsage,J=H.transparency>0||"transparency"===q||"maskAndTransparency"===q,X={ambient:u.vec3f64.fromArray(H.diffuse),diffuse:u.vec3f64.fromArray(H.diffuse),opacity:1-(H.transparency||0),transparent:J,textureAlphaMode:z?O(z.alphaChannelUsage):void 0,textureAlphaCutoff:.33,textureId:U,initTextureTransparent:!0,doubleSided:!0,cullFace:0,colorMixMode:H.externalColorMixMode||"tint",textureAlphaPremultiplied:!0};l.isSome(t)&&t.materialParamsMixin&&i.mixin(X,t.materialParamsMixin),W=new g(X,m),o[L.material]||(o[L.material]={}),o[L.material][L.texture]=W}r.push(W);var Y=new p(new f.GeometryData(B,F),m);y+=F.position?F.position.length:0,n.push(Y)}}return{name:m,stageResources:{textures:a,materials:r,geometries:n},pivotOffset:s.model.pivotOffset,boundingBox:T(n),numberOfVertices:y,lodThreshold:null}},t.createTextureResources=C;var S=new d.Version(1,2,"wosr")}).apply(null,r))||(e.exports=o)},T07b:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("cmSR"),n("nobt"),n("fese"),n("3kdR"),n("m7Ki"),n("8TPw"),n("uci5"),n("hIiW"),n("lF8C"),n("6t3m"),n("xDGw"),n("gS4P"),n("eYHx"),n("+5nk"),n("piY7"),n("zdOl"),n("cj3m"),n("3PFg"),n("IwVr"),n("JvNb"),n("7Aei"),n("aExC")],void 0===(o=(function(e,t,n,r,o,a,i,s,l,c,d,u,m,v,p,f,h,g,b,x,y,_,w,T,C){"use strict";var O,M,A,S,P,L,R,B,D,I,F;Object.defineProperty(t,"__esModule",{value:!0}),t.build=void 0,t.build=function(e){var t=new C.ShaderBuilder,V=t.vertex.code,j=t.fragment.code;return t.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3"),t.include(c.PositionAttribute),t.varyings.add("vpos","vec3"),t.include(y.VisualVariables,e),t.include(s.InstancedDoublePrecision,e),t.include(v.VerticalOffset,e),0===e.output&&(t.include(l.NormalAttribute,e),t.include(i.Transform,{linearDepth:!1}),e.offsetBackfaces&&t.include(o.Offset),e.instancedColor&&t.attributes.add("instanceColor","vec4"),t.varyings.add("vNormalWorld","vec3"),t.varyings.add("localvpos","vec3"),t.include(u.TextureCoordinateAttribute,e),t.include(r.ForwardLinearDepth,e),t.include(d.SymbolColor,e),t.include(m.VertexColor,e),t.vertex.uniforms.add("externalColor","vec4"),t.varyings.add("vcolorExt","vec4"),V.add(T.glsl(O||(O=n.__makeTemplateObject(["\n        void main(void) {\n          forwardNormalizedVertexColor();\n          vcolorExt = externalColor;\n          ","\n          vcolorExt *= vvColor();\n          vcolorExt *= getSymbolColor();\n          forwardColorMixMode();\n\n          if (vcolorExt.a < ",") {\n            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n          }\n          else {\n            vpos = calculateVPos();\n            localvpos = vpos - view[3].xyz;\n            vpos = subtractOrigin(vpos);\n            vNormalWorld = dpNormal(vvLocalNormal(normalModel()));\n            vpos = addVerticalOffset(vpos, localOrigin);\n            gl_Position = transformPosition(proj, view, vpos);\n            ","\n          }\n          forwardLinearDepth();\n          forwardTextureCoordinates();\n        }\n      "],["\n        void main(void) {\n          forwardNormalizedVertexColor();\n          vcolorExt = externalColor;\n          ","\n          vcolorExt *= vvColor();\n          vcolorExt *= getSymbolColor();\n          forwardColorMixMode();\n\n          if (vcolorExt.a < ",") {\n            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n          }\n          else {\n            vpos = calculateVPos();\n            localvpos = vpos - view[3].xyz;\n            vpos = subtractOrigin(vpos);\n            vNormalWorld = dpNormal(vvLocalNormal(normalModel()));\n            vpos = addVerticalOffset(vpos, localOrigin);\n            gl_Position = transformPosition(proj, view, vpos);\n            ","\n          }\n          forwardLinearDepth();\n          forwardTextureCoordinates();\n        }\n      "])),e.instancedColor?"vcolorExt *= instanceColor;":"",T.glsl.float(_.symbolAlphaCutoff),e.offsetBackfaces?"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);":"")),t.include(a.Slice,e),t.include(h.EvaluateSceneLighting,e),t.include(f.EvaluateAmbientOcclusion,e),t.include(_.DiscardOrAdjustAlpha,e),e.receiveShadows&&t.include(x.ReadShadowMap,e),t.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("opacity","float").add("layerOpacity","float"),t.fragment.uniforms.add("view","mat4"),e.hasColorTexture&&t.fragment.uniforms.add("tex","sampler2D"),t.include(b.PhysicallyBasedRenderingParameters,e),t.include(g.PhysicallyBasedRendering,e),t.fragment.include(w.MixExternalColor),j.add(T.glsl(F||(F=n.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        vec3 viewDirection = normalize(vpos - camPos);\n        ","\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ","\n        vec3 matColor = max(ambient, diffuse);\n        ","\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        vec3 viewDirection = normalize(vpos - camPos);\n        ","\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ","\n        vec3 matColor = max(ambient, diffuse);\n        ","\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "])),e.hasColorTexture?T.glsl(M||(M=n.__makeTemplateObject(["\n        vec4 texColor = texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"],["\n        vec4 texColor = texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"])),e.textureAlphaPremultiplied?"texColor.rgb /= texColor.a;":""):T.glsl(A||(A=n.__makeTemplateObject(["vec4 texColor = vec4(1.0);"],["vec4 texColor = vec4(1.0);"]))),1===e.pbrMode?"applyPBRFactors();":"",e.receiveShadows?"float shadow = readShadowMap(vpos, linearDepth);":1===e.viewingMode?"float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);":"float shadow = 0.0;",T.glsl(e.attributeColor?S||(S=n.__makeTemplateObject(["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"],["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"])):P||(P=n.__makeTemplateObject(["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n        "],["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n        "]))),T.glsl(L||(L=n.__makeTemplateObject(["\n        vec3 shadedNormal = normalize(vNormalWorld);\n        albedo_ *= 1.2;\n        vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView = clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n        float transmittance = 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff = vColor.r;\n        float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight += backLightFactor * lightingMainIntensity;"],["\n        vec3 shadedNormal = normalize(vNormalWorld);\n        albedo_ *= 1.2;\n        vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView = clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n        float transmittance = 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff = vColor.r;\n        float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight += backLightFactor * lightingMainIntensity;"]))),T.glsl(1===e.pbrMode||2===e.pbrMode?1===e.viewingMode?R||(R=n.__makeTemplateObject(["vec3 normalGround = normalize(vpos + localOrigin);"],["vec3 normalGround = normalize(vpos + localOrigin);"])):B||(B=n.__makeTemplateObject(["vec3 normalGround = vec3(0.0, 0.0, 1.0);"],["vec3 normalGround = vec3(0.0, 0.0, 1.0);"])):D||(D=n.__makeTemplateObject([""],[""]))),1===e.pbrMode||2===e.pbrMode?T.glsl(I||(I=n.__makeTemplateObject(["\n            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);"],["\n            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);"]))):"vec3 shadedColor = evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);"))),t.include(p.DefaultMaterialAuxiliaryPasses,e),t}}).apply(null,r))||(e.exports=o)},TP2F:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("51bw"),n("0LE5"),n("Rdxj"),n("2B1V"),n("IwVr"),n("9FJH"),n("9DjX"),n("FNtW"),n("lfQW"),n("CIy2"),n("ILj8"),n("s6rJ"),n("CsnI"),n("FN5H"),n("qbr3"),n("qbr3")],void 0===(o=(function(e,t,n,r,o,a,i,s,l,c,d,u,m,v,p,f,h,g,b){"use strict";var x=m.assert,y=function(e){function t(n,r){var o=e.call(this,r)||this;return o.supportsEdges=!0,o.techniqueConfig=new f.DefaultMaterialTechniqueConfiguration,o.params=p.copyParameters(n,w),o.vertexBufferLayout=t.getVertexBufferLayout(o.params),o.instanceBufferLayout=n.instanced?t.getInstanceBufferLayout(o.params):null,o}return n.__extends(t,e),t.prototype.isVisibleInPass=function(e){return 3!==e||this.params.castShadows},t.prototype.isVisible=function(){var t=this.params;if(!e.prototype.isVisible.call(this)||0===t.layerOpacity)return!1;var n=t.instanced,r=t.vertexColors,o=t.symbolColors,a=!!n&&n.indexOf("color")>-1,i=t.vvColorEnabled,s="replace"===t.colorMixMode,l=t.opacity>0,c=t.externalColor&&t.externalColor[3]>0;return r&&(a||i||o)?!!s||l:r?s?c:l:a||i||o?!!s||l:s?c:l},t.prototype.setParameterValues=function(e){var t=this.params;for(var n in e)"instanced"===n&&x(e.instanced===t.instanced,"Can not change instanced attributes"),"textureId"===n&&x(t.textureId,"Can only change texture of material that already has a texture"),"vertexColors"===n&&!0===e[n]&&e[n]!==t[n]&&x(t.vertexColors,"Can not enable vertex colors after DefaultMaterial creation"),t[n]=e[n];this.parametersChanged()},t.prototype.getParameters=function(){return this.params},t.prototype.getTechniqueConfig=function(e){return this.techniqueConfig.output=e,this.techniqueConfig.hasNormalTexture=!!this.params.normalTextureId,this.techniqueConfig.hasColorTexture=!!this.params.textureId,this.techniqueConfig.vertexTangents=this.params.vertexTangents,this.techniqueConfig.instanced=!!this.params.instanced,this.techniqueConfig.instancedDoublePrecision=this.params.instancedDoublePrecision,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.verticalOffset=null!==this.params.verticalOffset,this.techniqueConfig.screenSizePerspective=null!==this.params.screenSizePerspective,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.sliceHighlightDisabled=this.params.sliceHighlightDisabled,this.techniqueConfig.alphaDiscardMode=this.params.textureAlphaMode,this.techniqueConfig.normalsTypeDerivate="screenDerivative"===this.params.normals,0===e&&(this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.symbolColors=this.params.symbolColors,this.params.treeRendering||(this.techniqueConfig.doubleSidedMode=this.params.doubleSided&&"normal"===this.params.doubleSidedType?1:this.params.doubleSided&&"winding-order"===this.params.doubleSidedType?2:0),this.techniqueConfig.instancedColor=!!this.params.instanced&&this.params.instanced.indexOf("color")>-1,this.techniqueConfig.receiveShadows=this.params.receiveShadows&&this.params.shadowMappingEnabled,this.techniqueConfig.receiveAmbientOcclusion=this.params.receiveSSAO,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.textureAlphaPremultiplied=!!this.params.textureAlphaPremultiplied,this.techniqueConfig.usePBR=this.params.usePBR,this.techniqueConfig.hasMetalnessAndRoughnessTexture=!!this.params.metallicRoughnessTextureId,this.techniqueConfig.hasEmissionTexture=!!this.params.emissiveTextureId,this.techniqueConfig.hasOcclusionTexture=!!this.params.occlusionTextureId,this.techniqueConfig.offsetBackfaces=!(!this.params.transparent||!this.params.offsetTransparentBackfaces),this.techniqueConfig.isSchematic=this.params.usePBR&&this.params.isSchematic),this.techniqueConfig},t.prototype.intersect=function(e,t,n,r,a,i,s){if(null!==this.params.verticalOffset){var l=r.camera;o.vec3.set(R,n[12],n[13],n[14]);var d=null;switch(r.viewingMode){case 1:d=o.vec3.normalize(P,R);break;case 2:d=o.vec3.copy(P,S)}var u=0;if(null!==this.params.verticalOffset){var m=o.vec3.subtract(B,R,l.eye),v=o.vec3.length(m),f=o.vec3.scale(m,m,1/v),h=null;this.params.screenSizePerspective&&(h=o.vec3.dot(d,f)),u+=p.verticalOffsetAtDistance(l,v,this.params.verticalOffset,h,this.params.screenSizePerspective)}o.vec3.scale(d,d,u),o.vec3.transformMat3(L,d,r.transform.inverseRotation),a=o.vec3.subtract(M,a,L),i=o.vec3.subtract(A,i,L)}p.intersectTriangleGeometry(e,t,r,a,i,c.getVerticalOffsetObject3D(r.verticalOffset),s)},t.prototype.getGLMaterial=function(e){if(0===e.output||1===e.output||2===e.output||3===e.output||4===e.output)return new _(e)},t.prototype.createBufferWriter=function(){return new T(this.vertexBufferLayout,this.instanceBufferLayout)},t.getVertexBufferLayout=function(e){var t=e.textureId||e.normalTextureId||e.metallicRoughnessTextureId||e.emissiveTextureId||e.occlusionTextureId,n=i.newLayout().vec3f("position").vec3f("normal");return e.vertexTangents&&n.vec4f("tangent"),t&&n.vec2f("uv0"),e.vertexColors&&n.vec4u8("color"),e.symbolColors&&n.vec4u8("symbolColor"),n},t.getInstanceBufferLayout=function(e){var t=i.newLayout();return t=e.instancedDoublePrecision?t.vec3f("modelOriginHi").vec3f("modelOriginLo").mat3f("model").mat3f("modelNormal"):t.mat4f("model").mat4f("modelNormal"),e.instanced&&e.instanced.indexOf("color")>-1&&(t=t.vec4f("instanceColor")),e.instanced&&e.instanced.indexOf("featureAttribute")>-1&&(t=t.vec4f("instanceFeatureAttribute")),t},t}(d.Material),_=function(e){function t(t){var r=this,o=t.material;return(r=e.call(this,n.__assign(n.__assign({},t),o.getParameters()))||this).updateParameters(),r}return n.__extends(t,e),t.prototype.updateParameters=function(){this.selectPipelines(),this.selectSlot();var e=this.material.getParameters();this.updateTexture(e.textureId),this.technique=this.techniqueRep.acquireAndReleaseExisting(e.treeRendering?h.RealisticTreeTechnique:f.DefaultMaterialTechnique,this.material.getTechniqueConfig(this.output),this.technique)},t.prototype.selectSlot=function(){this.slot=this.material.getParameters().transparent?this.material.getParameters().writeDepth?5:8:3},t.prototype.selectPipelines=function(){var e=this.material.getParameters(),t=0===this.output?C(e):null,n=function(n){return b.makePipelineState({blending:t,culling:O(e),depthTest:{func:513},depthWrite:e.writeDepth&&b.defaultDepthWriteParams,colorWrite:b.defaultColorWriteParams,stencilWrite:e.sceneHasOcludees?u.stencilWriteMaskOn:null,stencilTest:e.sceneHasOcludees?n?u.stencilToolMaskBaseParams:u.stencilBaseAllZerosParams:null})};this.pipelineState=n(!1),this.occludeePipelineState=n(!0)},t.prototype._updateShadowState=function(e){e.shadowMappingEnabled!==this.material.getParameters().shadowMappingEnabled&&(this.material.setParameterValues({shadowMappingEnabled:e.shadowMappingEnabled}),this.updateParameters())},t.prototype._updateOccludeeState=function(e){e.hasOccludees!==this.material.getParameters().sceneHasOcludees&&(this.material.setParameterValues({sceneHasOcludees:e.hasOccludees}),this.updateParameters())},t.prototype.ensureParameters=function(e){0===this.output&&(this._updateShadowState(e),this._updateOccludeeState(e))},t.prototype.bind=function(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getParameters(),t),this.bindTexture(e,this.technique.program)},t.prototype.beginSlot=function(e){return e===this.slot},t.prototype.getPipelineState=function(e,t){return t?this.occludeePipelineState:this.pipelineState},t}(l);!function(e){e.COLOR_GAMMA=2.1}(y||(y={}));var w={textureId:void 0,initTextureTransparent:!1,isSchematic:!1,usePBR:!1,normalTextureId:void 0,vertexTangents:!1,occlusionTextureId:void 0,emissiveTextureId:void 0,metallicRoughnessTextureId:void 0,emissiveFactor:[0,0,0],mrrFactors:[0,1,.5],ambient:[.2,.2,.2],diffuse:[.8,.8,.8],externalColor:[1,1,1,1],colorMixMode:"multiply",opacity:1,layerOpacity:1,vertexColors:!1,symbolColors:!1,doubleSided:!1,doubleSidedType:"normal",cullFace:void 0,instanced:void 0,instancedDoublePrecision:!1,normals:"default",receiveSSAO:!0,receiveShadows:!0,castShadows:!0,shadowMappingEnabled:!1,verticalOffset:null,screenSizePerspective:null,slicePlaneEnabled:!1,sliceHighlightDisabled:!1,offsetTransparentBackfaces:!1,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvSizeValue:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],vvSymbolAnchor:[0,0,0],vvSymbolRotationMatrix:r.mat3f64.create(),transparent:!1,writeDepth:!0,textureAlphaMode:0,textureAlphaCutoff:s.defaultMaskAlphaCutoff,textureAlphaPremultiplied:!1,sceneHasOcludees:!1},T=function(){function e(e,t){this.vertexBufferLayout=e,this.instanceBufferLayout=t}return e.prototype.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},e.prototype.elementCount=function(e){return e.indices.position.length},e.prototype.write=function(e,t,n,r){v.writeDefaultAttributes(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,n,r)},e}(),C=function(e){return e.transparent&&g.separateBlendingParams(770,1,771,771)},O=function(e){return function(e){return e.cullFace?0!==e.cullFace:!e.slicePlaneEnabled&&!e.transparent&&!e.doubleSided}(e)&&{face:1===e.cullFace?1028:1029,mode:2305}},M=a.vec3f64.create(),A=a.vec3f64.create(),S=a.vec3f64.fromValues(0,0,1),P=a.vec3f64.create(),L=a.vec3f64.create(),R=a.vec3f64.create(),B=a.vec3f64.create();return y}).apply(null,r))||(e.exports=o)},TUJR:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("qsST")],void 0===(o=(function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logger=void 0,t.logger=n.getLogger("esri.views.3d.support.buffer.math")}).apply(null,r))||(e.exports=o)},TqPN:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("GntT"),n("f3AO"),n("dB/a"),n("cza4"),n("9o4r"),n("W5Zm"),n("Gz8v")],void 0===(o=(function(e,t,n,r,o,a,i,s,l){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createBuffer=t.mat4=t.mat3=t.vec4=t.vec3=t.vec2=t.scalar=void 0,t.mat3=r,t.mat4=o,t.scalar=a,t.vec2=i,t.vec3=s,t.vec4=l,t.createBuffer=function(e,t){return new e(new ArrayBuffer(t*e.ElementCount*n.elementTypeSize(e.ElementType)))}}).apply(null,r))||(e.exports=o)},TqrP:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht")],void 0===(o=(function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeTextureSource=t.makeMaterialParameters=void 0,t.makeMaterialParameters=function(e){return void 0===e&&(e={}),n.__assign({color:[1,1,1],opacity:1,alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1,castShadows:!0,receiveShadows:!0,receiveAmbientOcclustion:!0,textureColor:null,textureNormal:null,textureOcclusion:null,textureEmissive:null,textureMetallicRoughness:null,emissiveFactor:[0,0,0],metallicFactor:1,roughnessFactor:1,colorMixMode:"multiply"},e)},t.makeTextureSource=function(e,t){return void 0===t&&(t={}),{data:e,parameters:n.__assign({wrap:n.__assign({s:10497,t:10497},t.wrap),noUnpackFlip:!0,mipmap:!1},t)}}}).apply(null,r))||(e.exports=o)},W5Zm:function(e,t,n){var r,o;r=[n.dj.c(e.i),t],void 0===(o=(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.copy=void 0,t.copy=function(e,t,n){for(var r=e.typedBuffer,o=e.typedBufferStride,a=t.typedBuffer,i=t.typedBufferStride,s=n?n.count:t.count,l=(n&&n.dstIndex?n.dstIndex:0)*o,c=(n&&n.srcIndex?n.srcIndex:0)*i,d=0;d<s;++d)r[l]=a[c],r[l+1]=a[c+1],r[l+2]=a[c+2],l+=o,c+=i}}).apply(null,r))||(e.exports=o)},WMxK:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o;Object.defineProperty(t,"__esModule",{value:!0}),t.DecodeSymbolColor=void 0,t.DecodeSymbolColor=function(e){e.vertex.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n      float symbolAlpha = 0.0;\n\n      const float maxTint = 85.0;\n      const float maxReplace = 170.0;\n      const float scaleAlpha = 3.0;\n\n      if (symbolColor.a > maxReplace) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);\n      } else if (symbolColor.a > maxTint) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);\n      } else if (symbolColor.a > 0.0) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * symbolColor.a;\n      } else {\n        colorMixMode = ",";\n        symbolAlpha = 0.0;\n      }\n\n      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);\n    }\n  "],["\n    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n      float symbolAlpha = 0.0;\n\n      const float maxTint = 85.0;\n      const float maxReplace = 170.0;\n      const float scaleAlpha = 3.0;\n\n      if (symbolColor.a > maxReplace) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);\n      } else if (symbolColor.a > maxTint) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);\n      } else if (symbolColor.a > 0.0) {\n        colorMixMode = ",";\n        symbolAlpha = scaleAlpha * symbolColor.a;\n      } else {\n        colorMixMode = ",";\n        symbolAlpha = 0.0;\n      }\n\n      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);\n    }\n  "])),r.glsl.int(1),r.glsl.int(3),r.glsl.int(4),r.glsl.int(1)))}}).apply(null,r))||(e.exports=o)},ZuXA:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("rusB"),n("+nCE")],void 0===(o=(function(e,t,n,r){"use strict";function o(e){return r.generateDefaultIndexArray(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.triangleFanToTriangles=t.triangleStripToTriangles=t.trianglesToTriangles=t.linearIndexArray=void 0,t.linearIndexArray=o,t.trianglesToTriangles=function(e){return"number"==typeof e?o(e):n.isUint16Array(e)||n.isUint8Array(e)?new Uint32Array(e):e},t.triangleStripToTriangles=function(e){var t="number"==typeof e?e:e.length;if(t<3)return new Uint32Array(0);var n=t-2,r=new Uint32Array(3*n);if("number"==typeof e)for(var o=0,a=0;a<n;a+=1)a%2==0?(r[o++]=a,r[o++]=a+1,r[o++]=a+2):(r[o++]=a+1,r[o++]=a,r[o++]=a+2);else for(o=0,a=0;a<n;a+=1)if(a%2==0){var i=e[a],s=e[a+1],l=e[a+2];r[o++]=i,r[o++]=s,r[o++]=l}else s=e[a],l=e[a+2],r[o++]=i=e[a+1],r[o++]=s,r[o++]=l;return r},t.triangleFanToTriangles=function(e){var t="number"==typeof e?e:e.length;if(t<3)return new Uint32Array(0);var n=t-2,r=new Uint32Array(3*n);if("number"==typeof e){for(var o=0,a=0;a<n;++a)r[o++]=0,r[o++]=a+1,r[o++]=a+2;return r}var i=e[0],s=e[1];for(o=0,a=0;a<n;++a){var l=e[a+2];r[o++]=i,r[o++]=s,r[o++]=l,s=l}return r}}).apply(null,r))||(e.exports=o)},aluc:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("mOGR"),n("7Aei")],void 0===(o=(function(e,t,n,r,o){"use strict";var a,i,s,l;Object.defineProperty(t,"__esModule",{value:!0}),t.ComputeNormalTexture=void 0,t.ComputeNormalTexture=function(e,t){var c=e.fragment;c.uniforms.add("normalTexture","sampler2D"),c.uniforms.add("normalTextureSize","vec2"),t.vertexTangets?(e.attributes.add("tangent","vec4"),e.varyings.add("vTangent","vec4"),c.code.add(o.glsl(2===t.doubleSidedMode?a||(a=n.__makeTemplateObject(["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\n        vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "],["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\n        vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "])):i||(i=n.__makeTemplateObject(["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = vTangent.w;\n        vec3 tangent = normalize(vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "],["\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = vTangent.w;\n        vec3 tangent = normalize(vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    "]))))):(e.extensions.add("GL_OES_standard_derivatives"),c.code.add(o.glsl(s||(s=n.__makeTemplateObject(['\n    mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\n\n      vec3 Q1 = dFdx(pos);\n      vec3 Q2 = dFdy(pos);\n\n      vec2 stx = dFdx(st);\n      vec2 sty = dFdy(st);\n\n      float det = stx.t * sty.s - sty.t * stx.s;\n\n      vec3 T = stx.t * Q2 - sty.t * Q1; // compute tangent\n      T = T - normal * dot(normal, T); // orthogonalize tangent\n      T *= inversesqrt(max(dot(T,T), 1.e-10)); // "soft" normalize - goes to 0 when T goes to 0\n      vec3 B = sign(det) * cross(normal, T); // assume normal is normalized, B has the same lenght as B\n      return mat3(T, B, normal); // T and B go to 0 when the tangent space is not well defined by the uv coordinates\n    }\n  '],['\n    mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\n\n      vec3 Q1 = dFdx(pos);\n      vec3 Q2 = dFdy(pos);\n\n      vec2 stx = dFdx(st);\n      vec2 sty = dFdy(st);\n\n      float det = stx.t * sty.s - sty.t * stx.s;\n\n      vec3 T = stx.t * Q2 - sty.t * Q1; // compute tangent\n      T = T - normal * dot(normal, T); // orthogonalize tangent\n      T *= inversesqrt(max(dot(T,T), 1.e-10)); // "soft" normalize - goes to 0 when T goes to 0\n      vec3 B = sign(det) * cross(normal, T); // assume normal is normalized, B has the same lenght as B\n      return mat3(T, B, normal); // T and B go to 0 when the tangent space is not well defined by the uv coordinates\n    }\n  ']))))),0!==t.attributeTextureCoordinates&&(e.include(r.VertexTextureCoordinates,t),c.code.add(o.glsl(l||(l=n.__makeTemplateObject(["\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ","\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  "],["\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ","\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  "])),t.supportsTextureAtlas?"vtc.size = normalTextureSize;":"")))}}).apply(null,r))||(e.exports=o)},cE5x:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("ma1f"),n("qsST")],void 0===(o=(function(e,t,n,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultErrorContext=void 0;var o=r.getLogger("esri.views.3d.glTF"),a=function(){function e(){}return e.prototype.error=function(e){throw new n("gltf-loader-error",e)},e.prototype.errorUnsupported=function(e){throw new n("gltf-loader-unsupported-feature",e)},e.prototype.errorUnsupportedIf=function(e,t){e&&this.errorUnsupported(t)},e.prototype.assert=function(e,t){e||this.error(t)},e.prototype.warn=function(e){o.warn(e)},e.prototype.warnUnsupported=function(e){this.warn("[Unsupported Feature] "+e)},e.prototype.warnUnsupportedIf=function(e,t){e&&this.warnUnsupported(t)},e}();t.DefaultErrorContext=a}).apply(null,r))||(e.exports=o)},cGZG:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o,a,i,s;Object.defineProperty(t,"__esModule",{value:!0}),t.Normals=void 0,t.Normals=function(e,t){var l=e.fragment;l.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n    struct ShadingNormalParameters {\n      vec3 normalView;\n      vec3 viewDirection;\n    } shadingParams;\n    "],["\n    struct ShadingNormalParameters {\n      vec3 normalView;\n      vec3 viewDirection;\n    } shadingParams;\n    "])))),l.code.add(r.glsl(1===t.doubleSidedMode?a||(a=n.__makeTemplateObject(["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return dot(params.normalView, params.viewDirection) > 0.0 ? normalize(-params.normalView) : normalize(params.normalView);\n      }\n    "],["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return dot(params.normalView, params.viewDirection) > 0.0 ? normalize(-params.normalView) : normalize(params.normalView);\n      }\n    "])):2===t.doubleSidedMode?i||(i=n.__makeTemplateObject(["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return gl_FrontFacing ? normalize(params.normalView) : normalize(-params.normalView);\n      }\n    "],["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return gl_FrontFacing ? normalize(params.normalView) : normalize(-params.normalView);\n      }\n    "])):s||(s=n.__makeTemplateObject(["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return normalize(params.normalView);\n      }\n    "],["\n      vec3 shadingNormal(ShadingNormalParameters params) {\n        return normalize(params.normalView);\n      }\n    "]))))}}).apply(null,r))||(e.exports=o)},cMCQ:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("J/1E"),n("LxLY"),n("YX1r"),n("51bw"),n("FXVB"),n("1m5D"),n("0LE5"),n("Rdxj"),n("WRgd"),n("5PWn"),n("jj3b"),n("ZuXA"),n("Rqxa"),n("VfPl"),n("Q39H"),n("TqPN"),n("ys4y"),n("AgDx"),n("yqrJ"),n("TP2F")],void 0===(o=(function(e,t,n,r,o,a,i,s,l,c,d,u,m,v,p,f,h,g,b,x,y,_,w){"use strict";function T(e){var t=e.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);return t?{fileType:"gltf",url:t[1],specifiedLodIndex:null!=t[4]?Number(t[4]):null}:e.match(/(.*\.(json|json\.gz))$/)?{fileType:"wosr",url:e,specifiedLodIndex:null}:{fileType:"unknown",url:e,specifiedLodIndex:null}}function C(e,t,r,s){var l=e.model,c=i.mat3f64.create(),d=new Array,m=new Map,v=new Map;return l.lods.forEach((function(e,i){if(void 0===s||i===s){var f=0,T={name:e.name,stageResources:{textures:new Array,materials:new Array,geometries:new Array},lodThreshold:o.isSome(e.lodThreshold)?e.lodThreshold:null,pivotOffset:[0,0,0],numberOfVertices:0,boundingBox:u.empty()};d.push(T),e.parts.forEach((function(i){var s=i.material+(i.attributes.normal?"_normal":"")+(i.attributes.color?"_color":"")+(i.attributes.texCoord0?"_texCoord0":"")+(i.attributes.tangent?"_tangent":""),d=l.materials.get(i.material),C=o.isSome(i.attributes.texCoord0),M=o.isSome(i.attributes.normal);if(!m.has(s)){if(C){if(o.isSome(d.textureColor)&&!v.has(d.textureColor)){var A=l.textures.get(d.textureColor),S=n.__assign(n.__assign({},A.parameters),{preMultiplyAlpha:!0});v.set(d.textureColor,new _(A.data,d.textureColor,S))}o.isSome(d.textureNormal)&&!v.has(d.textureNormal)&&(A=l.textures.get(d.textureNormal),S=n.__assign(n.__assign({},A.parameters),{preMultiplyAlpha:!0}),v.set(d.textureNormal,new _(A.data,d.textureNormal,S))),o.isSome(d.textureOcclusion)&&!v.has(d.textureOcclusion)&&(A=l.textures.get(d.textureOcclusion),S=n.__assign(n.__assign({},A.parameters),{preMultiplyAlpha:!0}),v.set(d.textureOcclusion,new _(A.data,d.textureOcclusion,S))),o.isSome(d.textureEmissive)&&!v.has(d.textureEmissive)&&(A=l.textures.get(d.textureEmissive),S=n.__assign(n.__assign({},A.parameters),{preMultiplyAlpha:!0}),v.set(d.textureEmissive,new _(A.data,d.textureEmissive,S))),o.isSome(d.textureMetallicRoughness)&&!v.has(d.textureMetallicRoughness)&&(A=l.textures.get(d.textureMetallicRoughness),S=n.__assign(n.__assign({},A.parameters),{preMultiplyAlpha:!0}),v.set(d.textureMetallicRoughness,new _(A.data,d.textureMetallicRoughness,S)))}var P=w.COLOR_GAMMA,L=Math.pow(d.color[0],1/P),R=Math.pow(d.color[1],1/P),B=Math.pow(d.color[2],1/P),D=Math.pow(d.emissiveFactor[0],1/P),I=Math.pow(d.emissiveFactor[1],1/P),F=Math.pow(d.emissiveFactor[2],1/P);m.set(s,new w(n.__assign(n.__assign(n.__assign({},t),{transparent:"BLEND"===d.alphaMode,textureAlphaMode:O(d.alphaMode),textureAlphaCutoff:d.alphaCutoff,diffuse:[L,R,B],ambient:[L,R,B],opacity:d.opacity,doubleSided:d.doubleSided,doubleSidedType:"winding-order",cullFace:d.doubleSided?0:2,vertexColors:!!i.attributes.color,vertexTangents:!!i.attributes.tangent,normals:M?"default":"screenDerivative",castShadows:!0,receiveSSAO:!0,textureId:o.isSome(d.textureColor)&&C?v.get(d.textureColor).id:void 0,colorMixMode:d.colorMixMode,normalTextureId:o.isSome(d.textureNormal)&&C?v.get(d.textureNormal).id:void 0,textureAlphaPremultiplied:!0,occlusionTextureId:o.isSome(d.textureOcclusion)&&C?v.get(d.textureOcclusion).id:void 0,emissiveTextureId:o.isSome(d.textureEmissive)&&C?v.get(d.textureEmissive).id:void 0,metallicRoughnessTextureId:o.isSome(d.textureMetallicRoughness)&&C?v.get(d.textureMetallicRoughness).id:void 0,emissiveFactor:[D,I,F],mrrFactors:[d.metallicFactor,d.roughnessFactor,t.mrrFactors[2]],isSchematic:!1}),r),s))}var V=function(e,t){switch(t){case 4:return p.trianglesToTriangles(e);case 5:return p.triangleStripToTriangles(e);case 6:return p.triangleFanToTriangles(e)}}(i.indices||i.attributes.position.count,i.primitiveType),j={},E={},N=i.attributes.position.count,z=b.createBuffer(h.BufferViewVec3f,N);if(g.vec3.transformMat4(z,i.attributes.position,i.transform),E.position={data:z.typedBuffer,size:z.elementCount},j.position=V,o.isSome(i.attributes.normal)){var k=b.createBuffer(h.BufferViewVec3f,N);a.mat3.normalFromMat4(c,i.transform),g.vec3.transformMat3(k,i.attributes.normal,c),E.normal={data:k.typedBuffer,size:k.elementCount},j.normal=V}if(o.isSome(i.attributes.tangent)){var G=b.createBuffer(h.BufferViewVec4f,N);a.mat3.normalFromMat4(c,i.transform),g.vec4.transformMat3(G,i.attributes.tangent,c),E.tangent={data:G.typedBuffer,size:G.elementCount},j.tangent=V}if(o.isSome(i.attributes.texCoord0)){var U=b.createBuffer(h.BufferViewVec2f,N);b.vec2.normalizeIntegerBuffer(U,i.attributes.texCoord0),E.uv0={data:U.typedBuffer,size:U.elementCount},j.uv0=V}if(o.isSome(i.attributes.color)){var W=b.createBuffer(h.BufferViewVec4u8,N);if(4===i.attributes.color.elementCount)i.attributes.color instanceof h.BufferViewVec4f?g.vec4.scale(W,i.attributes.color,255):i.attributes.color instanceof h.BufferViewVec4u8?b.vec4.copy(W,i.attributes.color):i.attributes.color instanceof h.BufferViewVec4u16&&g.vec4.scale(W,i.attributes.color,1/256);else{b.vec4.fill(W,255,255,255,255);var H=new h.BufferViewVec3u8(W.buffer,0,4);i.attributes.color instanceof h.BufferViewVec3f?g.vec3.scale(H,i.attributes.color,255):i.attributes.color instanceof h.BufferViewVec3u8?b.vec3.copy(H,i.attributes.color):i.attributes.color instanceof h.BufferViewVec3u16&&g.vec3.scale(H,i.attributes.color,1/256)}E.color={data:W.typedBuffer,size:W.elementCount},j.color=V}var q=new x(new y.GeometryData(E,j),"gltf_"+e.name+"_"+f++);T.stageResources.geometries.push(q),T.stageResources.materials.push(m.get(s)),C&&(o.isSome(d.textureColor)&&T.stageResources.textures.push(v.get(d.textureColor)),o.isSome(d.textureNormal)&&T.stageResources.textures.push(v.get(d.textureNormal)),o.isSome(d.textureOcclusion)&&T.stageResources.textures.push(v.get(d.textureOcclusion)),o.isSome(d.textureEmissive)&&T.stageResources.textures.push(v.get(d.textureEmissive)),o.isSome(d.textureMetallicRoughness)&&T.stageResources.textures.push(v.get(d.textureMetallicRoughness))),T.numberOfVertices+=N;var J=q.boundingInfo;u.expand(T.boundingBox,J.getBBMin()),u.expand(T.boundingBox,J.getBBMax())}))}})),d}function O(e){switch(e){case"BLEND":return 0;case"MASK":return 2;case"OPAQUE":return 1;default:return 0}}Object.defineProperty(t,"__esModule",{value:!0}),t.gltfToEngineResources=t.parseUrl=t.fetch=void 0,t.fetch=function(e,t){return n.__awaiter(this,void 0,void 0,(function(){var a,i,u,p,g,x,y,_,w,O,M;return n.__generator(this,(function(A){switch(A.label){case 0:return"wosr"!==(a=T(r.adjustStaticAGOUrl(e))).fileType?[3,2]:[4,t.cache?t.cache.loadWOSR(a.url,t):f.load(a.url,t)];case 1:return i=A.sent(),[2,{lods:[u=f.processLoadResult(i,t)],referenceBoundingBox:u.boundingBox,isEsriSymbolResource:!1,isWosr:!0,remove:i.remove}];case 2:return[4,t.cache?t.cache.loadGLTF(a.url,t):v.load(new m.DefaultLoadingContext(t.streamDataRequester),a.url,t)];case 3:return p=A.sent(),g=o.get(p.model.meta,"ESRI_proxyEllipsoid"),p.meta.isEsriSymbolResource&&o.isSome(g)&&-1!==p.meta.uri.indexOf("/RealisticTrees/")&&function(e,t){for(var n=0;n<e.model.lods.length;++n){var r=e.model.lods[n];e.customMeta.esriTreeRendering=!0;for(var a=0,i=r.parts;a<i.length;a++){var u=i[a],m=u.attributes.normal;if(o.isNone(m))return;for(var v=u.attributes.position,p=v.count,f=d.vec3f64.create(),g=d.vec3f64.create(),x=d.vec3f64.create(),y=b.createBuffer(h.BufferViewVec4u8,p),_=b.createBuffer(h.BufferViewVec3f,p),w=s.mat4.invert(l.mat4f64.create(),u.transform),T=0;T<p;T++){v.getVec(T,g),m.getVec(T,f),c.vec3.transformMat4(g,g,u.transform),c.vec3.subtract(x,g,t.center),c.vec3.divide(x,x,t.radius);var C=x[2],O=c.vec3.length(x),M=Math.min(.45+.55*O*O,1);c.vec3.divide(x,x,t.radius),c.vec3.transformMat4(x,x,w),c.vec3.normalize(x,x),n+1!==e.model.lods.length&&e.model.lods.length>1&&c.vec3.lerp(x,x,f,C>-1?.2:Math.min(-4*C-3.8,1)),_.setVec(T,x),y.set(T,0,255*M),y.set(T,1,255*M),y.set(T,2,255*M),y.set(T,3,255)}u.attributes.normal=_,u.attributes.color=y}}}(p,g),x=p.meta.isEsriSymbolResource?{usePBR:t.usePBR,isSchematic:!1,treeRendering:p.customMeta.esriTreeRendering,mrrFactors:[0,1,.2]}:{usePBR:!0,isSchematic:!1,mrrFactors:[0,1,.5]},y=n.__assign(n.__assign({},t.materialParamsMixin),{treeRendering:p.customMeta.esriTreeRendering}),null!=a.specifiedLodIndex?(_=C(p,x,y,a.specifiedLodIndex),w=_[0].boundingBox,0!==a.specifiedLodIndex&&(O=C(p,x,y,0),w=O[0].boundingBox),[2,{lods:_,referenceBoundingBox:w,isEsriSymbolResource:p.meta.isEsriSymbolResource,isWosr:!1,remove:p.remove}]):[2,{lods:M=C(p,x,y),referenceBoundingBox:M[0].boundingBox,isEsriSymbolResource:p.meta.isEsriSymbolResource,isWosr:!1,remove:p.remove}]}}))}))},t.parseUrl=T,t.gltfToEngineResources=C}).apply(null,r))||(e.exports=o)},cqYc:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("8TPw"),n("1pwa"),n("7Aei")],void 0===(o=(function(e,t,n,r,o,a){"use strict";function i(e,t){0===t.normalType||1===t.normalType?(e.include(r.NormalAttribute,t),e.varyings.add("vNormalWorld","vec3"),e.varyings.add("vNormalView","vec3"),e.vertex.uniforms.add("uTransformNormal_GlobalFromModel","mat3"),e.vertex.uniforms.add("uTransformNormal_ViewFromGlobal","mat3"),e.vertex.code.add(a.glsl(s||(s=n.__makeTemplateObject(["\n      void forwardNormal() {\n        vNormalWorld = uTransformNormal_GlobalFromModel * normalModel();\n        vNormalView = uTransformNormal_ViewFromGlobal * vNormalWorld;\n      }\n    "],["\n      void forwardNormal() {\n        vNormalWorld = uTransformNormal_GlobalFromModel * normalModel();\n        vNormalView = uTransformNormal_ViewFromGlobal * vNormalWorld;\n      }\n    "]))))):2===t.normalType?(e.include(o.VertexPosition,t),e.varyings.add("vNormalWorld","vec3"),e.vertex.code.add(a.glsl(d||(d=n.__makeTemplateObject(["\n    void forwardNormal() {\n      vNormalWorld = ","\n    }\n    "],["\n    void forwardNormal() {\n      vNormalWorld = ","\n    }\n    "])),a.glsl(1===t.viewingMode?l||(l=n.__makeTemplateObject(["normalize(vPositionWorldCameraRelative);"],["normalize(vPositionWorldCameraRelative);"])):c||(c=n.__makeTemplateObject(["vec3(0.0, 0.0, 1.0);"],["vec3(0.0, 0.0, 1.0);"])))))):e.vertex.code.add(a.glsl(u||(u=n.__makeTemplateObject(["\n      void forwardNormal() {}\n    "],["\n      void forwardNormal() {}\n    "]))))}var s,l,c,d,u;Object.defineProperty(t,"__esModule",{value:!0}),t.VertexNormal=void 0,t.VertexNormal=i,function(e){e.bindUniforms=function(e,t){e.setUniformMatrix4fv("viewNormal",t)}}(i=t.VertexNormal||(t.VertexNormal={}))}).apply(null,r))||(e.exports=o)},cza4:function(e,t,n){var r,o;r=[n.dj.c(e.i),t],void 0===(o=(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeDense=t.copy=void 0,t.copy=function(e,t,n){for(var r=e.typedBuffer,o=e.typedBufferStride,a=t.typedBuffer,i=t.typedBufferStride,s=n?n.count:t.count,l=(n&&n.dstIndex?n.dstIndex:0)*o,c=(n&&n.srcIndex?n.srcIndex:0)*i,d=0;d<s;++d)r[l]=a[c],l+=o,c+=i},t.makeDense=function(e,t){var n=e.count;t||(t=new e.TypedArrayConstructor(n));for(var r=0;r<n;r++)t[r]=e.get(r);return t}}).apply(null,r))||(e.exports=o)},"dB/a":function(e,t,n){var r,o;r=[n.dj.c(e.i),t],void 0===(o=(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.copy=void 0,t.copy=function(e,t,n){for(var r=e.typedBuffer,o=e.typedBufferStride,a=t.typedBuffer,i=t.typedBufferStride,s=n?n.count:t.count,l=(n&&n.dstIndex?n.dstIndex:0)*o,c=(n&&n.srcIndex?n.srcIndex:0)*i,d=0;d<s;++d){for(var u=0;u<16;++u)r[l+u]=a[c+u];l+=o,c+=i}}}).apply(null,r))||(e.exports=o)},eFLy:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("H1tY"),n("7Aei")],void 0===(o=(function(e,t,n,r,o){"use strict";var a;Object.defineProperty(t,"__esModule",{value:!0}),t.HeaderComment=void 0,t.HeaderComment=function(e,t){var i=o.glsl(a||(a=n.__makeTemplateObject(["\n  /*\n  *  ","\n  *  ","\n  */\n  "],["\n  /*\n  *  ","\n  *  ","\n  */\n  "])),t.name,0===t.output?"RenderOutput: Color":1===t.output?"RenderOutput: Depth":3===t.output?"RenderOutput: Shadow":2===t.output?"RenderOutput: Normal":4===t.output?"RenderOutput: Highlight":"");r("esri-validate-shaders")&&(e.fragment.code.add(i),e.vertex.code.add(i))}}).apply(null,r))||(e.exports=o)},eYHx:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o,a;Object.defineProperty(t,"__esModule",{value:!0}),t.EvaluateAmbientOcclusion=void 0,t.EvaluateAmbientOcclusion=function(e,t){var i=e.fragment;t.receiveAmbientOcclusion?(i.uniforms.add("ssaoTex","sampler2D"),i.uniforms.add("viewportPixelSz","vec4"),i.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n      float evaluateAmbientOcclusion() {\n        return 1.0 - texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n      }\n\n      float evaluateAmbientOcclusionInverse() {\n        float ssao = texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        return viewportPixelSz.z < 0.0 ? 1.0 : ssao;\n      }\n    "],["\n      float evaluateAmbientOcclusion() {\n        return 1.0 - texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n      }\n\n      float evaluateAmbientOcclusionInverse() {\n        float ssao = texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        return viewportPixelSz.z < 0.0 ? 1.0 : ssao;\n      }\n    "]))))):i.code.add(r.glsl(a||(a=n.__makeTemplateObject(["\n      float evaluateAmbientOcclusion() { return 0.0; } // no occlusion\n      float evaluateAmbientOcclusionInverse() { return 1.0; }\n    "],["\n      float evaluateAmbientOcclusion() { return 0.0; } // no occlusion\n      float evaluateAmbientOcclusionInverse() { return 1.0; }\n    "]))))}}).apply(null,r))||(e.exports=o)},f3AO:function(e,t,n){var r,o;r=[n.dj.c(e.i),t],void 0===(o=(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.copy=void 0,t.copy=function(e,t,n){for(var r=e.typedBuffer,o=e.typedBufferStride,a=t.typedBuffer,i=t.typedBufferStride,s=n?n.count:t.count,l=(n&&n.dstIndex?n.dstIndex:0)*o,c=(n&&n.srcIndex?n.srcIndex:0)*i,d=0;d<s;++d){for(var u=0;u<9;++u)r[l+u]=a[c+u];l+=o,c+=i}}}).apply(null,r))||(e.exports=o)},fV0t:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("TUJR")],void 0===(o=(function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.shiftRight=t.scale=t.transformMat3=t.transformMat4=void 0,t.transformMat4=function(e,t,r){if(e.count===t.count)for(var o=e.count,a=r[0],i=r[1],s=r[2],l=r[4],c=r[5],d=r[6],u=r[8],m=r[9],v=r[10],p=r[12],f=r[13],h=r[14],g=e.typedBuffer,b=e.typedBufferStride,x=t.typedBuffer,y=t.typedBufferStride,_=0;_<o;_++){var w=_*b,T=_*y,C=x[T],O=x[T+1],M=x[T+2];g[w]=a*C+l*O+u*M+p,g[w+1]=i*C+c*O+m*M+f,g[w+2]=s*C+d*O+v*M+h}else n.logger.error("source and destination buffers need to have the same number of elements")},t.transformMat3=function(e,t,r){if(e.count===t.count)for(var o=e.count,a=r[0],i=r[1],s=r[2],l=r[3],c=r[4],d=r[5],u=r[6],m=r[7],v=r[8],p=e.typedBuffer,f=e.typedBufferStride,h=t.typedBuffer,g=t.typedBufferStride,b=0;b<o;b++){var x=b*f,y=b*g,_=h[y],w=h[y+1],T=h[y+2];p[x]=a*_+l*w+u*T,p[x+1]=i*_+c*w+m*T,p[x+2]=s*_+d*w+v*T}else n.logger.error("source and destination buffers need to have the same number of elements")},t.scale=function(e,t,n){for(var r=Math.min(e.count,t.count),o=e.typedBuffer,a=e.typedBufferStride,i=t.typedBuffer,s=t.typedBufferStride,l=0;l<r;l++){var c=l*a,d=l*s;o[c]=n*i[d],o[c+1]=n*i[d+1],o[c+2]=n*i[d+2]}},t.shiftRight=function(e,t,n){for(var r=Math.min(e.count,t.count),o=e.typedBuffer,a=e.typedBufferStride,i=t.typedBuffer,s=t.typedBufferStride,l=0;l<r;l++){var c=l*a,d=l*s;o[c]=i[d]>>n,o[c+1]=i[d+1]>>n,o[c+2]=i[d+2]>>n}}}).apply(null,r))||(e.exports=o)},gS4P:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("fese"),n("3kdR"),n("8TPw"),n("lF8C"),n("cqYc"),n("uEh2"),n("PaEL"),n("3PFg"),n("IwVr"),n("7Aei")],void 0===(o=(function(e,t,n,r,o,a,i,s,l,c,d,u,m){"use strict";var v,p,f,h,g,b,x,y,_,w,T,C;Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultMaterialAuxiliaryPasses=void 0,t.DefaultMaterialAuxiliaryPasses=function(e,t){var O=e.vertex.code,M=e.fragment.code;1!==t.output&&3!==t.output||(e.include(o.Transform,{linearDepth:!0}),e.include(i.TextureCoordinateAttribute,t),e.include(d.VisualVariables,t),e.include(l.OutputDepth,t),e.include(r.Slice,t),e.vertex.uniforms.add("nearFar","vec2"),e.varyings.add("depth","float"),t.hasColorTexture&&e.fragment.uniforms.add("tex","sampler2D"),O.add(m.glsl(v||(v=n.__makeTemplateObject(["\n      void main(void) {\n        vpos = calculateVPos();\n        vpos = subtractOrigin(vpos);\n        vpos = addVerticalOffset(vpos, localOrigin);\n        gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n        vpos = subtractOrigin(vpos);\n        vpos = addVerticalOffset(vpos, localOrigin);\n        gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "])))),e.include(u.DiscardOrAdjustAlpha,t),M.add(m.glsl(f||(f=n.__makeTemplateObject(["\n      void main(void) {\n        discardBySlice(vpos);\n        ","\n        outputDepth(depth);\n      }\n    "],["\n      void main(void) {\n        discardBySlice(vpos);\n        ","\n        outputDepth(depth);\n      }\n    "])),t.hasColorTexture?m.glsl(p||(p=n.__makeTemplateObject(["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);"],["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);"]))):""))),2===t.output&&(e.include(o.Transform,{linearDepth:!1}),e.include(a.NormalAttribute,t),e.include(s.VertexNormal,t),e.include(i.TextureCoordinateAttribute,t),e.include(d.VisualVariables,t),t.hasColorTexture&&e.fragment.uniforms.add("tex","sampler2D"),e.vertex.uniforms.add("viewNormal","mat4"),e.varyings.add("vPositionView","vec3"),O.add(m.glsl(g||(g=n.__makeTemplateObject(["\n      void main(void) {\n        vpos = calculateVPos();\n        vpos = subtractOrigin(vpos);\n        ","\n        vpos = addVerticalOffset(vpos, localOrigin);\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n        vpos = subtractOrigin(vpos);\n        ","\n        vpos = addVerticalOffset(vpos, localOrigin);\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "])),0===t.normalType?m.glsl(h||(h=n.__makeTemplateObject(["\n        vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));"],["\n        vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));"]))):"")),e.include(r.Slice,t),e.include(u.DiscardOrAdjustAlpha,t),M.add(m.glsl(_||(_=n.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vpos);\n        ","\n\n        ","\n        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        ","\n\n        ","\n        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "])),t.hasColorTexture?m.glsl(b||(b=n.__makeTemplateObject(["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);"],["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);"]))):"",m.glsl(3===t.normalType?x||(x=n.__makeTemplateObject(["\n            vec3 normal = screenDerivativeNormal(vPositionView);"],["\n            vec3 normal = screenDerivativeNormal(vPositionView);"])):y||(y=n.__makeTemplateObject(["\n            vec3 normal = normalize(vNormalWorld);\n            if (gl_FrontFacing == false) normal = -normal;"],["\n            vec3 normal = normalize(vNormalWorld);\n            if (gl_FrontFacing == false) normal = -normal;"])))))),4===t.output&&(e.include(o.Transform,{linearDepth:!1}),e.include(i.TextureCoordinateAttribute,t),e.include(d.VisualVariables,t),t.hasColorTexture&&e.fragment.uniforms.add("tex","sampler2D"),O.add(m.glsl(w||(w=n.__makeTemplateObject(["\n      void main(void) {\n        vpos = calculateVPos();\n        vpos = subtractOrigin(vpos);\n        vpos = addVerticalOffset(vpos, localOrigin);\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n        vpos = subtractOrigin(vpos);\n        vpos = addVerticalOffset(vpos, localOrigin);\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "])))),e.include(r.Slice,t),e.include(u.DiscardOrAdjustAlpha,t),e.include(c.OutputHighlight),M.add(m.glsl(C||(C=n.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        outputHighlight();\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        outputHighlight();\n      }\n    "])),t.hasColorTexture?m.glsl(T||(T=n.__makeTemplateObject(["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);"],["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);"]))):"")))}}).apply(null,r))||(e.exports=o)},hIiW:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("WMxK"),n("7Aei")],void 0===(o=(function(e,t,n,r,o){"use strict";var a,i;Object.defineProperty(t,"__esModule",{value:!0}),t.SymbolColor=void 0,t.SymbolColor=function(e,t){t.symbolColor?(e.include(r.DecodeSymbolColor),e.attributes.add("symbolColor","vec4"),e.varyings.add("colorMixMode","mediump float")):e.fragment.uniforms.add("colorMixMode","int"),e.vertex.code.add(o.glsl(t.symbolColor?a||(a=n.__makeTemplateObject(["\n    int symbolColorMixMode;\n\n    vec4 getSymbolColor() {\n      return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;\n    }\n\n    void forwardColorMixMode() {\n      colorMixMode = float(symbolColorMixMode) + 0.5;\n    }\n  "],["\n    int symbolColorMixMode;\n\n    vec4 getSymbolColor() {\n      return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;\n    }\n\n    void forwardColorMixMode() {\n      colorMixMode = float(symbolColorMixMode) + 0.5;\n    }\n  "])):i||(i=n.__makeTemplateObject(["\n    vec4 getSymbolColor() { return vec4(1.0); }\n    void forwardColorMixMode() {}\n    "],["\n    vec4 getSymbolColor() { return vec4(1.0); }\n    void forwardColorMixMode() {}\n    "]))))}}).apply(null,r))||(e.exports=o)},jj3b:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("LxLY"),n("qMld"),n("1m5D"),n("cE5x"),n("TqrP"),n("OIWm")],void 0===(o=(function(e,t,n,r,o,a,i,s,l){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.load=void 0;var c=0;function d(e){var t=null;return e.json.nodes.forEach((function(e){var n=e.extras;r.isSome(n)&&(n.ESRI_proxyEllipsoid||n.ESRI_lod)&&(t=n)})),t}function u(e,t){return n.__awaiter(this,void 0,void 0,(function(){function r(o,i){return n.__awaiter(this,void 0,void 0,(function(){var s,l,c,d,u,m,p;return n.__generator(this,(function(n){switch(n.label){case 0:if(s=a.nodes[o],l=e.getNodeTransform(o),v.warnUnsupportedIf(null!=s.weights,"Morph targets are not supported."),null==s.mesh)return[3,4];d=0,u=(c=a.meshes[s.mesh]).primitives,n.label=1;case 1:return d<u.length?[4,t(u[d],l,i,c.name)]:[3,4];case 2:n.sent(),n.label=3;case 3:return d++,[3,1];case 4:m=0,p=s.children||[],n.label=5;case 5:return m<p.length?[4,r(p[m],i)]:[3,8];case 6:n.sent(),n.label=7;case 7:return m++,[3,5];case 8:return[2]}}))}))}var a,i,s,l,c,d,u,m;return n.__generator(this,(function(t){switch(t.label){case 0:s=(i=(a=e.json).scenes[a.scene||0].nodes).length>1,l=0,c=i,t.label=1;case 1:return l<c.length?(u=a.nodes[d=c[l]],m=[r(d,0)],function(e){return e.extensions&&e.extensions.MSFT_lod&&Array.isArray(e.extensions.MSFT_lod.ids)}(u)&&!s&&m.push.apply(m,u.extensions.MSFT_lod.ids.map((function(e,t){return r(e,t+1)}))),[4,o.all(m)]):[3,4];case 2:t.sent(),t.label=3;case 3:return l++,[3,1];case 4:return[2]}}))}))}function m(e){if(33071===e||33648===e||10497===e)return e;v.error("Unexpected TextureSampler WrapMode: "+e)}t.load=function(e,t,o){return void 0===o&&(o={}),n.__awaiter(this,void 0,void 0,(function(){var i,h,g,b,x=this;return n.__generator(this,(function(y){switch(y.label){case 0:return[4,l.Resource.load(e,v,t,o)];case 1:return i=y.sent(),h="gltf_"+c++,g={lods:[],materials:new Map,textures:new Map,meta:d(i)},b=!(!i.json.asset.extras||"symbolResource"!==i.json.asset.extras.ESRI_type),[4,u(i,(function(e,t,l,c){return n.__awaiter(x,void 0,void 0,(function(){var d,u,b,x,y,_,w,T,C,O,M;return n.__generator(this,(function(n){switch(n.label){case 0:return u=function(e){switch(e){case 4:case 5:case 6:return e;default:return null}}(d=void 0!==e.mode?e.mode:4),r.isNone(u)?(v.warnUnsupported("Unsupported primitive mode ("+f[d]+"). Skipping primitive."),[2]):i.hasPositions(e)?[4,i.getMaterial(e,o)]:(v.warn("Skipping primitive without POSITION vertex attribute."),[2]);case 1:return b=n.sent(),y={transform:a.mat4f64.clone(t)},_={},[4,i.getPositionData(e,o)];case 2:return y.attributes=(_.position=n.sent(),_.normal=null,_.texCoord0=null,_.color=null,_.tangent=null,_),[4,i.getIndexData(e,o)];case 3:return y.indices=n.sent(),y.primitiveType=u,y.material=function(e,t,n){var r=function(t){var r=n+"_tex_"+(t&&t.id)+(t&&t.name?"_"+t.name:"");if(t&&!e.textures.has(r)){var o=s.makeTextureSource(t.data,{wrap:{s:m(t.wrapS),t:m(t.wrapT)},mipmap:p.some((function(e){return e===t.minFilter})),noUnpackFlip:!0});e.textures.set(r,o)}return r},o=n+"_mat_"+t.id+"_"+t.name;if(!e.materials.has(o)){var a=s.makeMaterialParameters({color:[t.color[0],t.color[1],t.color[2]],opacity:t.color[3],alphaMode:t.alphaMode,alphaCutoff:t.alphaCutoff,doubleSided:t.doubleSided,colorMixMode:t.ESRI_externalColorMixMode,textureColor:t.colorTexture?r(t.colorTexture):void 0,textureNormal:t.normalTexture?r(t.normalTexture):void 0,textureOcclusion:t.occlusionTexture?r(t.occlusionTexture):void 0,textureEmissive:t.emissiveTexture?r(t.emissiveTexture):void 0,textureMetallicRoughness:t.metallicRoughnessTexture?r(t.metallicRoughnessTexture):void 0,emissiveFactor:[t.emissiveFactor[0],t.emissiveFactor[1],t.emissiveFactor[2]],metallicFactor:t.metallicFactor,roughnessFactor:t.roughnessFactor});e.materials.set(o,a)}return o}(g,b,h),x=y,i.hasNormals(e)?(w=x.attributes,[4,i.getNormalData(e,o)]):[3,5];case 4:w.normal=n.sent(),n.label=5;case 5:return i.hasTangents(e)?(T=x.attributes,[4,i.getTangentData(e,o)]):[3,7];case 6:T.tangent=n.sent(),n.label=7;case 7:return i.hasTextureCoordinates(e)?(C=x.attributes,[4,i.getTextureCoordinates(e,o)]):[3,9];case 8:C.texCoord0=n.sent(),n.label=9;case 9:return i.hasVertexColors(e)?(O=x.attributes,[4,i.getVertexColors(e,o)]):[3,11];case 10:O.color=n.sent(),n.label=11;case 11:return M=null,r.isSome(g.meta)&&r.isSome(g.meta.ESRI_lod)&&"screenSpaceRadius"===g.meta.ESRI_lod.metric&&(M=g.meta.ESRI_lod.thresholds[l]),g.lods[l]=g.lods[l]||{parts:[],name:c,lodThreshold:M},g.lods[l].parts.push(x),[2]}}))}))}))];case 2:return y.sent(),[2,{model:g,meta:{isEsriSymbolResource:b,uri:i.uri},customMeta:{}}]}}))}))};var v=new i.DefaultErrorContext,p=[9987,9985],f=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"]}).apply(null,r))||(e.exports=o)},lF8C:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o,a,i;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureCoordinateAttribute=void 0,t.TextureCoordinateAttribute=function(e,t){1===t.attributeTextureCoordinates&&(e.attributes.add("uv0","vec2"),e.varyings.add("vuv0","vec2"),e.vertex.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n      }\n    "],["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n      }\n    "]))))),2===t.attributeTextureCoordinates&&(e.attributes.add("uv0","vec2"),e.varyings.add("vuv0","vec2"),e.attributes.add("uvRegion","vec4"),e.varyings.add("vuvRegion","vec4"),e.vertex.code.add(r.glsl(a||(a=n.__makeTemplateObject(["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n        vuvRegion = uvRegion;\n      }\n    "],["\n      void forwardTextureCoordinates() {\n        vuv0 = uv0;\n        vuvRegion = uvRegion;\n      }\n    "]))))),0===t.attributeTextureCoordinates&&e.vertex.code.add(r.glsl(i||(i=n.__makeTemplateObject(["\n      void forwardTextureCoordinates() {}\n    "],["\n      void forwardTextureCoordinates() {}\n    "]))))}}).apply(null,r))||(e.exports=o)},m7Ki:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("Rdxj"),n("r0i9"),n("7Aei"),n("1f+t")],void 0===(o=(function(e,t,n,r,o,a,i){"use strict";function s(e,t){t.instanced&&t.instancedDoublePrecision&&(e.attributes.add("modelOriginHi","vec3"),e.attributes.add("modelOriginLo","vec3"),e.attributes.add("model","mat3"),e.attributes.add("modelNormal","mat3")),t.instancedDoublePrecision&&(e.vertex.include(o.DoublePrecision,t),e.vertex.uniforms.add("viewOriginHi","vec3"),e.vertex.uniforms.add("viewOriginLo","vec3"));var r=[a.glsl(l||(l=n.__makeTemplateObject(["\n    vec3 calculateVPos() {\n      ","\n    }\n    "],["\n    vec3 calculateVPos() {\n      ","\n    }\n    "])),t.instancedDoublePrecision?"return model * localPosition().xyz;":"return localPosition().xyz;"),a.glsl(d||(d=n.__makeTemplateObject(["\n    vec3 subtractOrigin(vec3 _pos) {\n      ","\n    }\n    "],["\n    vec3 subtractOrigin(vec3 _pos) {\n      ","\n    }\n    "])),t.instancedDoublePrecision?a.glsl(c||(c=n.__makeTemplateObject(["\n          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          return _pos - originDelta;"],["\n          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          return _pos - originDelta;"]))):"return vpos;"),a.glsl(u||(u=n.__makeTemplateObject(["\n    vec3 dpNormal(vec4 _normal) {\n      ","\n    }\n    "],["\n    vec3 dpNormal(vec4 _normal) {\n      ","\n    }\n    "])),t.instancedDoublePrecision?"return normalize(modelNormal * _normal.xyz);":"return normalize(_normal.xyz);"),a.glsl(m||(m=n.__makeTemplateObject(["\n    vec3 dpNormalView(vec4 _normal) {\n      ","\n    }\n    "],["\n    vec3 dpNormalView(vec4 _normal) {\n      ","\n    }\n    "])),t.instancedDoublePrecision?"return normalize((viewNormal * vec4(modelNormal * _normal.xyz, 1.0)).xyz);":"return normalize((viewNormal * _normal).xyz);"),t.vertexTangets?a.glsl(v||(v=n.__makeTemplateObject(["\n    vec4 dpTransformVertexTangent(vec4 _tangent) {\n      ","\n\n    }\n    "],["\n    vec4 dpTransformVertexTangent(vec4 _tangent) {\n      ","\n\n    }\n    "])),t.instancedDoublePrecision?"return vec4(modelNormal * _tangent.xyz, _tangent.w);":"return _tangent;"):a.glsl(p||(p=n.__makeTemplateObject([""],[""])))];e.vertex.code.add(r[0]),e.vertex.code.add(r[1]),e.vertex.code.add(r[2]),2===t.output&&e.vertex.code.add(r[3]),e.vertex.code.add(r[4])}Object.defineProperty(t,"__esModule",{value:!0}),t.InstancedDoublePrecision=void 0,t.InstancedDoublePrecision=s,function(e){e.Uniforms=function(){},e.bindCustomOrigin=function(e,t){i.encodeDoubleArraySplit(t,f,h,3),e.setUniform3fv("viewOriginHi",f),e.setUniform3fv("viewOriginLo",h)}}(s=t.InstancedDoublePrecision||(t.InstancedDoublePrecision={}));var l,c,d,u,m,v,p,f=r.vec3f64.create(),h=r.vec3f64.create()}).apply(null,r))||(e.exports=o)},mOGR:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("lF8C"),n("nJqw"),n("7Aei")],void 0===(o=(function(e,t,n,r,o,a){"use strict";var i,s,l;Object.defineProperty(t,"__esModule",{value:!0}),t.VertexTextureCoordinates=void 0,t.VertexTextureCoordinates=function(e,t){e.include(r.TextureCoordinateAttribute,t),e.fragment.code.add(a.glsl(i||(i=n.__makeTemplateObject(["\n  struct TextureLookupParameter {\n    vec2 uv;\n    ","\n  } vtc;\n  "],["\n  struct TextureLookupParameter {\n    vec2 uv;\n    ","\n  } vtc;\n  "])),t.supportsTextureAtlas?"vec2 size;":"")),1===t.attributeTextureCoordinates&&e.fragment.code.add(a.glsl(s||(s=n.__makeTemplateObject(["\n      vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return texture2D(tex, params.uv);\n      }\n    "],["\n      vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return texture2D(tex, params.uv);\n      }\n    "])))),2===t.attributeTextureCoordinates&&(e.include(o.TextureAtlasLookup),e.fragment.code.add(a.glsl(l||(l=n.__makeTemplateObject(["\n    vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return textureAtlasLookup(tex, params.size, params.uv, vuvRegion);\n      }\n    "],["\n    vec4 textureLookup(sampler2D tex, TextureLookupParameter params) {\n        return textureAtlasLookup(tex, params.size, params.uv, vuvRegion);\n      }\n    "])))))}}).apply(null,r))||(e.exports=o)},nJqw:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureAtlasLookup=void 0,t.TextureAtlasLookup=function(e){e.extensions.add("GL_EXT_shader_texture_lod"),e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n    #ifndef GL_EXT_shader_texture_lod\n      float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n        float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));\n        return max(0.0, 0.5 * log2(deltaMaxSqr));\n      }\n    #endif\n\n    vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {\n      //[umin, vmin, umax, vmax]\n      vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;\n      vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;\n\n      // calculate derivative of continuous texture coordinate\n      // to avoid mipmapping artifacts caused by manual wrapping in shader\n      vec2 dUVdx = dFdx(textureCoordinates) * atlasScale;\n      vec2 dUVdy = dFdy(textureCoordinates) * atlasScale;\n\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);\n      #else\n        // use bias to compensate for difference in automatic vs desired mipmap level\n        vec2 dUVdxAuto = dFdx(uvAtlas);\n        vec2 dUVdyAuto = dFdy(uvAtlas);\n        float mipMapLevel = calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);\n        float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);\n\n        return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);\n      #endif\n    }\n  "],["\n    #ifndef GL_EXT_shader_texture_lod\n      float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n        float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));\n        return max(0.0, 0.5 * log2(deltaMaxSqr));\n      }\n    #endif\n\n    vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {\n      //[umin, vmin, umax, vmax]\n      vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;\n      vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;\n\n      // calculate derivative of continuous texture coordinate\n      // to avoid mipmapping artifacts caused by manual wrapping in shader\n      vec2 dUVdx = dFdx(textureCoordinates) * atlasScale;\n      vec2 dUVdy = dFdy(textureCoordinates) * atlasScale;\n\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);\n      #else\n        // use bias to compensate for difference in automatic vs desired mipmap level\n        vec2 dUVdxAuto = dFdx(uvAtlas);\n        vec2 dUVdyAuto = dFdy(uvAtlas);\n        float mipMapLevel = calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);\n        float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);\n\n        return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);\n      #endif\n    }\n  "]))))}}).apply(null,r))||(e.exports=o)},nobt:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o;Object.defineProperty(t,"__esModule",{value:!0}),t.Offset=void 0,t.Offset=function(e){e.vertex.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n    vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {\n      vec3 camToVert = posWorld - camPosWorld;\n\n      bool isBackface = dot(camToVert, normalWorld) > 0.0;\n      if (isBackface) {\n        posClip.z += 0.0000003 * posClip.w;\n      }\n      return posClip;\n    }\n  "],["\n    vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {\n      vec3 camToVert = posWorld - camPosWorld;\n\n      bool isBackface = dot(camToVert, normalWorld) > 0.0;\n      if (isBackface) {\n        posClip.z += 0.0000003 * posClip.w;\n      }\n      return posClip;\n    }\n  "]))))}}).apply(null,r))||(e.exports=o)},r0i9:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("H1tY"),n("7Aei"),n("rxbe")],void 0===(o=(function(e,t,n,r,o,a){"use strict";var i,s;Object.defineProperty(t,"__esModule",{value:!0}),t.doublePrecisionRequiresObfuscation=t.DoublePrecision=void 0,t.DoublePrecision=function(e,t){e.code.add(o.glsl(t.doublePrecisionRequiresObfuscation?i||(i=n.__makeTemplateObject(["\n      vec3 dpPlusFrc(vec3 a, vec3 b) {\n        return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n      }\n\n      vec3 dpMinusFrc(vec3 a, vec3 b) {\n        return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n      }\n\n      // based on https://www.thasler.com/blog/blog/glsl-part2-emu\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = dpPlusFrc(hiA, hiB);\n        vec3 e = dpMinusFrc(t1, hiA);\n        vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n        return t1 + t2;\n      }\n    "],["\n      vec3 dpPlusFrc(vec3 a, vec3 b) {\n        return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n      }\n\n      vec3 dpMinusFrc(vec3 a, vec3 b) {\n        return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n      }\n\n      // based on https://www.thasler.com/blog/blog/glsl-part2-emu\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = dpPlusFrc(hiA, hiB);\n        vec3 e = dpMinusFrc(t1, hiA);\n        vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n        return t1 + t2;\n      }\n    "])):s||(s=n.__makeTemplateObject(["\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = hiA + hiB;\n        vec3 e = t1 - hiA;\n        vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n        return t1 + t2;\n      }\n    "],["\n      vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n        vec3 t1 = hiA + hiB;\n        vec3 e = t1 - hiA;\n        vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n        return t1 + t2;\n      }\n    "]))))},t.doublePrecisionRequiresObfuscation=function(e){return!!r("force-double-precision-obfuscation")||a.testWebGLDriver(e).doublePrecisionRequiresObfuscation}}).apply(null,r))||(e.exports=o)},rxbe:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("LxLY"),n("Rdxj"),n("DJpR"),n("1f+t"),n("CIy2")],void 0===(o=(function(e,t,n,r,o,a,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.clearTestWebGLDriver=t.testWebGLDriver=void 0;var s=function(){function e(e){this.context=e,this._doublePrecisionRequiresObfuscation=null}return Object.defineProperty(e.prototype,"doublePrecisionRequiresObfuscation",{get:function(){if(n.isNone(this._doublePrecisionRequiresObfuscation)){var e=c(this.context,!1),t=c(this.context,!0);this._doublePrecisionRequiresObfuscation=0!==e&&(0===t||e/t>5)}return this._doublePrecisionRequiresObfuscation},enumerable:!1,configurable:!0}),e}(),l=null;function c(e,t){var n=new o.FramebufferObject(e,{colorTarget:0,depthStencilTarget:0},{target:3553,wrapMode:33071,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1}),s=o.BufferObject.createVertex(e,35044,new Uint16Array([0,0,1,0,0,1,1,1])),l=new o.VertexArrayObject(e,{a_pos:0},{geometry:[{name:"a_pos",count:2,type:5123,offset:0,stride:4,normalized:!1}]},{geometry:s}),c=r.vec3f64.fromValues(5633261.287538229,2626832.878767164,1434988.0495278358),d=r.vec3f64.fromValues(5633271.46742708,2626873.6381334523,1434963.231608387),u=function(n,r){var i=new o.Program(e,"\n\n  precision highp float;\n\n  attribute vec2 a_pos;\n\n  uniform vec3 u_highA;\n  uniform vec3 u_lowA;\n  uniform vec3 u_highB;\n  uniform vec3 u_lowB;\n\n  varying vec4 v_color;\n\n  "+(t?"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION":"")+"\n\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\n\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n  }\n\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n  }\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = dpPlusFrc(hiA, hiB);\n    vec3 e = dpMinusFrc(t1, hiA);\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n    return t1 + t2;\n  }\n\n  #else\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = hiA + hiB;\n    vec3 e = t1 - hiA;\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n    return t1 + t2;\n  }\n\n  #endif\n\n  const float MAX_RGBA_FLOAT =\n    255.0 / 256.0 +\n    255.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n  vec4 float2rgba(const float value) {\n    // Make sure value is in the domain we can represent\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n    // Decompose value in 32bit fixed point parts represented as\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\n    // by a power of 256 (this removes the bits that are represented in the previous\n    // component) and then converts the fractional part to 8bits.\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n    // Convert uint8 values (from 0 to 255) to floating point representation for\n    // the shader\n    const float toU8AsFloat = 1.0 / 255.0;\n\n    return fixedPointU8 * toU8AsFloat;\n  }\n\n  void main() {\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\n\n    v_color = float2rgba(val.z / 25.0);\n\n    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n  }\n  ","\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ",{a_pos:0}),s=new Float32Array(6);a.encodeDoubleArray(n,s,3);var l=new Float32Array(6);return a.encodeDoubleArray(r,l,3),e.bindProgram(i),i.setUniform3f("u_highA",s[0],s[2],s[4]),i.setUniform3f("u_lowA",s[1],s[3],s[5]),i.setUniform3f("u_highB",l[0],l[2],l[4]),i.setUniform3f("u_lowB",l[1],l[3],l[5]),i}(c,d),m=e.getBoundFramebufferObject(),v=e.getViewport(),p=v.x,f=v.y,h=v.width,g=v.height;e.bindFramebuffer(n),e.setViewport(0,0,1,1),e.bindVAO(l),e.drawArrays(5,0,4);var b=new Uint8Array(4);n.readPixels(0,0,1,1,6408,5121,b),u.dispose(),l.dispose(!1),s.dispose(),n.dispose(),e.setViewport(p,f,h,g),e.bindFramebuffer(m);var x=(c[2]-d[2])/25,y=i.unpackFloatRGBA(b);return Math.abs(x-y)}t.testWebGLDriver=function(e){return(n.isNone(l)||l.context!==e)&&(l=new s(e)),l},t.clearTestWebGLDriver=function(e){n.isSome(l)&&l.context===e&&(l=null)}}).apply(null,r))||(e.exports=o)},uEh2:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("DKwL"),n("7Aei")],void 0===(o=(function(e,t,n,r,o){"use strict";var a,i;Object.defineProperty(t,"__esModule",{value:!0}),t.OutputDepth=void 0,t.OutputDepth=function(e,t){e.fragment.include(r.RgbaFloatEncoding),3===t.output?(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(o.glsl(a||(a=n.__makeTemplateObject(["\n      float _calculateFragDepth(const in float depth) {\n        // calc polygon offset\n        const float SLOPE_SCALE = 2.0;\n        const float BIAS = 2.0 * .000015259;    // 1 / (2^16 - 1)\n        float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n        float result = depth + SLOPE_SCALE * m + BIAS;\n        return clamp(result, .0, .999999);\n      }\n\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));\n      }\n    "],["\n      float _calculateFragDepth(const in float depth) {\n        // calc polygon offset\n        const float SLOPE_SCALE = 2.0;\n        const float BIAS = 2.0 * .000015259;    // 1 / (2^16 - 1)\n        float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n        float result = depth + SLOPE_SCALE * m + BIAS;\n        return clamp(result, .0, .999999);\n      }\n\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));\n      }\n    "]))))):1===t.output&&e.fragment.code.add(o.glsl(i||(i=n.__makeTemplateObject(["\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_linearDepth);\n      }\n    "],["\n      void outputDepth(float _linearDepth) {\n        gl_FragColor = float2rgba(_linearDepth);\n      }\n    "]))))}}).apply(null,r))||(e.exports=o)},uci5:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(o=(function(e,t,n,r){"use strict";var o;Object.defineProperty(t,"__esModule",{value:!0}),t.PositionAttribute=void 0,t.PositionAttribute=function(e){e.attributes.add("position","vec3"),e.vertex.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n    vec3 positionModel() { return position; }\n  "],["\n    vec3 positionModel() { return position; }\n  "]))))}}).apply(null,r))||(e.exports=o)},w00x:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("ma1f")],void 0===(o=(function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Version=void 0;var r=function(){function e(e,t,n){void 0===n&&(n=""),this.major=e,this.minor=t,this._context=n}return e.prototype.lessThan=function(e,t){return this.major<e||e===this.major&&this.minor<t},e.prototype.since=function(e,t){return!this.lessThan(e,t)},e.prototype.validate=function(e){if(this.major!==e.major)throw new n((this._context&&this._context+":")+"unsupported-version","Required major "+(this._context&&this._context+" ")+"version is '"+this.major+"', but got '${version.major}.${version.minor}'",{version:e})},e.prototype.clone=function(){return new e(this.major,this.minor,this._context)},e.parse=function(t,r){void 0===r&&(r="");var o=t.split("."),a=o[0],i=o[1],s=/^\s*\d+\s*$/;if(!a||!a.match||!a.match(s))throw new n((r&&r+":")+"invalid-version","Expected major version to be a number, but got '${version}'",{version:t});if(!i||!i.match||!i.match(s))throw new n((r&&r+":")+"invalid-version","Expected minor version to be a number, but got '${version}'",{version:t});return new e(parseInt(a,10),parseInt(i,10),r)},e}();t.Version=r}).apply(null,r))||(e.exports=o)},wR99:function(e,t,n){var r,o;r=[n.dj.c(e.i),t],void 0===(o=(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BinaryStreamReader=void 0;var n=function(){function e(e){this.data=e,this.offset4=0,this.dataUint32=new Uint32Array(this.data,0,Math.floor(this.data.byteLength/4))}return e.prototype.readUint32=function(){var e=this.offset4;return this.offset4+=1,this.dataUint32[e]},e.prototype.readUint8Array=function(e){var t=4*this.offset4;return this.offset4+=e/4,new Uint8Array(this.data,t,e)},e.prototype.remainingBytes=function(){return this.data.byteLength-4*this.offset4},e}();t.BinaryStreamReader=n}).apply(null,r))||(e.exports=o)},zdOl:function(e,t,n){var r,o;r=[n.dj.c(e.i),t,n("zOht"),n("vlC2"),n("mOGR"),n("7Aei")],void 0===(o=(function(e,t,n,r,o,a){"use strict";function i(e,t){var r=e.fragment,i=t.hasMetalnessAndRoughnessTexture||t.hasEmissionTexture||t.hasOcclusionTexture;1===t.pbrMode&&i&&e.include(o.VertexTextureCoordinates,t),2!==t.pbrMode?(0===t.pbrMode&&r.code.add(a.glsl(l||(l=n.__makeTemplateObject(["\n      float getBakedOcclusion() { return 1.0; }\n  "],["\n      float getBakedOcclusion() { return 1.0; }\n  "])))),1===t.pbrMode&&(r.uniforms.add("emissionFactor","vec3"),r.uniforms.add("mrrFactors","vec3"),r.code.add(a.glsl(c||(c=n.__makeTemplateObject(["\n      vec3 mrr;\n      vec3 emission;\n      float occlusion;\n    "],["\n      vec3 mrr;\n      vec3 emission;\n      float occlusion;\n    "])))),t.hasMetalnessAndRoughnessTexture&&(r.uniforms.add("texMetallicRoughness","sampler2D"),t.supportsTextureAtlas&&r.uniforms.add("texMetallicRoughnessSize","vec2"),r.code.add(a.glsl(d||(d=n.__makeTemplateObject(["\n      void applyMetallnessAndRoughness(TextureLookupParameter params) {\n        vec3 metallicRoughness = textureLookup(texMetallicRoughness, params).rgb;\n\n        mrr[0] *= metallicRoughness.b;\n        mrr[1] *= metallicRoughness.g;\n      }"],["\n      void applyMetallnessAndRoughness(TextureLookupParameter params) {\n        vec3 metallicRoughness = textureLookup(texMetallicRoughness, params).rgb;\n\n        mrr[0] *= metallicRoughness.b;\n        mrr[1] *= metallicRoughness.g;\n      }"]))))),t.hasEmissionTexture&&(r.uniforms.add("texEmission","sampler2D"),t.supportsTextureAtlas&&r.uniforms.add("texEmissionSize","vec2"),r.code.add(a.glsl(u||(u=n.__makeTemplateObject(["\n      void applyEmission(TextureLookupParameter params) {\n        emission *= textureLookup(texEmission, params).rgb;\n      }"],["\n      void applyEmission(TextureLookupParameter params) {\n        emission *= textureLookup(texEmission, params).rgb;\n      }"]))))),t.hasOcclusionTexture?(r.uniforms.add("texOcclusion","sampler2D"),t.supportsTextureAtlas&&r.uniforms.add("texOcclusionSize","vec2"),r.code.add(a.glsl(m||(m=n.__makeTemplateObject(["\n      void applyOcclusion(TextureLookupParameter params) {\n        occlusion *= textureLookup(texOcclusion, params).r;\n      }\n\n      float getBakedOcclusion() {\n        return occlusion;\n      }\n      "],["\n      void applyOcclusion(TextureLookupParameter params) {\n        occlusion *= textureLookup(texOcclusion, params).r;\n      }\n\n      float getBakedOcclusion() {\n        return occlusion;\n      }\n      "]))))):r.code.add(a.glsl(v||(v=n.__makeTemplateObject(["\n      float getBakedOcclusion() { return 1.0; }\n      "],["\n      float getBakedOcclusion() { return 1.0; }\n      "])))),r.code.add(a.glsl(p||(p=n.__makeTemplateObject(["\n    void applyPBRFactors() {\n      mrr = mrrFactors;\n      emission = emissionFactor;\n      occlusion = 1.0;\n      ","\n      ","\n      ","\n      ","\n    }\n  "],["\n    void applyPBRFactors() {\n      mrr = mrrFactors;\n      emission = emissionFactor;\n      occlusion = 1.0;\n      ","\n      ","\n      ","\n      ","\n    }\n  "])),i?"vtc.uv = vuv0;":"",t.hasMetalnessAndRoughnessTexture?t.supportsTextureAtlas?"vtc.size = texMetallicRoughnessSize; applyMetallnessAndRoughness(vtc);":"applyMetallnessAndRoughness(vtc);":"",t.hasEmissionTexture?t.supportsTextureAtlas?"vtc.size = texEmissionSize; applyEmission(vtc);":"applyEmission(vtc);":"",t.hasOcclusionTexture?t.supportsTextureAtlas?"vtc.size = texOcclusionSize; applyOcclusion(vtc);":"applyOcclusion(vtc);":"")))):r.code.add(a.glsl(s||(s=n.__makeTemplateObject(["\n      const vec3 mrr = vec3(0.0, 0.6, 0.2);\n      const vec3 emission = vec3(0.0);\n      float occlusion = 1.0;\n\n      void applyPBRFactors() {}\n\n      float getBakedOcclusion() { return 1.0; }\n    "],["\n      const vec3 mrr = vec3(0.0, 0.6, 0.2);\n      const vec3 emission = vec3(0.0);\n      float occlusion = 1.0;\n\n      void applyPBRFactors() {}\n\n      float getBakedOcclusion() { return 1.0; }\n    "]))))}var s,l,c,d,u,m,v,p;Object.defineProperty(t,"__esModule",{value:!0}),t.PhysicallyBasedRenderingParameters=t.PBRSchematicMRRValues=void 0,t.PBRSchematicMRRValues=r.vec3f32.fromValues(0,.6,.2),t.PhysicallyBasedRenderingParameters=i,function(e){e.bindUniforms=function(e,t,n){void 0===n&&(n=!1),n||(e.setUniform3fv("mrrFactors",t.mrrFactors),e.setUniform3fv("emissionFactor",t.emissiveFactor))}}(i=t.PhysicallyBasedRenderingParameters||(t.PhysicallyBasedRenderingParameters={}))}).apply(null,r))||(e.exports=o)}}]);