(function(){var e={"arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl":"2o+p","arcgis-js-api/views/3d/webgl-engine/lib/GLMaterialTexture":"9FJH","arcgis-js-api/views/3d/webgl-engine/lib/DefaultTextureUnits":"EiD/","arcgis-js-api/views/3d/webgl-engine/lib/DDSUtil":"EyQ4","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl":"cj3m","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl":"cmSR","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl":"juLw","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl":"piY7","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl":"rCq5","arcgis-js-api/views/3d/support/imageUtils":"weRx","arcgis-js-api/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl":"xDGw","arcgis-js-api/views/3d/webgl-engine/lib/Texture":"yqrJ"},t=this||window,n=t.webpackJsonp=t.webpackJsonp||[];n.registerAbsMids?n.registerAbsMids(e):(n.absMidsWaiting=n.absMidsWaiting||[]).push(e)})(),(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{"2o+p":function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("7Aei"),n("s6rJ")],void 0===(r=(function(e,t,n,a,r){"use strict";function i(e){e.vertex.code.add(a.glsl(o||(o=n.__makeTemplateObject(["\n    float screenSizePerspectiveMinSize(float size, vec4 factor) {\n      float nonZeroSize = 1.0 - step(size, 0.0);\n\n      return (\n        factor.z * (\n          1.0 +\n          // Multiply by nzs ensures if size is 0, then we ignore proportionally scaled padding\n          nonZeroSize *\n          2.0 * factor.w / (\n            size + (1.0 - nonZeroSize) // Adding 1 - nzs ensures we divide either by size, or by 1\n          )\n        )\n      );\n    }\n  "],["\n    float screenSizePerspectiveMinSize(float size, vec4 factor) {\n      float nonZeroSize = 1.0 - step(size, 0.0);\n\n      return (\n        factor.z * (\n          1.0 +\n          // Multiply by nzs ensures if size is 0, then we ignore proportionally scaled padding\n          nonZeroSize *\n          2.0 * factor.w / (\n            size + (1.0 - nonZeroSize) // Adding 1 - nzs ensures we divide either by size, or by 1\n          )\n        )\n      );\n    }\n  "])))),e.vertex.code.add(a.glsl(s||(s=n.__makeTemplateObject(["\n    float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n      return absCosAngle * absCosAngle * absCosAngle;\n    }\n  "],["\n    float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n      return absCosAngle * absCosAngle * absCosAngle;\n    }\n  "])))),e.vertex.code.add(a.glsl(l||(l=n.__makeTemplateObject(["\n    vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n      return vec4(\n        min(params.x / (distanceToCamera - params.y), 1.0),\n        screenSizePerspectiveViewAngleDependentFactor(absCosAngle),\n        params.z,\n        params.w\n      );\n    }\n  "],["\n    vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n      return vec4(\n        min(params.x / (distanceToCamera - params.y), 1.0),\n        screenSizePerspectiveViewAngleDependentFactor(absCosAngle),\n        params.z,\n        params.w\n      );\n    }\n  "])))),e.vertex.code.add(a.glsl(c||(c=n.__makeTemplateObject(["\n    float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n      return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n    }\n  "],["\n    float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n      return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n    }\n  "])))),e.vertex.code.add(a.glsl(d||(d=n.__makeTemplateObject(["\n    float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorFloat(\n        size,\n        screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)\n      );\n    }\n  "],["\n    float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorFloat(\n        size,\n        screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)\n      );\n    }\n  "])))),e.vertex.code.add(a.glsl(u||(u=n.__makeTemplateObject(["\n    vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n      return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n    }\n  "],["\n    vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n      return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n    }\n  "])))),e.vertex.code.add(a.glsl(f||(f=n.__makeTemplateObject(["\n    vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "],["\n    vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n      return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n    }\n  "]))))}var o,s,l,c,d,u,f;Object.defineProperty(t,"__esModule",{value:!0}),t.ScreenSizePerspective=void 0,t.ScreenSizePerspective=i,function(e){e.bindUniforms=function(e,t){t.screenSizePerspective&&(r.bindScreenSizePerspective(t.screenSizePerspective,e,"screenSizePerspective"),r.bindScreenSizePerspective(t.screenSizePerspectiveAlignment||t.screenSizePerspective,e,"screenSizePerspectiveAlignment"))}}(i=t.ScreenSizePerspective||(t.ScreenSizePerspective={}))}).apply(null,a))||(e.exports=r)},"9FJH":function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("LxLY"),n("EiD/"),n("tUyH")],void 0===(r=(function(e,t,n,a,r,i){"use strict";return function(e){function t(t){var n=e.call(this,t)||this;return n._textureIDs=new Set,n._textureRepository=t.textureRep,n._textureId=t.textureId,n._initTransparent=!!t.initTextureTransparent,n._texture=n._acquireIfNotUndefined(n._textureId),n._textureNormal=n._acquireIfNotUndefined(t.normalTextureId),n._textureEmissive=n._acquireIfNotUndefined(t.emissiveTextureId),n._textureOcclusion=n._acquireIfNotUndefined(t.occlusionTextureId),n._textureMetallicRoughness=n._acquireIfNotUndefined(t.metallicRoughnessTextureId),n}return n.__extends(t,e),t.prototype.dispose=function(){var e=this;this._textureIDs.forEach((function(t){return e._textureRepository.release(t)})),this._textureIDs.clear()},t.prototype.updateTexture=function(e){e!==this._textureId&&(this._releaseIfNotUndefined(this._textureId),this._textureId=e,this._texture=this._acquireIfNotUndefined(this._textureId))},t.prototype.bindTexture=function(e,t){a.isSome(this._texture)&&(t.setUniform1i("tex",r.DefaultTextureUnits.DIFFUSE),e.bindTexture(this._texture.glTexture,r.DefaultTextureUnits.DIFFUSE)),a.isSome(this._textureNormal)&&(t.setUniform1i("normalTexture",r.DefaultTextureUnits.NORMAL),e.bindTexture(this._textureNormal.glTexture,r.DefaultTextureUnits.NORMAL)),a.isSome(this._textureEmissive)&&(t.setUniform1i("texEmission",r.DefaultTextureUnits.EMISSION),e.bindTexture(this._textureEmissive.glTexture,r.DefaultTextureUnits.EMISSION)),a.isSome(this._textureOcclusion)&&(t.setUniform1i("texOcclusion",r.DefaultTextureUnits.OCCLUSION),e.bindTexture(this._textureOcclusion.glTexture,r.DefaultTextureUnits.OCCLUSION)),a.isSome(this._textureMetallicRoughness)&&(t.setUniform1i("texMetallicRoughness",r.DefaultTextureUnits.METALLIC_ROUGHNESS),e.bindTexture(this._textureMetallicRoughness.glTexture,r.DefaultTextureUnits.METALLIC_ROUGHNESS))},t.prototype.bindTextureScale=function(e,t){var n=a.isSome(this._texture)&&this._texture.glTexture;n&&n.descriptor.textureCoordinateScaleFactor?t.setUniform2fv("textureCoordinateScaleFactor",n.descriptor.textureCoordinateScaleFactor):t.setUniform2f("textureCoordinateScaleFactor",1,1)},t.prototype._acquireIfNotUndefined=function(e){if(!a.isNone(e))return this._textureIDs.add(e),this._textureRepository.acquire(e,this._initTransparent)},t.prototype._releaseIfNotUndefined=function(e){void 0!==e&&(this._textureIDs.delete(e),this._textureRepository.release(e))},t}(i.GLMaterial)}).apply(null,a))||(e.exports=r)},"EiD/":function(e,t,n){var a,r;a=[n.dj.c(e.i),t],void 0===(r=(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultTextureUnits=void 0,t.DefaultTextureUnits={DIFFUSE:0,NORMAL:1,EMISSION:2,OCCLUSION:3,METALLIC_ROUGHNESS:4,SSAO:6,SHADOW_MAP:7}}).apply(null,a))||(e.exports=r)},EyQ4:function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("qsST"),n("xoE+"),n("Zp3t")],void 0===(r=(function(e,t,n,a,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createDDSTextureData=t.createDDSTexture=void 0;var i=n.getLogger("esri.views.3d.webgl-engine.lib.DDSUtil");function o(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}var s=o("DXT1"),l=o("DXT3"),c=o("DXT5");function d(e,t){var n=new Int32Array(e,0,31);if(542327876!==n[0])return i.error("Invalid magic number in DDS header"),null;if(!(4&n[20]))return i.error("Unsupported format, must contain a FourCC code"),null;var r,o,d,u=n[21];switch(u){case s:r=8,o=33776;break;case l:r=16,o=33778;break;case c:r=16,o=33779;break;default:return i.error("Unsupported FourCC code:",(d=u,String.fromCharCode(255&d,d>>8&255,d>>16&255,d>>24&255))),null}var f=1,p=n[4],h=n[3];0==(3&p)&&0==(3&h)||(i.warn("Rounding up compressed texture size to nearest multiple of 4."),p=p+3&-4,h=h+3&-4);var m,v,g=p,x=h;131072&n[2]&&!1!==t&&(f=Math.max(1,n[7])),1===f||a.isPowerOfTwo(p)&&a.isPowerOfTwo(h)||(i.warn("Ignoring mipmaps of non power of two sized compressed texture."),f=1);for(var w=n[1]+4,b=[],S=0;S<f;++S)v=(p+3>>2)*(h+3>>2)*r,m=new Uint8Array(e,w,v),b.push(m),w+=v,p=Math.max(1,p>>1),h=Math.max(1,h>>1);return{textureData:{type:"compressed",levels:b},internalFormat:o,width:g,height:x}}t.createDDSTexture=function(e,t,n,a){var i=d(n,a),o=i.textureData,s=i.internalFormat,l=i.width,c=i.height;t.samplingMode=o.levels.length>1?9987:9729,t.hasMipmap=o.levels.length>1,t.internalFormat=s,t.width=l,t.height=c;var u=new r(e,t,o);return e.bindTexture(u),u},t.createDDSTextureData=d}).apply(null,a))||(e.exports=r)},cj3m:function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("DKwL"),n("7Aei")],void 0===(r=(function(e,t,n,a,r){"use strict";function i(e){e.fragment.include(a.RgbaFloatEncoding),e.fragment.uniforms.add("depthTex","sampler2D"),e.fragment.uniforms.add("shadowMapNum","int"),e.fragment.uniforms.add("shadowMapDistance","vec4"),e.fragment.uniforms.add("shadowMapMatrix","mat4",4),e.fragment.uniforms.add("depthHalfPixelSz","float"),e.fragment.code.add(r.glsl(o||(o=n.__makeTemplateObject(["\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      float halfPixelSize = depthHalfPixelSz;\n      vec4 distance = shadowMapDistance;\n      float depth = _linearDepth;\n\n      //choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      if (i >= shadowMapNum) { return 0.0; }\n\n      mat4 mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n\n      // vertex completely outside? -> no shadow\n      vec3 lvpos = 0.5 * lv.xyz + vec3(0.5);\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n\n      float texSize = 0.5 / halfPixelSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\n\n      float s00 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s10 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s11 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s01 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n  "],["\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      float halfPixelSize = depthHalfPixelSz;\n      vec4 distance = shadowMapDistance;\n      float depth = _linearDepth;\n\n      //choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      if (i >= shadowMapNum) { return 0.0; }\n\n      mat4 mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n\n      // vertex completely outside? -> no shadow\n      vec3 lvpos = 0.5 * lv.xyz + vec3(0.5);\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n\n      float texSize = 0.5 / halfPixelSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\n\n      float s00 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s10 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s11 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s01 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n  "]))))}var o;Object.defineProperty(t,"__esModule",{value:!0}),t.ReadShadowMap=void 0,t.ReadShadowMap=i,function(e){e.bindUniforms=function(e,t,n){t.shadowMappingEnabled&&(t.shadowMap.bind(e,n),t.shadowMap.bindView(e,t.origin))},e.bindViewCustomOrigin=function(e,t,n){t.shadowMappingEnabled&&t.shadowMap.bindView(e,n)},e.bindView=function(e,t){t.shadowMappingEnabled&&t.shadowMap.bindView(e,t.origin)}}(i=t.ReadShadowMap||(t.ReadShadowMap={}))}).apply(null,a))||(e.exports=r)},cmSR:function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(r=(function(e,t,n,a){"use strict";var r,i,o;Object.defineProperty(t,"__esModule",{value:!0}),t.ForwardLinearDepth=void 0,t.ForwardLinearDepth=function(e,t){0===t.output&&t.receiveShadows?(e.varyings.add("linearDepth","float"),e.vertex.code.add(a.glsl(r||(r=n.__makeTemplateObject(["\n      void forwardLinearDepth() { linearDepth = gl_Position.w; }\n    "],["\n      void forwardLinearDepth() { linearDepth = gl_Position.w; }\n    "]))))):1===t.output||3===t.output?(e.varyings.add("linearDepth","float"),e.vertex.uniforms.add("uCameraNearFar","vec2"),e.vertex.code.add(a.glsl(i||(i=n.__makeTemplateObject(["\n      void forwardLinearDepth() {\n        linearDepth = (-position_view().z - uCameraNearFar[0]) / (uCameraNearFar[1] - uCameraNearFar[0]);\n      }\n    "],["\n      void forwardLinearDepth() {\n        linearDepth = (-position_view().z - uCameraNearFar[0]) / (uCameraNearFar[1] - uCameraNearFar[0]);\n      }\n    "]))))):e.vertex.code.add(a.glsl(o||(o=n.__makeTemplateObject(["\n      void forwardLinearDepth() {}\n    "],["\n      void forwardLinearDepth() {}\n    "]))))}}).apply(null,a))||(e.exports=r)},juLw:function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(r=(function(e,t,n,a){"use strict";var r,i,o;Object.defineProperty(t,"__esModule",{value:!0}),t.AnalyticalSkyModel=void 0,t.AnalyticalSkyModel=function(e){var t=e.fragment.code;t.add(a.glsl(r||(r=n.__makeTemplateObject(["\n    vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)\n    {\n      return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n    }\n    "],["\n    vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)\n    {\n      return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n    }\n    "])))),t.add(a.glsl(i||(i=n.__makeTemplateObject(["\n    float integratedRadiance(float cosTheta2, float roughness)\n    {\n      return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);\n    }\n    "],["\n    float integratedRadiance(float cosTheta2, float roughness)\n    {\n      return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);\n    }\n    "])))),t.add(a.glsl(o||(o=n.__makeTemplateObject(["\n    vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)\n    {\n      float cosTheta2 = 1.0 - RdotNG * RdotNG;\n      float intRadTheta = integratedRadiance(cosTheta2, roughness);\n\n      // Calculate the integrated directional radiance of the ground and the sky\n      float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;\n      float sky = 2.0 - ground;\n      return (ground * ambientGround + sky * ambientSky) * 0.5;\n    }\n    "],["\n    vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)\n    {\n      float cosTheta2 = 1.0 - RdotNG * RdotNG;\n      float intRadTheta = integratedRadiance(cosTheta2, roughness);\n\n      // Calculate the integrated directional radiance of the ground and the sky\n      float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;\n      float sky = 2.0 - ground;\n      return (ground * ambientGround + sky * ambientSky) * 0.5;\n    }\n    "]))))}}).apply(null,a))||(e.exports=r)},piY7:function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("juLw"),n("quQL"),n("7Aei")],void 0===(r=(function(e,t,n,a,r,i){"use strict";var o,s,l,c,d,u,f,p,h,m,v;Object.defineProperty(t,"__esModule",{value:!0}),t.PhysicallyBasedRendering=void 0,t.PhysicallyBasedRendering=function(e,t){var g=e.fragment.code;e.include(r.PiUtils),3===t.pbrMode||4===t.pbrMode?(g.add(i.glsl(o||(o=n.__makeTemplateObject(["\n    struct PBRShadingWater\n    {\n        float NdotL;   // cos angle between normal and light direction\n        float NdotV;   // cos angle between normal and view direction\n        float NdotH;   // cos angle between normal and half vector\n        float VdotH;   // cos angle between view direction and half vector\n        float LdotH;   // cos angle between light direction and half vector\n        float VdotN;   // cos angle between view direction and normal vector\n    };\n\n    float dtrExponent = ",";\n    "],["\n    struct PBRShadingWater\n    {\n        float NdotL;   // cos angle between normal and light direction\n        float NdotV;   // cos angle between normal and view direction\n        float NdotH;   // cos angle between normal and half vector\n        float VdotH;   // cos angle between view direction and half vector\n        float LdotH;   // cos angle between light direction and half vector\n        float VdotN;   // cos angle between view direction and normal vector\n    };\n\n    float dtrExponent = ",";\n    "])),t.useCustomDTRExponentForWater?"2.2":"2.0")),g.add(i.glsl(s||(s=n.__makeTemplateObject(["\n    vec3 fresnelReflection(float angle, vec3 f0, float f90) {\n      return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n    }\n    "],["\n    vec3 fresnelReflection(float angle, vec3 f0, float f90) {\n      return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n    }\n    "])))),g.add(i.glsl(l||(l=n.__makeTemplateObject(["\n    float normalDistributionWater(float NdotH, float roughness)\n    {\n      float r2 = roughness * roughness;\n      float NdotH2 = NdotH * NdotH;\n      float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;\n      return r2 / denom;\n    }\n    "],["\n    float normalDistributionWater(float NdotH, float roughness)\n    {\n      float r2 = roughness * roughness;\n      float NdotH2 = NdotH * NdotH;\n      float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;\n      return r2 / denom;\n    }\n    "])))),g.add(i.glsl(c||(c=n.__makeTemplateObject(["\n    float geometricOcclusionKelemen(float LoH)\n    {\n        return 0.25 / (LoH * LoH);\n    }\n    "],["\n    float geometricOcclusionKelemen(float LoH)\n    {\n        return 0.25 / (LoH * LoH);\n    }\n    "])))),g.add(i.glsl(d||(d=n.__makeTemplateObject(["\n    vec3 brdfSpecularWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)\n    {\n      vec3  F = fresnelReflection(props.VdotH, F0, F0Max);\n      float dSun = normalDistributionWater(props.NdotH, roughness);\n      float V = geometricOcclusionKelemen(props.LdotH);\n\n      float diffusionSunHaze = mix(roughness + 0.045, roughness + 0.385, 1.0 - props.VdotH);\n      float strengthSunHaze  = 1.2;\n      float dSunHaze = normalDistributionWater(props.NdotH, diffusionSunHaze)*strengthSunHaze;\n\n      return ((dSun + dSunHaze) * V) * F;\n    }\n\n    vec3 tonemapACES(const vec3 x) {\n      return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n    }\n    "],["\n    vec3 brdfSpecularWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)\n    {\n      vec3  F = fresnelReflection(props.VdotH, F0, F0Max);\n      float dSun = normalDistributionWater(props.NdotH, roughness);\n      float V = geometricOcclusionKelemen(props.LdotH);\n\n      float diffusionSunHaze = mix(roughness + 0.045, roughness + 0.385, 1.0 - props.VdotH);\n      float strengthSunHaze  = 1.2;\n      float dSunHaze = normalDistributionWater(props.NdotH, diffusionSunHaze)*strengthSunHaze;\n\n      return ((dSun + dSunHaze) * V) * F;\n    }\n\n    vec3 tonemapACES(const vec3 x) {\n      return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n    }\n    "]))))):1!==t.pbrMode&&2!==t.pbrMode||(e.include(a.AnalyticalSkyModel),g.add(i.glsl(u||(u=n.__makeTemplateObject(["\n    struct PBRShadingInfo\n    {\n        float NdotL;                  // cos angle between normal and light direction\n        float NdotV;                  // cos angle between normal and view direction\n        float NdotH;                  // cos angle between normal and half vector\n        float VdotH;                  // cos angle between view direction and half vector\n        float LdotH;                  // cos angle between view light direction and half vector\n        float NdotNG;                 // cos angle between normal and normal of the ground\n        float RdotNG;                 // cos angle between view direction reflected of the normal and normal of the ground\n        float NdotAmbDir;             // cos angle between view direction and the fill light in ambient illumination\n        float NdotH_Horizon;          // cos angle between normal and half vector defined with horizon illumination\n        vec3 skyRadianceToSurface;         // integrated radiance of the sky based on the surface roughness (used for specular reflection)\n        vec3 groundRadianceToSurface;      // integrated radiance of the ground based on the surface roughness (used for specular reflection)\n        vec3 skyIrradianceToSurface;       // irradiance of the sky (used for diffuse reflection)\n        vec3 groundIrradianceToSurface;    // irradiance of the ground (used for diffuse reflection)\n\n        float averageAmbientRadiance;      // average ambient radiance used to deduce black level in gamut mapping\n        float ssao;                   // ssao coefficient\n        vec3 albedoLinear;            // linear color of the albedo\n        vec3 f0;                      // fresnel value at normal incident light\n        vec3 f90;                     // fresnel value at 90o of incident light\n\n        vec3 diffuseColor;            // diffuse color of the material used in environment illumination\n        float metalness;              // metalness of the material\n        float roughness;              // roughness of the material\n    };\n    "],["\n    struct PBRShadingInfo\n    {\n        float NdotL;                  // cos angle between normal and light direction\n        float NdotV;                  // cos angle between normal and view direction\n        float NdotH;                  // cos angle between normal and half vector\n        float VdotH;                  // cos angle between view direction and half vector\n        float LdotH;                  // cos angle between view light direction and half vector\n        float NdotNG;                 // cos angle between normal and normal of the ground\n        float RdotNG;                 // cos angle between view direction reflected of the normal and normal of the ground\n        float NdotAmbDir;             // cos angle between view direction and the fill light in ambient illumination\n        float NdotH_Horizon;          // cos angle between normal and half vector defined with horizon illumination\n        vec3 skyRadianceToSurface;         // integrated radiance of the sky based on the surface roughness (used for specular reflection)\n        vec3 groundRadianceToSurface;      // integrated radiance of the ground based on the surface roughness (used for specular reflection)\n        vec3 skyIrradianceToSurface;       // irradiance of the sky (used for diffuse reflection)\n        vec3 groundIrradianceToSurface;    // irradiance of the ground (used for diffuse reflection)\n\n        float averageAmbientRadiance;      // average ambient radiance used to deduce black level in gamut mapping\n        float ssao;                   // ssao coefficient\n        vec3 albedoLinear;            // linear color of the albedo\n        vec3 f0;                      // fresnel value at normal incident light\n        vec3 f90;                     // fresnel value at 90o of incident light\n\n        vec3 diffuseColor;            // diffuse color of the material used in environment illumination\n        float metalness;              // metalness of the material\n        float roughness;              // roughness of the material\n    };\n    "])))),g.add(i.glsl(f||(f=n.__makeTemplateObject(["\n    float normalDistribution(float NdotH, float roughness)\n    {\n        float a = NdotH * roughness;\n        float b = roughness / (1.0 - NdotH * NdotH + a * a);\n        return b * b * INV_PI;\n    }\n    "],["\n    float normalDistribution(float NdotH, float roughness)\n    {\n        float a = NdotH * roughness;\n        float b = roughness / (1.0 - NdotH * NdotH + a * a);\n        return b * b * INV_PI;\n    }\n    "])))),g.add(i.glsl(p||(p=n.__makeTemplateObject(["\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n    const vec2 c2 = vec2(-1.04, 1.04);\n\n    vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {\n        vec4 r = roughness * c0 + c1;\n        float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;\n        return c2 * a004 + r.zw;\n    }\n    "],["\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n    const vec2 c2 = vec2(-1.04, 1.04);\n\n    vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {\n        vec4 r = roughness * c0 + c1;\n        float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;\n        return c2 * a004 + r.zw;\n    }\n    "])))),g.add(i.glsl(h||(h=n.__makeTemplateObject(["\n    vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {\n      vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);\n      vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);\n\n      // From diffuse illumination calculate reflected color\n      vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;\n\n      // From specular illumination calculate reflected color\n      vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);\n      vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;\n      vec3 specularComponent = specularColor * indirectSpecular;\n\n      return (diffuseComponent + specularComponent);\n    }\n    "],["\n    vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {\n      vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);\n      vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);\n\n      // From diffuse illumination calculate reflected color\n      vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;\n\n      // From specular illumination calculate reflected color\n      vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);\n      vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;\n      vec3 specularComponent = specularColor * indirectSpecular;\n\n      return (diffuseComponent + specularComponent);\n    }\n    "])))),g.add(i.glsl(m||(m=n.__makeTemplateObject(["\n    float gamutMapChanel(float x, vec2 p){\n      return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );\n    }"],["\n    float gamutMapChanel(float x, vec2 p){\n      return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );\n    }"])))),g.add(i.glsl(v||(v=n.__makeTemplateObject(["\n    vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){\n      vec3 outColor;\n      vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));\n      outColor.x = gamutMapChanel(inColor.x, p) ;\n      outColor.y = gamutMapChanel(inColor.y, p) ;\n      outColor.z = gamutMapChanel(inColor.z, p) ;\n      return outColor;\n    }\n    "],["\n    vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){\n      vec3 outColor;\n      vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));\n      outColor.x = gamutMapChanel(inColor.x, p) ;\n      outColor.y = gamutMapChanel(inColor.y, p) ;\n      outColor.z = gamutMapChanel(inColor.z, p) ;\n      return outColor;\n    }\n    "])))))}}).apply(null,a))||(e.exports=r)},rCq5:function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("7Aei")],void 0===(r=(function(e,t,n,a){"use strict";var r;Object.defineProperty(t,"__esModule",{value:!0}),t.ColorConversion=void 0,t.ColorConversion=function(e){e.code.add(a.glsl(r||(r=n.__makeTemplateObject(["\n    vec4 premultiplyAlpha(vec4 v) {\n      return vec4(v.rgb * v.a, v.a);\n    }\n\n    // Note: the min in the last line has been added to fix an instability in chrome.\n    // See https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/23911\n    // With proper floating point handling, the value could never be >1.\n    vec3 rgb2hsv(vec3 c) {\n      vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n      vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n      vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n      float d = q.x - min(q.w, q.y);\n      float e = 1.0e-10;\n      return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n    }\n\n    vec3 hsv2rgb(vec3 c) {\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n\n    float rgb2v(vec3 c) {\n      return max(c.x, max(c.y, c.z));\n    }\n  "],["\n    vec4 premultiplyAlpha(vec4 v) {\n      return vec4(v.rgb * v.a, v.a);\n    }\n\n    // Note: the min in the last line has been added to fix an instability in chrome.\n    // See https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/23911\n    // With proper floating point handling, the value could never be >1.\n    vec3 rgb2hsv(vec3 c) {\n      vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n      vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n      vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n      float d = q.x - min(q.w, q.y);\n      float e = 1.0e-10;\n      return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n    }\n\n    vec3 hsv2rgb(vec3 c) {\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n\n    float rgb2v(vec3 c) {\n      return max(c.x, max(c.y, c.z));\n    }\n  "]))))}}).apply(null,a))||(e.exports=r)},weRx:function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("zp6E")],void 0===(r=(function(e,t,n,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.requestImage=void 0,t.requestImage=function(e,t){return a(e,n.__assign({responseType:"image"},t)).then((function(e){return e.data}))}}).apply(null,a))||(e.exports=r)},xDGw:function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("2o+p"),n("7Aei")],void 0===(r=(function(e,t,n,a,r){"use strict";function i(e,t){var i=e.vertex.code;t.verticalOffsetEnabled?(e.vertex.uniforms.add("verticalOffset","vec4"),t.screenSizePerspectiveEnabled&&(e.include(a.ScreenSizePerspective),e.vertex.uniforms.add("screenSizePerspectiveAlignment","vec4")),i.add(r.glsl(u||(u=n.__makeTemplateObject(["\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n      ","\n      ","\n      // Screen sized offset in world space, used for example for line callouts\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n\n    vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      return worldPos + calculateVerticalOffset(worldPos, localOrigin);\n    }\n    "],["\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n      ","\n      ","\n      // Screen sized offset in world space, used for example for line callouts\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n\n    vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      return worldPos + calculateVerticalOffset(worldPos, localOrigin);\n    }\n    "])),r.glsl(1===t.viewingMode?s||(s=n.__makeTemplateObject(["vec3 worldNormal = normalize(worldPos + localOrigin);"],["vec3 worldNormal = normalize(worldPos + localOrigin);"])):l||(l=n.__makeTemplateObject(["vec3 worldNormal = vec3(0.0, 0.0, 1.0);"],["vec3 worldNormal = vec3(0.0, 0.0, 1.0);"]))),r.glsl(t.screenSizePerspectiveEnabled?c||(c=n.__makeTemplateObject(["\n          float cosAngle = dot(worldNormal, normalize(worldPos - camPos));\n          float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);"],["\n          float cosAngle = dot(worldNormal, normalize(worldPos - camPos));\n          float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);"])):d||(d=n.__makeTemplateObject(["\n          float verticalOffsetScreenHeight = verticalOffset.x;"],["\n          float verticalOffsetScreenHeight = verticalOffset.x;"])))))):i.add(r.glsl(f||(f=n.__makeTemplateObject(["\n    vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }\n    "],["\n    vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }\n    "]))))}function o(e,t,n,a){return void 0===a&&(a=p),a.screenLength=e.screenLength,a.perDistance=Math.tan(.5*t)/(.5*n),a.minWorldLength=e.minWorldLength,a.maxWorldLength=e.maxWorldLength,a}Object.defineProperty(t,"__esModule",{value:!0}),t.calculateVerticalOffsetFactors=t.VerticalOffset=void 0,t.VerticalOffset=i,function(e){e.bindUniforms=function(e,t,n){if(t.verticalOffset){var a=o(t.verticalOffset,n.camera.fovY,n.camera.fullViewport[3]);e.setUniform4f("verticalOffset",a.screenLength*(n.camera.pixelRatio||1),a.perDistance,a.minWorldLength,a.maxWorldLength)}}}(i=t.VerticalOffset||(t.VerticalOffset={})),t.calculateVerticalOffsetFactors=o;var s,l,c,d,u,f,p={screenLength:0,perDistance:0,minWorldLength:0,maxWorldLength:0}}).apply(null,a))||(e.exports=r)},yqrJ:function(e,t,n){var a,r;a=[n.dj.c(e.i),t,n("zOht"),n("pcDC"),n("ma1f"),n("BcWh"),n("xoE+"),n("xoE+"),n("LxLY"),n("qMld"),n("rusB"),n("jfWY"),n("R6Tp"),n("weRx"),n("EyQ4"),n("/Bau"),n("W0kZ"),n("CIy2"),n("/f24"),n("Zp3t"),n("Kfys"),n("7laH")],void 0===(r=(function(e,t,n,a,r,i,o,s,l,c,d,u,f,p,h,m,v,g,x,w,b,S){"use strict";return function(){function e(t,n,a){this.data=t,this.glTexture=null,this.powerOfTwoStretchInfo=null,this.loadingPromise=null,this.loadingController=null,this.events=new i,this.data=t,this.id=e.idGen.gen(n),this.params=a||{},this.params.mipmap=!1!==this.params.mipmap,this.params.noUnpackFlip=this.params.noUnpackFlip||!1,this.params.preMultiplyAlpha=this.params.preMultiplyAlpha||!1,this.params.wrap=this.params.wrap||{s:10497,t:10497},this.params.powerOfTwoResizeMode=this.params.powerOfTwoResizeMode||1,this.estimatedTexMemRequired=e.estimateTexMemRequired(this.data,this.params),this.startPreload()}return e.prototype.startPreload=function(){var e=this.data;l.isNone(e)||(e instanceof HTMLVideoElement?this.startPreloadVideoElement(e):e instanceof HTMLImageElement&&this.startPreloadImageElement(e))},e.prototype.startPreloadVideoElement=function(e){u.isBlobProtocol(e.src)||"auto"===e.preload&&e.crossOrigin||(e.preload="auto",e.crossOrigin="anonymous",e.src=e.src)},e.prototype.startPreloadImageElement=function(e){u.isDataProtocol(e.src)||u.isBlobProtocol(e.src)||e.crossOrigin||(e.crossOrigin="anonymous",e.src=e.src)},e.getDataDimensions=function(e){return e instanceof HTMLVideoElement?{width:e.videoWidth,height:e.videoHeight}:e},e.estimateTexMemRequired=function(t,n){if(l.isNone(t))return 0;if(d.isArrayBuffer(t)||d.isUint8Array(t))return t.byteLength;var a=t instanceof Image||t instanceof ImageData||t instanceof HTMLCanvasElement||t instanceof HTMLVideoElement?e.getDataDimensions(t):n;return(n.mipmap?4/3:1)*a.width*a.height*(n.components||4)||0},e.prototype.dispose=function(){this.data=void 0},Object.defineProperty(e.prototype,"width",{get:function(){return this.params.width},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{get:function(){return this.params.height},enumerable:!1,configurable:!0}),e.prototype.createDescriptor=function(e){return{target:3553,pixelFormat:6408,dataType:5121,wrapMode:this.params.wrap,flipped:!this.params.noUnpackFlip,samplingMode:this.params.mipmap?9987:9729,hasMipmap:this.params.mipmap,preMultiplyAlpha:this.params.preMultiplyAlpha,maxAnisotropy:this.params.mipmap&&!this.params.disableAnisotropy?e.parameters.maxMaxAnisotropy:void 0}},e.prototype.load=function(t,n){if(l.isSome(this.glTexture))return this.glTexture;if(l.isSome(this.loadingPromise))return this.loadingPromise;var r=this.data;return l.isNone(r)?(this.glTexture=new w(t,this.createDescriptor(t),null),t.bindTexture(this.glTexture),this.glTexture):"string"==typeof r?this.loadFromURL(t,n,r):r instanceof Image?this.loadFromImageElement(t,n,r):r instanceof HTMLVideoElement?this.loadFromVideoElement(t,n,r):r instanceof ImageData||r instanceof HTMLCanvasElement?this.loadFromImage(t,r,n):(d.isArrayBuffer(r)||d.isUint8Array(r))&&this.params.encoding===e.DDS_ENCODING?this.loadFromDDSData(t,r):d.isUint8Array(r)?this.loadFromPixelData(t,r):d.isArrayBuffer(r)?this.loadFromPixelData(t,new Uint8Array(r)):(a.neverReachedSilent(r),null)},Object.defineProperty(e.prototype,"requiresFrameUpdates",{get:function(){return this.data instanceof HTMLVideoElement},enumerable:!1,configurable:!0}),e.prototype.frameUpdate=function(e,t,n){if(!(this.data instanceof HTMLVideoElement)||l.isNone(this.glTexture))return n;if(this.data.readyState<2||n===this.data.currentTime)return n;if(l.isSome(this.powerOfTwoStretchInfo)){var a=this.powerOfTwoStretchInfo,r=a.framebuffer,i=a.vao,o=a.sourceTexture;o.setData(this.data),this.drawStretchedTexture(e,t,r,i,o,this.glTexture)}else{var s=this.data,c=s.width,d=s.height,u=this.glTexture.descriptor,f=u.width,p=u.height;c!==f||d!==p?this.glTexture.updateData(0,0,0,Math.min(c,f),Math.min(d,p),this.data):this.glTexture.setData(this.data)}return this.glTexture.descriptor.hasMipmap&&this.glTexture.generateMipmap(),this.data.currentTime},e.prototype.loadFromDDSData=function(e,t){return this.glTexture=h.createDDSTexture(e,this.createDescriptor(e),t,this.params.mipmap),e.bindTexture(this.glTexture),this.glTexture},e.prototype.loadFromPixelData=function(e,t){g.assert(this.params.width>0&&this.params.height>0);var n=this.createDescriptor(e);return n.pixelFormat=1===this.params.components?6409:3===this.params.components?6407:6408,n.width=this.params.width,n.height=this.params.height,this.glTexture=new w(e,n,t),e.bindTexture(this.glTexture),this.glTexture},e.prototype.loadAsync=function(e){return n.__awaiter(this,void 0,void 0,(function(){var t,a,r,i=this;return n.__generator(this,(function(n){return t=c.createAbortController(),this.loadingController=t,a=e(t.signal),this.loadingPromise=a,a.then(r=function(){i.loadingController===t&&(i.loadingController=null),i.loadingPromise===a&&(i.loadingPromise=null)},r),[2,a]}))}))},e.prototype.loadFromURL=function(e,t,a){var r=this;return this.loadAsync((function(i){return n.__awaiter(r,void 0,void 0,(function(){var r;return n.__generator(this,(function(n){switch(n.label){case 0:return[4,p.requestImage(a,{signal:i})];case 1:return r=n.sent(),[2,this.loadFromImage(e,r,t)]}}))}))}))},e.prototype.loadFromImageElement=function(e,t,a){var r=this;return a.complete?this.loadFromImage(e,a,t):this.loadAsync((function(i){return n.__awaiter(r,void 0,void 0,(function(){var r;return n.__generator(this,(function(n){switch(n.label){case 0:return[4,f.loadImageAsync(a,a.src,!1,i)];case 1:return r=n.sent(),[2,this.loadFromImage(e,r,t)]}}))}))}))},e.prototype.loadFromVideoElement=function(e,t,n){return n.readyState>=2?this.loadFromImage(e,n,t):this.loadFromVideoElementAsync(e,t,n)},e.prototype.loadFromVideoElementAsync=function(e,t,n){var a=this;return this.loadAsync((function(i){return c.create((function(o,s){var d=function(){n.removeEventListener("loadeddata",u),n.removeEventListener("error",f),l.isSome(p)&&p.remove()},u=function(){n.readyState>=2&&(d(),o(a.loadFromImage(e,n,t)))},f=function(e){d(),s(e||new r("Failed to load video"))};n.addEventListener("loadeddata",u),n.addEventListener("error",f);var p=c.onAbort(i,(function(){return f(c.createAbortError())}))}))}))},e.prototype.loadFromImage=function(t,n,a){var r=e.getDataDimensions(n);this.params.width=r.width,this.params.height=r.height;var i=this.createDescriptor(t);return i.pixelFormat=3===this.params.components?6407:6408,!this.requiresPowerOfTwo(t,i)||s.isPowerOfTwo(r.width)&&s.isPowerOfTwo(r.height)?(i.width=r.width,i.height=r.height,this.glTexture=new w(t,i,n),t.bindTexture(this.glTexture),this.glTexture):(this.glTexture=this.makePowerOfTwoTexture(t,n,r,i,a),t.bindTexture(this.glTexture),this.glTexture)},e.prototype.requiresPowerOfTwo=function(e,t){var n="number"==typeof t.wrapMode?33071===t.wrapMode:33071===t.wrapMode.s&&33071===t.wrapMode.t;return!S.default(e.gl)&&(t.hasMipmap||!n)},e.prototype.makePowerOfTwoTexture=function(e,t,n,r,i){var s,l=n.width,c=n.height,d=o.nextHighestPowerOfTwo(l),u=o.nextHighestPowerOfTwo(c);switch(r.width=d,r.height=u,this.params.powerOfTwoResizeMode){case 2:r.textureCoordinateScaleFactor=[l/d,c/u],(s=new w(e,r)).updateData(0,0,0,l,c,t);break;case 1:case null:case void 0:s=this.stretchToPowerOfTwo(e,t,r,i);break;default:a.neverReached(this.params.powerOfTwoResizeMode)}return r.hasMipmap&&s.generateMipmap(),s},e.prototype.stretchToPowerOfTwo=function(e,t,n,a){var r=new w(e,n),i=new x(e,{colorTarget:0,depthStencilTarget:0},r),o=new w(e,{target:3553,pixelFormat:n.pixelFormat,dataType:5121,wrapMode:33071,samplingMode:9729,flipped:!!n.flipped,maxAnisotropy:8,preMultiplyAlpha:n.preMultiplyAlpha},t),s=m.createQuadVAO(e);return this.drawStretchedTexture(e,a,i,s,o,r),this.requiresFrameUpdates?this.powerOfTwoStretchInfo={vao:s,sourceTexture:o,framebuffer:i}:(s.dispose(!0),o.dispose(),i.detachColorTexture(),e.bindFramebuffer(null),i.dispose()),r},e.prototype.drawStretchedTexture=function(e,t,n,a,r,i){e.bindFramebuffer(n);var o=e.getViewport();e.setViewport(0,0,i.descriptor.width,i.descriptor.height);var s=t.program;e.bindProgram(s),s.setUniform4f("color",1,1,1,1),s.setUniform1i("tex",0),e.bindTexture(r,0),e.bindVAO(a),e.setPipelineState(t.pipeline),e.drawArrays(5,0,b.vertexCount(a,"geometry")),e.bindFramebuffer(null),e.setViewport(o.x,o.y,o.width,o.height)},e.prototype.unload=function(){if(l.isSome(this.powerOfTwoStretchInfo)){var e=this.powerOfTwoStretchInfo,t=e.framebuffer,n=e.sourceTexture;e.vao.dispose(!0),n.dispose(),t.dispose(),this.glTexture=null,this.powerOfTwoStretchInfo=null}if(l.isSome(this.glTexture)&&(this.glTexture.dispose(),this.glTexture=null),l.isSome(this.loadingController)){var a=this.loadingController;this.loadingController=null,this.loadingPromise=null,a.abort()}this.events.emit("unloaded")},e.idGen=new v.IdGen,e.DDS_ENCODING="image/vnd-ms.dds",e}()}).apply(null,a))||(e.exports=r)}}]);